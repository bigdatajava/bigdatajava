(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{412:function(t,s,a){"use strict";a.r(s);var r=a(5),_=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"redis特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis特性"}},[t._v("#")]),t._v(" Redis特性")]),t._v(" "),s("ol",[s("li",[t._v("非关系型的"),s("strong",[t._v("键值对")]),t._v("数据库，可以根据键以O(1) 的时间复杂度取出或插入关联值")]),t._v(" "),s("li",[t._v("Redis 的数据是存在"),s("strong",[t._v("内存")]),t._v("中的")]),t._v(" "),s("li",[t._v("键值对中键的类型可以是字符串，整型，浮点型等，且键是唯一的")]),t._v(" "),s("li",[t._v("键值对中的值类型可以是string，hash，list，set，sorted set 等")]),t._v(" "),s("li",[t._v("Redis 内置了复制，磁盘持久化，LUA脚本，事务，SSL, ACLs，客户端缓存，客户端代理等功能")]),t._v(" "),s("li",[t._v("通过Redis哨兵和Redis Cluster 模式提供高可用性")])]),t._v(" "),s("h2",{attrs:{id:"应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),s("h3",{attrs:{id:"缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),s("h3",{attrs:{id:"计数器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计数器"}},[t._v("#")]),t._v(" 计数器")]),t._v(" "),s("p",[t._v("可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。")]),t._v(" "),s("h3",{attrs:{id:"分布式id生成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式id生成"}},[t._v("#")]),t._v(" 分布式ID生成")]),t._v(" "),s("p",[t._v("利用自增特性，一次请求一个大一点的步长如 incr 2000 ,缓存在本地使用，用完再请求。")]),t._v(" "),s("h3",{attrs:{id:"海量数据统计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#海量数据统计"}},[t._v("#")]),t._v(" 海量数据统计")]),t._v(" "),s("p",[t._v("位图（bitmap）:存储是否参过某次活动，是否已读谋篇文章，用户是否为会员， 日活统计。")]),t._v(" "),s("h3",{attrs:{id:"会话缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#会话缓存"}},[t._v("#")]),t._v(" 会话缓存")]),t._v(" "),s("p",[t._v("可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。")]),t._v(" "),s("h3",{attrs:{id:"分布式队列-阻塞队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式队列-阻塞队列"}},[t._v("#")]),t._v(" 分布式队列/"),s("strong",[t._v("阻塞队列")])]),t._v(" "),s("p",[t._v("List 是一个双向链表，可以通过 lpush/rpush 和 rpop/lpop 写入和读取消息。可以通过使用brpop/blpop 来实现阻塞队列。")]),t._v(" "),s("h3",{attrs:{id:"分布式锁实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁实现"}},[t._v("#")]),t._v(" 分布式锁实现")]),t._v(" "),s("p",[t._v("在分布式场景下，无法使用基于进程的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁。")]),t._v(" "),s("h3",{attrs:{id:"热点数据存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#热点数据存储"}},[t._v("#")]),t._v(" 热点数据存储")]),t._v(" "),s("p",[t._v("最新评论，最新文章列表，使用list 存储,ltrim取出热点数据，删除老数据。")]),t._v(" "),s("h3",{attrs:{id:"社交类需求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#社交类需求"}},[t._v("#")]),t._v(" 社交类需求")]),t._v(" "),s("p",[t._v("Set 可以实现交集，从而实现共同好友等功能，Set通过求差集，可以进行好友推荐，文章推荐。")]),t._v(" "),s("h3",{attrs:{id:"排行榜"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排行榜"}},[t._v("#")]),t._v(" 排行榜")]),t._v(" "),s("p",[t._v("sorted_set可以实现有序性操作，从而实现排行榜等功能。")]),t._v(" "),s("h3",{attrs:{id:"延迟队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延迟队列"}},[t._v("#")]),t._v(" 延迟队列")]),t._v(" "),s("p",[t._v("使用sorted_set，使用 【当前时间戳 + 需要延迟的时长】做score, 消息内容作为元素,调用zadd来生产消息，消费者使用zrangbyscore获取当前时间之前的数据做轮询处理。消费完再删除任务 rem key member")])])}),[],!1,null,null,null);s.default=_.exports}}]);