(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{406:function(s,e,v){"use strict";v.r(e);var _=v(5),t=Object(_.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"键值设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#键值设计"}},[s._v("#")]),s._v(" 键值设计")]),s._v(" "),e("h3",{attrs:{id:"key名设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key名设计"}},[s._v("#")]),s._v(" key名设计")]),s._v(" "),e("ul",[e("li",[s._v("(1)【建议】: 可读性和可管理性")])]),s._v(" "),e("p",[s._v("以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" trade:order:1       \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("ul",[e("li",[s._v("(2)【建议】：简洁性")])]),s._v(" "),e("p",[s._v("保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("user:{uid}:friends:messages:{mid} 简化为 u:{uid}:fr:m:{mid}      \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("ul",[e("li",[s._v("(3)【强制】：不要包含特殊字符")])]),s._v(" "),e("p",[s._v("反例：包含空格、换行、单双引号以及其他转义字符")]),s._v(" "),e("h3",{attrs:{id:"value设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#value设计"}},[s._v("#")]),s._v(" value设计")]),s._v(" "),e("ul",[e("li",[s._v("(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)")])]),s._v(" "),e("p",[s._v("在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。")]),s._v(" "),e("ol",[e("li",[s._v("字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。")]),s._v(" "),e("li",[s._v("非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。")])]),s._v(" "),e("p",[s._v("一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。")]),s._v(" "),e("p",[s._v("反例：一个包含200万个元素的list。")]),s._v(" "),e("p",[s._v("非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）")]),s._v(" "),e("p",[e("strong",[s._v("bigkey的危害：")])]),s._v(" "),e("p",[s._v("1.导致redis阻塞")]),s._v(" "),e("p",[s._v("2.网络拥塞")]),s._v(" "),e("p",[s._v("bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例也造成影响，其后果不堪设想。")]),s._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[s._v("过期删除")])]),s._v(" "),e("p",[s._v("有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除("),e("strong",[s._v("lazyfree-lazy-expire yes")]),s._v(")，就会存在阻塞Redis的可能性。")]),s._v(" "),e("p",[e("strong",[s._v("bigkey的产生：")])]),s._v(" "),e("p",[s._v("一般来说，bigkey的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：")]),s._v(" "),e("p",[s._v("(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。")]),s._v(" "),e("p",[s._v("(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。")]),s._v(" "),e("p",[s._v("(3) 缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey。")]),s._v(" "),e("p",[e("strong",[s._v("如何优化bigkey")])]),s._v(" "),e("ol",[e("li",[s._v("拆")])]),s._v(" "),e("p",[s._v("big list： list1、list2、...listN")]),s._v(" "),e("p",[s._v("big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据")]),s._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[s._v("如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。")])]),s._v(" "),e("ul",[e("li",[s._v("(2)【推荐】：选择适合的数据类型。")])]),s._v(" "),e("p",[s._v("例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡)")]),s._v(" "),e("p",[s._v("反例：")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("set user:1:name tom \nset user:1:age 19 \nset user:1:favor football \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("正例:")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("hmset user:1 name tom age 19 favor football      \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("3.【推荐】：控制key的生命周期，redis不是垃圾桶。")]),s._v(" "),e("p",[s._v("建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。")]),s._v(" "),e("h2",{attrs:{id:"命令优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令优化"}},[s._v("#")]),s._v(" 命令优化")]),s._v(" "),e("p",[s._v("1.【推荐】 O(N)命令关注N的数量")]),s._v(" "),e("p",[s._v("例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。")]),s._v(" "),e("p",[s._v("2.【推荐】：禁用命令")]),s._v(" "),e("p",[s._v("禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。")]),s._v(" "),e("p",[s._v("3.【推荐】合理使用select")]),s._v(" "),e("p",[s._v("redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。")]),s._v(" "),e("p",[s._v("4.【推荐】使用批量操作提高效率")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("原生命令：例如mget、mset。 \n非原生命令：可以使用pipeline提高效率。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。")]),s._v(" "),e("p",[s._v("注意两者不同：")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("1. 原生命令是原子操作，pipeline是非原子操作。 \n2. pipeline可以打包不同的命令，原生命令做不到 \n3. pipeline需要客户端和服务端同时支持。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("5.【建议】Redis事务功能较弱，不建议过多使用，可以用lua替代")]),s._v(" "),e("h2",{attrs:{id:"客户端优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端优化"}},[s._v("#")]),s._v(" 客户端优化")]),s._v(" "),e("p",[s._v("1.【推荐】")]),s._v(" "),e("p",[s._v("避免多个应用使用一个Redis实例")]),s._v(" "),e("p",[s._v("正例：不相干的业务拆分，公共数据做服务化。")]),s._v(" "),e("p",[s._v("2.【推荐】")]),s._v(" "),e("p",[s._v("使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\njedisPoolConfig.setMaxTotal(5);\njedisPoolConfig.setMaxIdle(2);\njedisPoolConfig.setTestOnBorrow(true);\n\nJedisPool jedisPool = new JedisPool(jedisPoolConfig, "192.168.0.60", 6379, 3000, null);\n\nJedis jedis = null;\ntry {\n    jedis = jedisPool.getResource();\n    //具体的命令\n    jedis.executeCommand()\n} catch (Exception e) {\n    logger.error("op key {} error: " + e.getMessage(), key, e);\n} finally {\n    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。\n    if (jedis != null) \n        jedis.close();\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br")])]),e("p",[s._v("连接池参数含义：")]),s._v(" "),e("table",[e("thead",[e("tr",[e("th",[s._v("序号")]),s._v(" "),e("th",[s._v("参数名")]),s._v(" "),e("th",[s._v("含义")]),s._v(" "),e("th",[s._v("默认值")]),s._v(" "),e("th",[s._v("使用建议")])])]),s._v(" "),e("tbody",[e("tr",[e("td",[s._v("1")]),s._v(" "),e("td",[s._v("maxTotal")]),s._v(" "),e("td",[s._v("资源池中最大连接数")]),s._v(" "),e("td",[s._v("8")]),s._v(" "),e("td",[s._v("设置建议见下面")])]),s._v(" "),e("tr",[e("td",[s._v("2")]),s._v(" "),e("td",[s._v("maxIdle")]),s._v(" "),e("td",[s._v("资源池允许最大空闲的连接数")]),s._v(" "),e("td",[s._v("8")]),s._v(" "),e("td",[s._v("设置建议见下面")])]),s._v(" "),e("tr",[e("td",[s._v("3")]),s._v(" "),e("td",[s._v("minIdle")]),s._v(" "),e("td",[s._v("资源池确保最少空闲的连接数")]),s._v(" "),e("td",[s._v("0")]),s._v(" "),e("td",[s._v("设置建议见下面")])]),s._v(" "),e("tr",[e("td",[s._v("4")]),s._v(" "),e("td",[s._v("blockWhenExhausted")]),s._v(" "),e("td",[s._v("当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效")]),s._v(" "),e("td",[s._v("true")]),s._v(" "),e("td",[s._v("建议使用默认值")])]),s._v(" "),e("tr",[e("td",[s._v("5")]),s._v(" "),e("td",[s._v("maxWaitMillis")]),s._v(" "),e("td",[s._v("当资源池连接用尽后，调用者的最大等待时间(单位为毫秒)")]),s._v(" "),e("td",[s._v("-1：表示永不超时")]),s._v(" "),e("td",[s._v("不建议使用默认值")])]),s._v(" "),e("tr",[e("td",[s._v("6")]),s._v(" "),e("td",[s._v("testOnBorrow")]),s._v(" "),e("td",[s._v("向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除")]),s._v(" "),e("td",[s._v("false")]),s._v(" "),e("td",[s._v("业务量很大时候建议设置为false(多一次ping的开销)。")])]),s._v(" "),e("tr",[e("td",[s._v("7")]),s._v(" "),e("td",[s._v("testOnReturn")]),s._v(" "),e("td",[s._v("向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除")]),s._v(" "),e("td",[s._v("false")]),s._v(" "),e("td",[s._v("业务量很大时候建议设置为false(多一次ping的开销)。")])]),s._v(" "),e("tr",[e("td",[s._v("8")]),s._v(" "),e("td",[s._v("jmxEnabled")]),s._v(" "),e("td",[s._v("是否开启jmx监控，可用于监控")]),s._v(" "),e("td",[s._v("true")]),s._v(" "),e("td",[s._v("建议开启，但应用本身也要开启")])])])]),s._v(" "),e("p",[e("strong",[s._v("优化建议：")])]),s._v(" "),e("p",[s._v("1）"),e("strong",[s._v("maxTotal")]),s._v("：最大连接数，早期的版本叫maxActive")]),s._v(" "),e("p",[s._v("实际上这个是一个很难回答的问题，考虑的因素比较多：")]),s._v(" "),e("ul",[e("li",[s._v("业务希望Redis并发量")]),s._v(" "),e("li",[s._v("客户端执行命令时间")]),s._v(" "),e("li",[s._v("Redis资源：例如 nodes(例如应用个数) * maxTotal 是不能超过redis的最大连接数maxclients。")]),s._v(" "),e("li",[s._v("资源开销：例如虽然希望控制"),e("strong",[s._v("空闲连接")]),s._v("(连接池此刻可马上使用的连接)，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。")])]),s._v(" "),e("p",[e("strong",[s._v("以一个例子说明")]),s._v("，假设:")]),s._v(" "),e("ul",[e("li",[s._v("一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为1ms，一个连接的QPS大约是1000")]),s._v(" "),e("li",[s._v("业务期望的QPS是50000")])]),s._v(" "),e("p",[s._v("那么理论上需要的资源池大小是50000 / 1000 = 50个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。")]),s._v(" "),e("p",[s._v("但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种高QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。")]),s._v(" "),e("p",[s._v("2）"),e("strong",[s._v("maxIdle和minIdle")])]),s._v(" "),e("p",[s._v("maxIdle实际上才是业务需要的最大连接数，maxTotal是为了"),e("strong",[s._v("给出余量")]),s._v("，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销。")]),s._v(" "),e("p",[e("strong",[s._v("连接池的最佳性能是maxTotal = maxIdle")]),s._v("，这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxTotal可以再放大一倍。")]),s._v(" "),e("p",[s._v('minIdle（最小空闲连接数），与其说是最小空闲连接数，不如说是"'),e("strong",[s._v("至少需要保持的空闲连接数")]),s._v('"，在使用连接的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了maxIdle，当超过的连接执行完业务后会慢慢被移出连接池释放掉。')]),s._v(" "),e("p",[s._v("如果系统启动完马上就会有很多的请求过来，那么可以给redis连接池做"),e("strong",[s._v("预热")]),s._v("，比如快速的创建一些redis连接，执行简单命令，类似ping()，快速的将连接池里的空闲连接提升到minIdle的数量。")]),s._v(" "),e("p",[e("strong",[s._v("连接池预热")]),s._v("示例代码：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("List<Jedis> minIdleJedisList = new ArrayList<Jedis>(jedisPoolConfig.getMinIdle());\n\nfor (int i = 0; i < jedisPoolConfig.getMinIdle(); i++) {\n    Jedis jedis = null;\n    try {\n        jedis = pool.getResource();\n        minIdleJedisList.add(jedis);\n        jedis.ping();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    } finally {\n        //注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接。。\n        //jedis.close();\n    }\n}\n//统一将预热的连接还回连接池\nfor (int i = 0; i < jedisPoolConfig.getMinIdle(); i++) {\n    Jedis jedis = null;\n    try {\n        jedis = minIdleJedisList.get(i);\n        //将连接归还回连接池\n        jedis.close();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    } finally {\n    }\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("总之，要根据实际系统的QPS和调用redis客户端的规模整体评估每个节点所使用的连接池大小。")]),s._v(" "),e("p",[s._v("3.【建议】")]),s._v(" "),e("p",[s._v("高并发下建议客户端添加熔断功能(例如sentinel、hystrix)")]),s._v(" "),e("p",[s._v("4.【推荐】")]),s._v(" "),e("p",[s._v("设置合理的密码，如有必要可以使用SSL加密访问")]),s._v(" "),e("p",[s._v("5.【建议】")]),s._v(" "),e("p",[e("strong",[s._v("Redis对于过期键有三种清除策略：")])]),s._v(" "),e("ol",[e("li",[s._v("被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key")]),s._v(" "),e("li",[s._v("主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批"),e("strong",[s._v("已过期")]),s._v("的key")]),s._v(" "),e("li",[s._v("当前已用内存超过maxmemory限定时，触发"),e("strong",[s._v("主动清理策略")])])]),s._v(" "),e("p",[e("strong",[s._v("主动清理策略")]),s._v("在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：")]),s._v(" "),e("p",[e("strong",[s._v("a) 针对设置了过期时间的key做处理：")])]),s._v(" "),e("ol",[e("li",[s._v("volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。")]),s._v(" "),e("li",[s._v("volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。")]),s._v(" "),e("li",[s._v("volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。")]),s._v(" "),e("li",[s._v("volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。")])]),s._v(" "),e("p",[e("strong",[s._v("b) 针对所有的key做处理：")])]),s._v(" "),e("ol",[e("li",[s._v("allkeys-random：从所有键值对中随机选择并删除数据。")]),s._v(" "),e("li",[s._v("allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。")]),s._v(" "),e("li",[s._v("allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。")])]),s._v(" "),e("p",[e("strong",[s._v("c) 不处理：")])]),s._v(" "),e("ol",[e("li",[s._v('noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error) OOM command not allowed when used memory"，此时Redis只响应读操作。')])]),s._v(" "),e("p",[e("strong",[s._v("LRU 算法")]),s._v("**（Least Recently Used，最近最少使用）**")]),s._v(" "),e("p",[s._v("淘汰很久没被访问过的数据，以"),e("strong",[s._v("最近一次访问时间")]),s._v("作为参考。")]),s._v(" "),e("p",[e("strong",[s._v("LFU 算法")]),s._v("**（Least Frequently Used，最不经常使用）**")]),s._v(" "),e("p",[s._v("淘汰最近一段时间被访问次数最少的数据，以"),e("strong",[s._v("次数")]),s._v("作为参考。")]),s._v(" "),e("p",[s._v("当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。")]),s._v(" "),e("p",[s._v("根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。")]),s._v(" "),e("p",[s._v("当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。")])])}),[],!1,null,null,null);e.default=t.exports}}]);