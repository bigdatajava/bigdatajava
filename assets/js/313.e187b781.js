(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{656:function(e,l,t){"use strict";t.r(l);var a=t(1),o=Object(a.a)({},(function(){var e=this,l=e._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"hashmap的put方法的大体流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的put方法的大体流程"}},[e._v("#")]),e._v(" HashMap的Put方法的大体流程")]),e._v(" "),l("ol",[l("li",[l("p",[e._v("根据Key通过哈希算法与与运算得出数组下标")])]),e._v(" "),l("li",[l("p",[e._v("如果数组下标位置元素为空，则将key和value封装为Node对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位置")])]),e._v(" "),l("li",[l("p",[e._v("如果数组下标位置元素不为空，则要分情况讨论")])]),e._v(" "),l("li",[l("ol",[l("li",[e._v("如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中")]),e._v(" "),l("li",[e._v("如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node")])])]),e._v(" "),l("li",[l("ol",[l("li",[l("ol",[l("li",[e._v("如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value")]),e._v(" "),l("li",[e._v("如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于8，那么则会将该链表转成红黑树")])])])])]),e._v(" "),l("li",[l("ol",[l("li",[l("ol",[l("li",[e._v("将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法")])])])])])]),e._v(" "),l("p",[e._v("源码：")]),e._v(" "),l("p",[l("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/map/image-20211104164546844.png",alt:""}})])])}),[],!1,null,null,null);l.default=o.exports}}]);