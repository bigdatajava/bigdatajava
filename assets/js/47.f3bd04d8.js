(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{389:function(s,e,t){"use strict";t.r(e);var a=t(1),r=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"redis是单线程吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis是单线程吗"}},[s._v("#")]),s._v(" Redis是单线程吗？")]),s._v(" "),e("p",[s._v("Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。")]),s._v(" "),e("h2",{attrs:{id:"redis-单线程为什么还能这么快"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-单线程为什么还能这么快"}},[s._v("#")]),s._v(" Redis 单线程为什么还能这么快？")]),s._v(" "),e("p",[s._v("因为它所有的数据都在"),e("strong",[s._v("内存")]),s._v("中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。")]),s._v(" "),e("h2",{attrs:{id:"redis-单线程如何处理那么多的并发客户端连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-单线程如何处理那么多的并发客户端连接"}},[s._v("#")]),s._v(" Redis 单线程如何处理那么多的并发客户端连接？")]),s._v(" "),e("p",[s._v("Redis的"),e("strong",[s._v("IO多路复用")]),s._v("：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/redis/8.png",alt:""}})]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('# 查看redis支持的最大连接数，在redis.conf文件中可修改，# maxclients 10000\n127.0.0.1:6379> CONFIG GET maxclients\n    ##1) "maxclients"\n    ##2) "10000"\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("​")]),s._v(" "),e("p",[s._v("​")])])}),[],!1,null,null,null);e.default=r.exports}}]);