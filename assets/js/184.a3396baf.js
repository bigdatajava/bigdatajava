(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{528:function(s,a,t){"use strict";t.r(a);var r=t(1),e=Object(r.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("U2FsdGVkX18OeYKgh4CgzsR0effDDx7HB0+Sa/KBWVISyjIb6q8eZLKZowJ4U7ls\nWr/rQPEtlvKta8yohOLQEUEtKeUMZZH/i2JH7a9QvXVsCNZkGGAd2LKbbMQ0T5T/\naQ==\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h2",{attrs:{id:"日志框架发展史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#日志框架发展史"}},[s._v("#")]),s._v(" 日志框架发展史")]),s._v(" "),a("p",[s._v("早年，你工作的时候，在日志里使用了log4j框架来输出，于是你代码是这么写的")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('import org.apache.log4j.Logger;\n\\\\省略\nLogger logger = Logger.getLogger(Test.class);\nlogger.trace("trace");\n\\\\省略\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("但是，岁月流逝，sun公司对于log4j的出现内心隐隐表示嫉妒。于是在jdk1.4版本后，增加了一个包为java.util.logging，简称为jul，用以对抗log4j。于是，你的领导要你把日志框架改为jul，这时候你只能一行行的将log4j的api改为jul的api，如下所示")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('import java.util.logging.Logger；\n\\\\省略\nLogger loggger = Logger.getLogger(Test.class.getName()); \nlogger.finest("finest");\n\\\\省略\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("可以看出，api完全是不同的。那有没有办法，将这些api抽象出接口，这样以后调用的时候，就调用这些接口就好了呢？")]),s._v(" "),a("p",[s._v("这个时候"),a("strong",[s._v("jcl")]),s._v("(Jakarta Commons Logging)出现了，说jcl可能大家有点陌生，讲commons-logging-xx.jar组件，大家总有印象吧。JCL 只提供 log 接口，具体的实现则在运行时动态寻找。这样一来组件开发者只需要针对 JCL 接口开发，而调用组件的应用程序则可以在运行时搭配自己喜好的日志实践工具。JCL可以实现的集成方案如下图所示")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200023940.png",alt:"image-20220617200023940"}})]),s._v(" "),a("p",[s._v("jcl默认的配置：如果能找到Log4j 则默认使用log4j 实现，如果没有则使用jul(jdk自带的) 实现，再没有则使用jcl内部提供的SimpleLog 实现。")]),s._v(" "),a("p",[s._v("于是，你在代码里变成这么写了")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("apache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("commons"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("logging"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Log")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("apache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("commons"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("logging"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LogFactory")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\\\\省略\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Log")]),s._v(" log "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LogFactory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getLog")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nlog"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("trace")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[s._v("'trace'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\\\\省略\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("至于这个Log具体的实现类，JCL会在ClassLoader中进行查找。这么做，有三个缺点，缺点一是效率较低，二是容易引发混乱，三是在使用了自定义ClassLoader的程序中，使用JCL会引发内存泄露。")]),s._v(" "),a("p",[s._v("于是log4j的作者觉得jcl不好用，自己又写了一个新的接口api，那么就是slf4j。关于slf4j的集成图如下所示")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200046836.png",alt:"image-20220617200046836"}})]),s._v(" "),a("h2",{attrs:{id:"slf4j与其他各种日志组件的桥接说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slf4j与其他各种日志组件的桥接说明"}},[s._v("#")]),s._v(" Slf4j与其他各种日志组件的桥接说明")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("jar包名")]),s._v(" "),a("th",[s._v("说明")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[s._v("slf4j-log4j12-1.7.13.jar")])]),s._v(" "),a("td",[s._v("Log4j1.2版本的桥接器，你需要将Log4j.jar加入Classpath。")])]),s._v(" "),a("tr",[a("td",[a("strong",[s._v("slf4j-jdk14-1.7.13.jar")])]),s._v(" "),a("td",[s._v("java.util.logging的桥接器，Jdk原生日志框架。")])]),s._v(" "),a("tr",[a("td",[a("strong",[s._v("slf4j-nop-1.7.13.jar")])]),s._v(" "),a("td",[s._v("NOP桥接器，默默丢弃一切日志。")])]),s._v(" "),a("tr",[a("td",[a("strong",[s._v("slf4j-simple-1.7.13.jar")])]),s._v(" "),a("td",[s._v("一个简单实现的桥接器，该实现输出所有事件到System.err. 只有Info以及高于该级别的消息被打印，在小型应用中它也许是有用的。")])]),s._v(" "),a("tr",[a("td",[a("strong",[s._v("slf4j-jcl-1.7.13.jar")])]),s._v(" "),a("td",[s._v("Jakarta Commons Logging 的桥接器. 这个桥接器将Slf4j所有日志委派给Jcl。")])]),s._v(" "),a("tr",[a("td",[a("strong",[s._v("logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)")])]),s._v(" "),a("td",[s._v("Slf4j的原生实现，Logback直接实现了Slf4j的接口，因此使用Slf4j与Logback的结合使用也意味更小的内存与计算开销")])])])]),s._v(" "),a("p",[s._v("如图所示，应用调了sl4j-api，即日志门面接口。日志门面接口本身通常并没有实际的日志输出能力，它底层还是需要去调用具体的日志框架API的，也就是实际上它需要跟具体的日志框架结合使用。由于具体日志框架比较多，而且互相也大都不兼容，日志门面接口要想实现与任意日志框架结合可能需要对应的桥接器，上图红框中的组件即是对应的各种桥接器！")]),s._v(" "),a("p",[s._v("我们在代码中需要写日志，变成下面这么写")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n//省略\nLogger logger = LoggerFactory.getLogger(Test.class);\n// 省略\nlogger.info("info");\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("在代码中，并不会出现具体日志框架的api。程序根据classpath中的桥接器类型，和日志框架类型，判断出logger.info应该以什么框架输出！注意了，如果classpath中不小心引了两个桥接器，那会直接报错的！")]),s._v(" "),a("p",[s._v("因此，在阿里的开发手册上才有这么一条")]),s._v(" "),a("blockquote",[a("p",[s._v("强制：应用中不可直接使用日志系统（log4j、logback）中的 API ，而应依赖使用日志框架 SLF4J 中的 API 。")]),s._v(" "),a("p",[s._v("使用门面模式的日志框架，有利于维护和各个类的日志处理方式的统一。")])]),s._v(" "),a("h2",{attrs:{id:"如果要将jcl或jul-转slf4j呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果要将jcl或jul-转slf4j呢"}},[s._v("#")]),s._v(" 如果要将jcl或jul 转slf4j呢？")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200101913.png",alt:"image-20220617200101913"}})]),s._v(" "),a("p",[s._v("ok，至此，基础知识完毕，下面是实战！")]),s._v(" "),a("h2",{attrs:{id:"日志实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#日志实战"}},[s._v("#")]),s._v(" 日志实战")]),s._v(" "),a("h3",{attrs:{id:"案例一-一个项目-一个模块用log4j-另一个模块用slf4j-log4j2-如何统一输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例一-一个项目-一个模块用log4j-另一个模块用slf4j-log4j2-如何统一输出"}},[s._v("#")]),s._v(" 案例一：一个项目，一个模块用log4j，另一个模块用slf4j+log4j2,如何统一输出？")]),s._v(" "),a("p",[s._v("其实在某些中小型公司，这种情况很常见。我曾经见过某公司的项目，因为研发不懂底层的日志原理，日志文件里头既有log4j.properties,又有log4j2.xml，各种API混用，惨不忍睹!")]),s._v(" "),a("p",[s._v("还有人用着jul的API，然后拿着log4j.properties，跑来问我，为什么配置不生效！简直是一言难尽！")]),s._v(" "),a("p",[s._v("OK，回到我们的问题，如何统一输出！OK，这里就要用上slf4j的适配器，slf4j提供了各种各样的适配器，用来将某种日志框架委托给slf4j。其最明显的集成工作方式有如下:")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200116257.png",alt:"image-20220617200116257"}})]),s._v(" "),a("p",[s._v("进行选择填空，将我们的案例里的条件填入,根据题意应该选log4j-over-slf4j适配器，于是就变成下面这张图")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200129286.png",alt:"image-20220617200129286"}})]),s._v(" "),a("p",[s._v("就可以实现日志统一为log4j2来输出！")]),s._v(" "),a("blockquote",[a("p",[s._v("根据适配器工作原理的不同，被适配的日志框架并不是一定要删除！")]),s._v(" "),a("p",[s._v("以上图为例，log4j这个日志框架删不删都可以，你只要能保证log4j的加载顺序在log4j-over-slf4j后即可，因为log4j-over-slf4j这个适配器的工作原理是，内部提供了和log4j一模一样的api接口，因此你在程序中调用log4j的api的时候，你必须想办法让其走适配器的api。")]),s._v(" "),a("p",[s._v("如果你删了log4j这个框架，那你程序里肯定是走log4j-over-slf4j这个组件里的api。")]),s._v(" "),a("p",[s._v("如果不删log4j，只要保证其在classpth里的顺序比log4j前即可！")])]),s._v(" "),a("h3",{attrs:{id:"案例二-如何让spring以log4j2的形式输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例二-如何让spring以log4j2的形式输出"}},[s._v("#")]),s._v(" 案例二：如何让spring以log4j2的形式输出？")]),s._v(" "),a("p",[s._v("spring默认使用的是jcl输出日志，由于你此时并没有引入Log4j的日志框架，jcl会以jul做为日志框架。此时集成图如下")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200212957.png",alt:"image-20220617200212957"}})]),s._v(" "),a("p",[s._v("而你的应用中，采用了slf4j+log4j-core，即log4j2进行日志记录，那么此时集成图如下")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200222541.png",alt:"image-20220617200222541"}})]),s._v(" "),a("p",[s._v("那我们现在需要让spring以log4j2的形式输出？怎么办？")]),s._v(" "),a("p",[s._v("**第一种方案，**走jcl-over-slf4j适配器，此时集成图就变成下面这样了")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200235430.png",alt:"image-20220617200235430"}})]),s._v(" "),a("p",[s._v("在这种方案下，spring框架中遇到日志输出的语句，就会如上图红线流程一样，最终以log4J2的形式输出！")]),s._v(" "),a("p",[a("strong",[s._v("有第二种方案么？")])]),s._v(" "),a("p",[s._v("有，走jul-to-slf4j适配器，此时集成图如下")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200251953.png",alt:"image-20220617200251953"}})]),s._v(" "),a("p",[s._v("ps:这种情况下，记得在代码中执行")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("SLF4JBridgeHandler.removeHandlersForRootLogger();\nSLF4JBridgeHandler.install();\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("这样jul-to-slf4j适配器才能正常工作，详情可以查询该适配器工作原理。")]),s._v(" "),a("p",[s._v("天啦噜！要死循环")]),s._v(" "),a("p",[s._v("假设，我们在应用中调用了sl4j-api，但是呢，你引了四个jar包，slf4j-api-xx.jar,slf4j-log4j12-xx.jar,log4j-xx.jar,log4j-over-slf4j-xx.jar，于是你就会出现如下尴尬的场面")]),s._v(" "),a("p",[s._v("​")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200303323.png",alt:"image-20220617200303323"}})]),s._v(" "),a("p",[s._v("如上图所示，在这种情况下，你调用了slf4j-api，就会陷入死循环中！slf4j-api去调了slf4j-log4j12,slf4j-log4j12又去调用了log4j，log4j去调用了log4j-over-slf4j。最终，log4j-over-slf4j又调了slf4j-api，陷入死循环！")]),s._v(" "),a("h2",{attrs:{id:"spring4和spring5日志中的不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring4和spring5日志中的不同"}},[s._v("#")]),s._v(" spring4和spring5日志中的不同")]),s._v(" "),a("h3",{attrs:{id:"spring4日志体系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring4日志体系"}},[s._v("#")]),s._v(" Spring4日志体系")]),s._v(" "),a("p",[s._v("构建spring4项目：采用java+注解的方式快速构建，pom中只引入spring-context包")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200335809.png",alt:"image-20220617200335809"}})]),s._v(" "),a("p",[s._v("运行下面的代码，可以看到有日志输出")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200401363.png",alt:"image-20220617200401363"}})]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200411909.png",alt:"image-20220617200411909"}})]),s._v(" "),a("p",[s._v("找到打印日志的地方，debug模式下，查看输出日志的Log是什么log")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200421772.png",alt:"image-20220617200421772"}})]),s._v(" "),a("p",[s._v("可以看出是jdk14Logger，这个在JCL中说过，这个指的是JUL，也就是说在默认spring日志体系下，采用的是JUL，")]),s._v(" "),a("p",[s._v("接下来，我们按照之前的方法引入log4j，debug运行上面的程序，再次查看日志类型")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200430048.png",alt:"image-20220617200430048"}})]),s._v(" "),a("p",[s._v("​    额，这次在增加log4j jar包和配置文件的情况下，spring4有使用了log4j，这么像JCL呢，木错，让我们在idea中打开spring4的日志依赖结构：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200438458.png",alt:"image-20220617200438458"}})]),s._v(" "),a("p",[s._v("common-logging 这不就是JCL使用到的包吗，可以看出，Spring4使用的是原生的JCL，所以在有log4j的时候使用log4j打印日志，没有的时候使用JUL打印日志。")]),s._v(" "),a("h3",{attrs:{id:"spring5日志体系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring5日志体系"}},[s._v("#")]),s._v(" Spring5日志体系")]),s._v(" "),a("p",[s._v("线上依赖结构图：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200512620.png",alt:"image-20220617200512620"}})]),s._v(" "),a("p",[s._v("答题结构没变，只是原来common-logging ，换成了spring-jcl，看名字就知道是spring自造的包，jcl，更是标注了，它使用的是JCL日志体系。")]),s._v(" "),a("p",[s._v("所以还是看源码吧。")]),s._v(" "),a("p",[s._v("按照之前的经验，我们只用debug找到spring内部一个Log，看看他的产生方式和类型。这次我给大家找了AbstractApplicationContext里面找到产生Log的地方")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200536935.png",alt:"image-20220617200536935"}})]),s._v(" "),a("p",[s._v("进入这个方法的getLog()中，一直深入，不要怜惜spring，找到LogAdapter中的createLog()方法")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200548277.png",alt:"image-20220617200548277"}})]),s._v(" "),a("p",[s._v("可以看出来spring5中对日志的生产，不在像原生JCL中那样使用一个数组，然后进行循环产生，这里用到的是Switch case,这个关键字段LogApi又是在哪一部分赋值的呢？看图")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200558317.png",alt:"image-20220617200558317"}})]),s._v(" "),a("p",[s._v("Duang ,没错是在静态代码块中赋的值，为了验证，我们准备用其中提到的log4j2验证（注意：log4j不行，因为这里的switch没有log4j选项），首先我们准备log4j2的配置文件")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<Configuration status="WARN">\n<Appenders>\n<Console name="Console" target="SYSTEM_OUT">\n<PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>\n</Console>\n</Appenders>\n<Loggers>\n<Root level="debug">\n<AppenderRef ref="Console"/>\n</Root>\n</Loggers>\n</Configuration>\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("然后准备pom")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200609432.png",alt:"image-20220617200609432"}})]),s._v(" "),a("p",[s._v("代码还是这一行，直接运行：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200618446.png",alt:"image-20220617200618446"}})]),s._v(" "),a("p",[s._v("结果有日志打印出来了")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/spring/image-20220617200626780.png",alt:"image-20220617200626780"}})]),s._v(" "),a("p",[s._v("所以，在spring5中，依然使用的是JCL，但是不是原生的，是经过改造的JCL，默认使用的是JUL，而原生JCL中默认使用的是log4j.")])])}),[],!1,null,null,null);a.default=e.exports}}]);