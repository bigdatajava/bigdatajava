(window.webpackJsonp=window.webpackJsonp||[]).push([[212],{579:function(s,n,e){"use strict";e.r(n);var a=e(5),t=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("hr"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("U2FsdGVkX1/6TknILXhCFweX1cqc2ede1fTkdCNlKcySjvLvYZOJmREgzuwVLpnZ\nZtH96sdhA1KynTj9l0u6CXV7vX5YuJOPaWkFfBTMuyZNMoc7bZEQVEJu3vWX5cyK\nxA==\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("h2",{attrs:{id:"scheduledthreadpoolexecutor定时线程池类的类结构图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#scheduledthreadpoolexecutor定时线程池类的类结构图"}},[s._v("#")]),s._v(" ScheduledThreadPoolExecutor定时线程池类的类结构图")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/60.png",alt:""}})]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/61.png",alt:""}})]),s._v(" "),n("p",[s._v("ScheduledThreadPoolExecutor：它用来处理延时任务或定时任务。它接收SchduledFutureTask类型的任务，采用DelayQueue存储等待的任务,有三种提交任务的方式：")]),s._v(" "),n("blockquote",[n("p",[s._v("schedule")]),s._v(" "),n("p",[s._v("scheduledAtFixedRate")]),s._v(" "),n("p",[s._v("scheduledWithFixedDelay")])]),s._v(" "),n("h2",{attrs:{id:"schduledfuturetask"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#schduledfuturetask"}},[s._v("#")]),s._v(" SchduledFutureTask")]),s._v(" "),n("p",[s._v("SchduledFutureTask接收的参数(成员变量)：")]),s._v(" "),n("blockquote",[n("p",[s._v("private long time：任务开始的时间")]),s._v(" "),n("p",[s._v("private final long "),n("strong",[s._v("sequenceNumber")]),s._v(";：任务的序号")]),s._v(" "),n("p",[s._v("private final long "),n("strong",[s._v("period")]),s._v("：任务执行的时间间隔")])]),s._v(" "),n("h3",{attrs:{id:"工作线程的执行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#工作线程的执行过程"}},[s._v("#")]),s._v(" 工作线程的执行过程")]),s._v(" "),n("p",[s._v("工作线程会从DelayQueue取已经到期的任务去执行；执行结束后重新设置任务的到期时间，再次放回DelayQueue")]),s._v(" "),n("p",[s._v("ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序。")]),s._v(" "),n("h3",{attrs:{id:"排序算法-compareto方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#排序算法-compareto方法"}},[s._v("#")]),s._v(" 排序算法-compareTo方法")]),s._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("compareTo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Delayed")]),s._v(" other"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("other "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// compare zero if same object")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("other "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("instanceof")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ScheduledFutureTask")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ScheduledFutureTask")]),n("span",{pre:!0,attrs:{class:"token generics"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ScheduledFutureTask")]),n("span",{pre:!0,attrs:{class:"token generics"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("other"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" diff "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" time "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("time"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("diff "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("diff "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("sequenceNumber "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("sequenceNumber"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" diff "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("getDelay")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NANOSECONDS")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" other"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("getDelay")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NANOSECONDS")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("diff "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("diff "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br")])]),n("blockquote",[n("p",[s._v("首先按照time排序，time小的排在前面，time大的排在后面；")]),s._v(" "),n("p",[s._v("如果time相同，按照sequenceNumber排序，sequenceNumber小的排在前面，sequenceNumber大的排在后面，")]),s._v(" "),n("p",[s._v("换句话说，如果两个task的执行时间相同，优先执行先提交的task。")])]),s._v(" "),n("h3",{attrs:{id:"调度task-run方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#调度task-run方法"}},[s._v("#")]),s._v(" 调度task-run方法")]),s._v(" "),n("p",[s._v("run方法是调度task的核心，task的执行实际上是run方法的执行。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public void run() {\n    boolean periodic = isPeriodic();\n//如果当前线程池已经不支持执行任务，则取消\n    if (!canRunInCurrentRunState(periodic))\n        cancel(false);\n//如果不需要周期性执行，则直接执行run方法然后结束\n    else if (!periodic)\n        ScheduledFutureTask.super.run();\n//如果需要周期执行，则在执行完任务以后，设置下一次执行时间\n    else if (ScheduledFutureTask.super.runAndReset()) {\n        // 计算下次执行该任务的时间\n setNextRunTime();\n //重复执行任务\n        reExecutePeriodic(outerTask);\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("blockquote",[n("ol",[n("li",[s._v("如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；")]),s._v(" "),n("li",[s._v("如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后直接返回，否则执行步骤3；")]),s._v(" "),n("li",[s._v("如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；")]),s._v(" "),n("li",[s._v("计算下次执行该任务的具体时间；")]),s._v(" "),n("li",[s._v("重复执行任务。")])])]),s._v(" "),n("h3",{attrs:{id:"reexecuteperiodic方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reexecuteperiodic方法"}},[s._v("#")]),s._v(" reExecutePeriodic方法")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void reExecutePeriodic(RunnableScheduledFuture<?> task) {\n    if (canRunInCurrentRunState(true)) {\n        super.getQueue().add(task);\n        if (!canRunInCurrentRunState(true) && remove(task))\n            task.cancel(false);\n        else\n            ensurePrestart();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("p",[s._v("该方法和delayedExecute方法类似，不同的是：")]),s._v(" "),n("ol",[n("li",[s._v("由于调用reExecutePeriodic方法时已经执行过一次周期性任务了，所以不会reject当前任务；")]),s._v(" "),n("li",[s._v("传入的任务一定是周期性任务。")])]),s._v(" "),n("h2",{attrs:{id:"线程池任务的提交"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程池任务的提交"}},[s._v("#")]),s._v(" 线程池任务的提交")]),s._v(" "),n("p",[s._v("首先是schedule方法，该方法是指任务在指定延迟时间到达后触发，只会执行一次。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public ScheduledFuture<?> schedule(Runnable command,\n                                   long delay,\n                                   TimeUnit unit) {\n//参数校验\nif (command == null || unit == null)\n        throw new NullPointerException();\n//这里是一个嵌套结构，首先把用户提交的任务包装成ScheduledFutureTask\n//然后在调用decorateTask进行包装，该方法是留给用户去扩展的，默认是个空方法\n    RunnableScheduledFuture<?> t = decorateTask(command,\n        new ScheduledFutureTask<Void>(command, null,\n                                      triggerTime(delay, unit)));\n   //包装好任务以后，就进行提交了\ndelayedExecute(t);\n    return t;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("p",[s._v("任务提交方法：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("private void delayedExecute(RunnableScheduledFuture<?> task) {\n    //如果线程池已经关闭，则使用拒绝策略把提交任务拒绝掉\nif (isShutdown())\n        reject(task);\n    else {\n//与ThreadPoolExecutor不同，这里直接把任务加入延迟队列\n        super.getQueue().add(task);//使用用的DelayedWorkQueue\n//如果当前状态无法执行任务，则取消\n        if (isShutdown() &&\n            !canRunInCurrentRunState(task.isPeriodic()) &&\n            remove(task))\n            task.cancel(false);\n        else\n//这里是增加一个worker线程，避免提交的任务没有worker去执行\n//原因就是该类没有像ThreadPoolExecutor一样，woker满了才放入队列\n          ensurePrestart();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br")])]),n("p",[s._v("DelayedWorkQueue")]),s._v(" "),n("p",[s._v("ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为ScheduledThreadPoolExecutor要求的工作队列有些特殊。")]),s._v(" "),n("p",[s._v("DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面（"),n("strong",[s._v("注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的，下文中会说明")]),s._v("）。")]),s._v(" "),n("p",[s._v("堆结构如下图：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/62.png",alt:""}})]),s._v(" "),n("p",[s._v("可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数组表示，可以转换成如下的数组：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/63.png",alt:""}})]),s._v(" "),n("p",[s._v("在这种结构中，可以发现有如下特性：")]),s._v(" "),n("p",[s._v("假设，索引值从0开始，子节点的索引值为k，父节点的索引值为p，则：")]),s._v(" "),n("ol",[n("li",[s._v("一个节点的左子节点的索引为：k = p * 2 + 1；")]),s._v(" "),n("li",[s._v("一个节点的右子节点的索引为：k = (p + 1) * 2；")]),s._v(" "),n("li",[s._v("一个节点的父节点的索引为：p = (k - 1) / 2。")])]),s._v(" "),n("p",[n("strong",[s._v("为什么要使用DelayedWorkQueue呢？")])]),s._v(" "),n("p",[s._v("定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。")]),s._v(" "),n("p",[s._v("DelayedWorkQueue是一个优先级队列，它可以保证每次  出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 "),n("em",[s._v("O(logN)")]),s._v("。")]),s._v(" "),n("p",[n("strong",[s._v("DelayedWorkQueue属性")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 队列初始容量\nprivate static final int INITIAL_CAPACITY = 16;\n// 根据初始容量创建RunnableScheduledFuture类型的数组\nprivate RunnableScheduledFuture<?>[] queue =\n    new RunnableScheduledFuture<?>[INITIAL_CAPACITY];\nprivate final ReentrantLock lock = new ReentrantLock();\nprivate int size = 0;\n// leader线程\nprivate Thread leader = null;\n// 当较新的任务在队列的头部可用时，或者新线程可能需要成为leader，则通过该条件发出信号\nprivate final Condition available = lock.newCondition();\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("注意这里的leader，它是Leader-Follower模式的变体，用于减少不必要的定时等待。什么意思呢？对于多线程的网络模型来说：")]),s._v(" "),n("p",[s._v("所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。")]),s._v(" "),n("p",[n("strong",[s._v("offer方法")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public boolean offer(Runnable x) {\n//参数校验\n    if (x == null)\n        throw new NullPointerException();\n    RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n//查看当前元素数量，如果大于队列长度则进行扩容\n        int i = size;\n        if (i >= queue.length)\n            grow();\n//元素数量加1\n        size = i + 1;\n//如果当前队列还没有元素，则直接加入头部\n        if (i == 0) {\n            queue[0] = e;\n//记录索引\n            setIndex(e, 0);\n        } else {\n //把任务加入堆中，并调整堆结构，这里就会根据任务的触发时间排列\n             //把需要最早执行的任务放在前面\n            siftUp(i, e);\n        }\n//如果新加入的元素就是队列头，这里有两种情况\n        //1.这是用户提交的第一个任务\n        //2.新任务进行堆调整以后，排在队列头\n        if (queue[0] == e) {\n// leader设置为null为了使在take方法中的线程在通过available.signal();后会执行available.awaitNanos(delay);\n            leader = null;\n//加入元素以后，唤醒worker线程\n            available.signal();\n        }\n    } finally {\n        lock.unlock();\n    }\n    return true;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br")])]),n("p",[n("strong",[s._v("任务排序sift方法")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("private void siftUp(int k, RunnableScheduledFuture<?> key) {\n// 找到父节点的索引\nwhile (k > 0) {\n  // 获取父节点\n        int parent = (k - 1) >>> 1;\n        RunnableScheduledFuture<?> e = queue[parent];\n  // 如果key节点的执行时间大于父节点的执行时间，不需要再排序了\n        if (key.compareTo(e) >= 0)\n            break;\n // 如果key.compareTo(e) < 0，说明key节点的执行时间小于父节点的执行时间，需要把父节点移到后面\n        queue[k] = e;\n        setIndex(e, k);\n// 设置索引为k\n        k = parent;\n    }\n// key设置为排序后的位置中\n    queue[k] = key;\n    setIndex(key, k);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("p",[s._v("代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间小于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。")]),s._v(" "),n("p",[s._v("假设新入队的节点的延迟时间（调用getDelay()方法获得）是5，执行过程如下：")]),s._v(" "),n("ol",[n("li",[n("strong",[s._v("先将新的节点添加到数组的尾部，这时新节点的索引k为7：")])])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/64.png",alt:""}})]),s._v(" "),n("ol",[n("li",[n("strong",[s._v("计算新父节点的索引：parent = (k - 1) >>> 1，parent = 3，那么queue[3]的时间间隔值为8，因为 5 < 8 ，将执行queue[7] = queue[3]：")])])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/65.png",alt:""}})]),s._v(" "),n("ol",[n("li",[n("strong",[s._v("这时将k设置为3，继续循环，再次计算parent为1，queue[1]的时间间隔为3，因为 5 > 3 ，这时退出循环，最终k为3：")])])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/66.png",alt:""}})]),s._v(" "),n("p",[s._v("可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。")]),s._v(" "),n("p",[n("strong",[s._v("take方法")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public RunnableScheduledFuture<?> take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        for (;;) {\n            RunnableScheduledFuture<?> first = queue[0];\n            if (first == null)\n                available.await();\n            else {\n// 计算当前时间到执行时间的时间间隔\n                long delay = first.getDelay(NANOSECONDS);\n                if (delay <= 0)\n                    return finishPoll(first);\n                first = null; // don't retain ref while waiting\n                // leader不为空，阻塞线程\nif (leader != null)\n                    available.await();\n                else {\n                    // leader为空，则把leader设置为当前线程，\nThread thisThread = Thread.currentThread();\n                    leader = thisThread;\n                    try {\n                       // 阻塞到执行时间 \navailable.awaitNanos(delay);\n                    } finally {\n// 设置leader = null，让其他线程执行available.awaitNanos(delay);\n                        if (leader == thisThread)\n                            leader = null;\n                    }\n                }\n            }\n        }\n    } finally {\n// 如果leader不为空，则说明leader的线程正在执行available.awaitNanos(delay);\n        // 如果queue[0] == null，说明队列为空\n        if (leader == null && queue[0] != null)\n            available.signal();\n        lock.unlock();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br")])]),n("p",[s._v("take方法是什么时候调用的呢？在ThreadPoolExecutor中，介绍了getTask方法，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。")]),s._v(" "),n("p",[s._v("再来说一下leader的作用，这里的leader是为了减少不必要的定时等待，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从take（）或poll（）返回之前signal其它线程，除非其他线程成为了leader。")]),s._v(" "),n("p",[s._v("举例来说，如果没有leader，那么在执行take时，都要执行available.awaitNanos(delay)，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个这时执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。")]),s._v(" "),n("p",[s._v("所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。")]),s._v(" "),n("p",[n("strong",[s._v("poll 方法")])]),s._v(" "),n("p",[s._v("下面看下poll方法，与take类似，但这里要提供超时功能：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public RunnableScheduledFuture<?> poll(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        for (;;) {\n            RunnableScheduledFuture<?> first = queue[0];\n            if (first == null) {\n                if (nanos <= 0)\n                    return null;\n                else\n                    nanos = available.awaitNanos(nanos);\n            } else {\n                long delay = first.getDelay(NANOSECONDS);\n// 如果delay <= 0，说明已经到了任务执行的时间，返回。\n                if (delay <= 0)\n                    return finishPoll(first);\n// 如果nanos <= 0，说明已经超时，返回null\n                if (nanos <= 0)\n                    return null;\n                first = null; // don't retain ref while waiting\n  // nanos < delay 说明需要等待的时间小于任务要执行的延迟时间\n                // leader != null 说明有其它线程正在对任务进行阻塞\n                // 这时阻塞当前线程nanos纳秒\n                if (nanos < delay || leader != null)\n                    nanos = available.awaitNanos(nanos);\n                else {\n                    Thread thisThread = Thread.currentThread();\n                    leader = thisThread;\n                    try {\n// 这里的timeLeft表示delay减去实际的等待时间\n                        long timeLeft = available.awaitNanos(delay);\n                       // 计算剩余的等待时间 \nnanos -= delay - timeLeft;\n                    } finally {\n                        if (leader == thisThread)\n                            leader = null;\n                    }\n                }\n            }\n        }\n    } finally {\n        if (leader == null && queue[0] != null)\n            available.signal();\n        lock.unlock();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br")])]),n("p",[n("strong",[s._v("finishPoll方法")])]),s._v(" "),n("p",[s._v("当调用了take或者poll方法能够获取到任务时，会调用该方法进行返回：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("private RunnableScheduledFuture<?> finishPoll(RunnableScheduledFuture<?> f) {\n// 数组长度-1\n    int s = --size;\n// 取出最后一个节点\n    RunnableScheduledFuture<?> x = queue[s];\n    queue[s] = null;\n// 长度不为0，则从第一个元素开始排序，目的是要把最后一个节点放到合适的位置上\n    if (s != 0)\n        siftDown(0, x);\n    setIndex(f, -1);\n    return f;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("p",[n("strong",[s._v("siftDown方法")])]),s._v(" "),n("p",[s._v("siftDown方法使堆从k开始向下调整：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("private void siftDown(int k, RunnableScheduledFuture<?> key) {\n// 根据二叉树的特性，数组长度除以2，表示取有子节点的索引\n    int half = size >>> 1;\n// 判断索引为k的节点是否有子节点\n    while (k < half) {\n// 左子节点的索引\n        int child = (k << 1) + 1;\n        RunnableScheduledFuture<?> c = queue[child];\n// 右子节点的索引\n        int right = child + 1;\n// 如果有右子节点并且左子节点的时间间隔大于右子节点，取时间间隔最小的节点\n        if (right < size && c.compareTo(queue[right]) > 0)\n            c = queue[child = right];\n// 如果key的时间间隔小于等于c的时间间隔，跳出循环\n        if (key.compareTo(c) <= 0)\n            break;\n// 设置要移除索引的节点为其子节点\n        queue[k] = c;\n        setIndex(c, k);\n        k = child;\n    }\n// 将key放入索引为k的位置\n    queue[k] = key;\n    setIndex(key, k);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br")])]),n("p",[s._v("siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。例如：")]),s._v(" "),n("p",[n("strong",[s._v("没有子节点的情况：")])]),s._v(" "),n("p",[s._v("假设初始的堆如下：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/67.png",alt:""}})]),s._v(" "),n("p",[s._v("假设 k = 3 ，那么 k = half ，没有子节点，在执行siftDown方法时直接把索引为3的节点设置为数组的最后一个节点：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/68.png",alt:""}})]),s._v(" "),n("p",[n("strong",[s._v("有子节点的情况：")])]),s._v(" "),n("p",[s._v("假设 k = 0 ，那么执行以下步骤：")]),s._v(" "),n("p",[s._v("1、获取左子节点，child = 1 ，获取右子节点， right = 2 ：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/69.png",alt:""}})]),s._v(" "),n("p",[s._v("2、由于 right < size ，这时比较左子节点和右子节点时间间隔的大小，这里 3 < 7 ，所以 c = queue[child] ；")]),s._v(" "),n("p",[s._v("3、比较key的时间间隔是否小于c的时间间隔，这里不满足，继续执行，把索引为k的节点设置为c，然后将k设置为child；")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/70.png",alt:""}})]),s._v(" "),n("p",[s._v("4、因为 half = 3 ，k = 1 ，继续执行循环，这时的索引变为：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/71.png",alt:""}})]),s._v(" "),n("p",[s._v("5、这时再经过如上判断后，将k的值为3，最终的结果如下：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/72.png",alt:""}})]),s._v(" "),n("p",[s._v("6、最后，如果在finishPoll方法中调用的话，会把索引为0的节点的索引设置为-1，表示已经删除了该节点，并且size也减了1，最后的结果如下：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/73.png",alt:""}})]),s._v(" "),n("p",[s._v("可见，siftdown方法在执行完并不是有序的，但可以发现，子节点的下次执行时间一定比父节点的下次执行时间要大，由于每次都会取左子节点和右子节点中下次执行时间最小的节点，所以还是可以保证在take和poll时出队是有序的。")]),s._v(" "),n("p",[n("strong",[s._v("remove方法")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public boolean remove(Object x) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        int i = indexOf(x);\n        if (i < 0)\n            return false;\n\n        setIndex(queue[i], -1);\n        int s = --size;\n        RunnableScheduledFuture<?> replacement = queue[s];\n        queue[s] = null;\n        if (s != i) {\n  // 从i开始向下调整\n            siftDown(i, replacement);\n // 如果queue[i] == replacement，说明i是叶子节点\n            // 如果是这种情况，不能保证子节点的下次执行时间比父节点的大\n            // 这时需要进行一次向上调整\n            if (queue[i] == replacement)\n                siftUp(i, replacement);\n        }\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("p",[s._v("假设初始的堆结构如下：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/74.png",alt:""}})]),s._v(" "),n("p",[s._v("这时要删除8的节点，那么这时 k = 1，key为最后一个节点：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/75.png",alt:""}})]),s._v(" "),n("p",[s._v("这时通过上文对siftDown方法的分析，siftDown方法执行后的结果如下：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/76.png",alt:""}})]),s._v(" "),n("p",[s._v("这时会发现，最后一个节点的值比父节点还要小，所以这里要执行一次siftUp方法来保证子节点的下次执行时间要比父节点的大，所以最终结果如下：")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/lock/77.png",alt:""}})]),s._v(" "),n("p",[n("strong",[s._v("总结")])]),s._v(" "),n("p",[s._v("主要总结为以下几个方面：")]),s._v(" "),n("ul",[n("li",[s._v("与Timer执行定时任务的比较，相比Timer，ScheduedThreadPoolExecutor有什么优点；")]),s._v(" "),n("li",[s._v("ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以它也是一个线程池，也有coorPoolSize和workQueue，ScheduledThreadPoolExecutor特殊的地方在于，自己实现了优先工作队列DelayedWorkQueue；")]),s._v(" "),n("li",[s._v("ScheduedThreadPoolExecutor实现了ScheduledExecutorService，所以就有了任务调度的方法，如schedule，scheduleAtFixedRate和scheduleWithFixedDelay，同时注意他们之间的区别；")]),s._v(" "),n("li",[s._v("内部类ScheduledFutureTask继承自FutureTask，实现了任务的异步执行并且可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执行的时间间隔；")]),s._v(" "),n("li",[s._v("周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行完不设置结果和状态。")]),s._v(" "),n("li",[s._v("详细分析了DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。同时注意一下优先队列中堆的顺序，堆中的顺序并不是绝对的，但要保证子节点的值要比父节点的值要大，这样就不会影响出队的顺序。")])]),s._v(" "),n("p",[s._v("总体来说，ScheduedThreadPoolExecutor的重点是要理解下次执行时间的计算，以及优先队列的出队、入队和删除的过程，这两个是理解ScheduedThreadPoolExecutor的关键。")])])}),[],!1,null,null,null);n.default=t.exports}}]);