(window.webpackJsonp=window.webpackJsonp||[]).push([[286],{631:function(v,_,a){"use strict";a.r(_);var s=a(1),t=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"技术方面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#技术方面"}},[v._v("#")]),v._v(" 技术方面")]),v._v(" "),_("h3",{attrs:{id:"面试-static"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试-static"}},[v._v("#")]),v._v(" 面试 static")]),v._v(" "),_("p",[_("strong",[v._v("问：什么时候会使用static？")]),v._v("\n当一个方法或变量需要初始化的时候，或者经常被掉用的时候可以加上static;\nstatic 可以修饰变量，或方法或类；\n修饰的变量为静态成员变量，类加载的时候被分配堆上创建，可以被整个类访问，可以直接类名直接访问，也可以使用对象名访问；\n修饰的方法为静态方法，只能访问本类的静态成员变量，访问非静态成员通过创建类的对象，通过对象访问；\n普通方法，可以直接访问同类中的额非静态变量和静态变量；\n静态方法中，不能直接调用非静态方法，但是可以通过对象来访问非静态方法；")]),v._v(" "),_("h3",{attrs:{id:"类加载机制是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制是什么"}},[v._v("#")]),v._v(" 类加载机制是什么？")]),v._v(" "),_("p",[v._v("javac编译器会将.java文件编译成.class文件，当java虚拟机需要某个类的时候会将.class文件加载并创建类的对象，这个过程称为类的加载过程；\n类加载过程分为\n加载（由classloader根据类的全限定名加载class文件）\n验证（验证文件信息如文件格式的验证，元信息验证，字节码验证，符号引用验证）\n准备（为类变量 staic修饰的字段变量 分配空间并赋初始值，不包含final修饰的static,final在编译的时候已经分配了，不会为实例变量分配初始化）\n解析（把常量池的符号引用替换成直接引用）\n初始化（如果该类具有父类就对父类进行初始化，执行静态代码块和静态初始化成员变量）")]),v._v(" "),_("h3",{attrs:{id:"问http与https的区别-s指的什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问http与https的区别-s指的什么"}},[v._v("#")]),v._v(" 问http与https的区别，s指的什么？")]),v._v(" "),_("p",[v._v("http是超文本传输协议，负责客户端到服务端的一系列操作，专门用来注入html的超媒体文档等web内容的协议，基于传输层的tcp协议的应用层协议。\nhttps:是基于安全套接字的http协议，http+ssl/tls（数字证书）\n区别：http不安全，https安全\n标准端口：80  443\nhttps传输层加密\nhttps工作原理：\n首先服务器端向客户端发送传输证书，这个证书是公钥，包含了如证书的办法机构，过期时间等；\n客户端收到公钥会解析验证证书，如果没有问题，生成一个随机值（私钥）然后用证书对这个私钥加密，发送给服务端；\n服务端使用私钥对信息解密，得到客户端的私钥，然后客户端和服务端就通过这个私钥通信\n（非对称的加密传输协议）")]),v._v(" "),_("h3",{attrs:{id:"问聊一下mysql的索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问聊一下mysql的索引"}},[v._v("#")]),v._v(" 问聊一下mysql的索引？")]),v._v(" "),_("p",[v._v("索引分为单列索引（单个列的索引，一张表可以有很多单列索引），唯一索引（索引列的值必须唯一，但允许空值），聚合索引（多个列的索引）\nBtree索引，hash索引（hash索引是在btree索引基础上对索引进行hashCode）")]),v._v(" "),_("p",[_("strong",[v._v("2021.8.13面试")])]),v._v(" "),_("h3",{attrs:{id:"get和post的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post的区别"}},[v._v("#")]),v._v(" get和post的区别")]),v._v(" "),_("p",[v._v("1：传送方式：get是浏览器传输，post是报文传输\n传送长度：get有参数限制（取决于浏览器），post上理论上没有限制\n2，数据传输：get，通过拼接url进行传递参数，url是可见；\npost，通过body体传输参数，url不可见\n3，GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);\nPOST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。\n4，缓存方式：GET请求会被浏览器主动缓存，而POST不会，除非手动设置。")]),v._v(" "),_("p",[v._v("请求头中都包括哪些内容")]),v._v(" "),_("p",[_("strong",[v._v("21.8.19")])]),v._v(" "),_("h3",{attrs:{id:"sync锁理解-锁的升级过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sync锁理解-锁的升级过程"}},[v._v("#")]),v._v(" sync锁理解，锁的升级过程")]),v._v(" "),_("h3",{attrs:{id:"jdk11和jdk8的垃圾收集器区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk11和jdk8的垃圾收集器区别"}},[v._v("#")]),v._v(" JDK11和JDK8的垃圾收集器区别")]),v._v(" "),_("h3",{attrs:{id:"g1垃圾收集器特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1垃圾收集器特点"}},[v._v("#")]),v._v(" G1垃圾收集器特点")]),v._v(" "),_("h3",{attrs:{id:"volatile关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#volatile关键字"}},[v._v("#")]),v._v(" volatile关键字")]),v._v(" "),_("h3",{attrs:{id:"redis的线程模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis的线程模型"}},[v._v("#")]),v._v(" Redis的线程模型")]),v._v(" "),_("h3",{attrs:{id:"es的索引原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es的索引原理"}},[v._v("#")]),v._v(" ES的索引原理")]),v._v(" "),_("h3",{attrs:{id:"mysql两种索引方式区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql两种索引方式区别"}},[v._v("#")]),v._v(" MySQL两种索引方式区别")]),v._v(" "),_("h3",{attrs:{id:"hashmap初始化大小是16-如果初始化时存为11-那容量大小是多少"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap初始化大小是16-如果初始化时存为11-那容量大小是多少"}},[v._v("#")]),v._v(" HashMap初始化大小是16，如果初始化时存为11，那容量大小是多少")]),v._v(" "),_("h3",{attrs:{id:"springcloud的feign和openfeign区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springcloud的feign和openfeign区别"}},[v._v("#")]),v._v(" springcloud的Feign和openFeign区别")]),v._v(" "),_("h3",{attrs:{id:"springboot自动加载怎么实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springboot自动加载怎么实现的"}},[v._v("#")]),v._v(" springboot自动加载怎么实现的")]),v._v(" "),_("h3",{attrs:{id:"缓存穿透-雪崩怎么处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透-雪崩怎么处理"}},[v._v("#")]),v._v(" 缓存穿透，雪崩怎么处理")]),v._v(" "),_("h3",{attrs:{id:"b树和b-树区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b树和b-树区别"}},[v._v("#")]),v._v(" B树和B+树区别")]),v._v(" "),_("h3",{attrs:{id:"java清理内存-清除java内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java清理内存-清除java内存"}},[v._v("#")]),v._v(" java清理内存,清除Java内存")]),v._v(" "),_("h3",{attrs:{id:"java-对象使用后设置为-null-不会减少内存占用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-对象使用后设置为-null-不会减少内存占用"}},[v._v("#")]),v._v(" Java 对象使用后设置为 null 不会减少内存占用")]),v._v(" "),_("h3",{attrs:{id:"jdk8-jdk7-hashmap的时间复杂度不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk8-jdk7-hashmap的时间复杂度不同"}},[v._v("#")]),v._v(" jdk8，jdk7 hashMap的时间复杂度不同")]),v._v(" "),_("h3",{attrs:{id:"红黑树的查询复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#红黑树的查询复杂度"}},[v._v("#")]),v._v(" 红黑树的查询复杂度")]),v._v(" "),_("h3",{attrs:{id:"juc包下的都用过啥"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#juc包下的都用过啥"}},[v._v("#")]),v._v(" juc包下的都用过啥")]),v._v(" "),_("h3",{attrs:{id:"锁的升级过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁的升级过程"}},[v._v("#")]),v._v(" 锁的升级过程")]),v._v(" "),_("h3",{attrs:{id:"redis多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis多路复用"}},[v._v("#")]),v._v(" redis多路复用")]),v._v(" "),_("h3",{attrs:{id:"es索引-怎么简索引-以及索引去重的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es索引-怎么简索引-以及索引去重的"}},[v._v("#")]),v._v(" ES索引，怎么简索引，以及索引去重的")]),v._v(" "),_("h3",{attrs:{id:"平时有用过网络相关的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#平时有用过网络相关的吗"}},[v._v("#")]),v._v(" 平时有用过网络相关的吗？")]),v._v(" "),_("h3",{attrs:{id:"jvm调优"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优"}},[v._v("#")]),v._v(" jvm调优：")]),v._v(" "),_("p",[v._v("方法区又叫元空间\n①：-xms ，-Xmx堆空间设置,-Xmn新生代，-Xss :栈（线程大小）-XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。-XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M\n-xx:Permsize 代表永久代的初始容量")]),v._v(" "),_("h3",{attrs:{id:"mysql索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引"}},[v._v("#")]),v._v(" Mysql索引")]),v._v(" "),_("p",[v._v("从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式")]),v._v(" "),_("h3",{attrs:{id:"mysql优化。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql优化。"}},[v._v("#")]),v._v(" mysql优化。")]),v._v(" "),_("p",[v._v("①：联合索引第一个字段使用范围不会走索引；\n②：覆盖索引优化；\n③：in和or在比表数据量比较大的情况会走索引，在表记录不多的情况会选择表扫描；\n④：like kk%一般情况都会走索引，尽量采用后置的通配符，用到了索引下推优化，mysql5.6引入了索引下推优化，可以在索引遍历中个，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，到主键索引上找出相应的记录；\n索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）树叶子节点上保存的是全行数据，所以索引下推并不会起到减少查询全行数据的效果\n⑤：尽力避免NULL值出现，可能会造成索引失效；\n⑥：查询条件上尽量不要对索隐裂使用函数；\n⑦：<>,not, in ,not exists 条件可能会倾向于全表扫描")]),v._v(" "),_("h3",{attrs:{id:"redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[v._v("#")]),v._v(" redis ：")]),v._v(" "),_("p",[v._v("redis的持久化机制：\nrdb(快照，以二进制文件存储dump.rdb),对redis设置，在N秒内数据集至少有M个改动，这一条件自动保存。也可以手动使用命令save或bgSave(写时复制，fork子进程)保存快照。\nAOF，将修改的每一条指令记录保存appendOnly.aof文件中（先写入os  cache,再fsync到磁盘），如果执行带有过期时间的set命令，aof文件李记录的不是原始命令，而是记录key过期时间的时间戳\n配置fsync多久将数据到磁盘一次\nappendfsync always; 每次有新命令\nappendfsync everysec;每秒\nappendfsync no;从不，交由操作系统处理\n主从复制\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210413123239357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaW9mY2hhbw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),v._v(" "),_("p",[v._v("redis的哨兵，集群模式原理\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210413123516369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaW9mY2hhbw==,size_16,color_FFFFFF,t_70",alt:""}}),v._v("哨兵配置复杂，性能和高可用性等方面表现一般，特别在主从切换的瞬间存在访问瞬断情况，而且哨兵模式只有一个主节点对外提供服务\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210413124040490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaW9mY2hhbw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),v._v(" "),_("p",[v._v("redis的高可用是怎么做到的\nredis的过期策略\nredis的并发竞争问题\n公司怎么布置redis，占用内存多少")]),v._v(" "),_("p",[v._v("生产上有三台redis实例，如果要再加两台，如果把之前的三台机器数据迁移到新的机器上面")]),v._v(" "),_("p",[v._v("redis五种基本类型（string,list,hash,zset,set）\n使用场景：string(单值缓存，对象缓存，分布式锁，计数器，web集群session共享，分布式系统全局序列号)\nhash(电商购购物车)")]),v._v(" "),_("p",[v._v("社交关注模型；\n"),_("strong",[v._v("hash 电商购物车")]),v._v("；\n①：以用户id为key ②：商品id为filed ③：商品数量为value\n购物车操作：\n①：添加商品 hset cart:1001 10088 1\n②：增加数量 hincryby cart:1001 10088 1\n③:删除商品：hdel cart:1001 10088 1\n④：商品总数：hlen cart:1001\n⑤：获取购物车所有商品：hgetall cart:1001\n优点：同类数据归类存储，相比string操作消耗内从与cpu更小，更节省空间\n缺点：过期功能不适用在field上，只能用在key上\n"),_("strong",[v._v("zset 点赞，收藏，社交关注模型")]),v._v("\n①：点赞 sadd like:{消息id} {用户Id}\n②：取消点赞 srem like\n③：检查用户是否点过赞 sismember like\n④：获取点赞的用户列表 smemners like\n⑤：获取点赞用户 scard like\n在这里插入图片描述")]),v._v(" "),_("p",[_("strong",[v._v("list 微博和微信信息交通流")]),v._v("：\n1）MacTalk发微博，消息ID为10018\nLPUSH  msg:{诸葛老师-ID}  10018\n2）备胎说车发微博，消息ID为10086\nLPUSH  msg:{诸葛老师-ID} 10086\n3）查看最新微博消息\nLRANGE  msg:{诸葛老师-ID}  0  4\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210412114117971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaW9mY2hhbw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),v._v(" "),_("strong",[v._v("set")]),v._v(" "),_("strong",[v._v("微信抽奖")]),v._v("\n①：参与抽奖用户 sadd key {userID}\n②：查看参与抽奖用户 smembers key\n③：srandmember key [count]/spop key [count]")]),v._v(" "),_("p",[v._v("2、redis分布式锁。\n分布式锁就是保证原子性，事务要么同时失败，要么回滚")]),v._v(" "),_("p",[v._v("3、redisson原理。\n4、redis跳跃表。\nzset  sorted_set跳跃表，排行榜计算")]),v._v(" "),_("p",[v._v("5、redis的rehash原理\nrehash(渐进式哈希)是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。新版本的dictRehash()还加入了一个最大访问空桶数(empty_visits)的限制来进一步减小可能引起阻塞的时间")]),v._v(" "),_("p",[v._v("6、redis生产优化，如果卡顿怎么排查。\n7、"),_("strong",[v._v("mysql索引原理，几种不同数据结构做索引的差别")]),v._v("。\n红黑树，二叉树，hash表，B-tree\n二叉树：插入数据会单边增长，在某些场景下退化成链表，链表查找是从头开始遍历，相当于没有加索引；\n红黑树：一种平衡二叉树，树的高度越高遍历次数就会越多，影响查询效率\nB-tree:叶节点具有相同深度，叶节点的指针为空；所有索引元素不重复；节点中的数据索引从左到右递增排列\nB+Tree(B-Tree变种)：\n非叶子节点不存储data,只存储冗余索引，可以放更多的索引；叶子节点包含所有索引字段；叶子节点用指针连接，提高区间访问的性能； InnoDb索引表数据文件是按B+tree值组织的一个索引结构文件\nhash结构：\n对索引的key进行一次hash计算可以定位出数据存储的位置；很多时候Hash索引比B+树索引更高效；仅能满足=，in，不支持范围查询；\nhash冲突问题；")]),v._v(" "),_("p",[v._v("8、"),_("strong",[v._v("mysql的MVCC")]),v._v("。\nMysql在可重复读隔离级别下能够保证事务较高的隔离性，这个隔离性就是MVCC机制保证的，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实行。\nMysql在读已提交和可重复读隔离级别都实现了MVCC机制，通过read-view机制月undo版本链比对机制，使得不同的事务会根据数据版本链对别规则读取同一条数据在版本连上的不同版本数据；\nundo日志版本链和read view机制；")]),v._v(" "),_("p",[v._v("9、spring源码IOC和AOP原理\n10、MQ的顺序消费、丢失消息、重复消息\n11、mysql分库分表\n12、spring boot原理。\n13、分布式事务。分布式锁，各种分布式锁的差别。\n14、spring cloud的组件原理。和dubbo的区别是啥\n15、ElasticSearch相关: 1、写入流程。2、查询流程。3、参数优化和调优。4、能不能替换成mysql使用。5、生产咋部署的，数据量多大，使用多少副本，大概用了多少G\n16、"),_("strong",[v._v("AQS协议")]),v._v("。"),_("strong",[v._v("各种锁的对比")]),v._v("。对象头存储了什么。多线程通信。线程池使用姿势。\nAQS全称是abstractQueuedSynchronizer,抽象的队列式同步器，一套多线程共享资源的同步器框架，具备的特性：\n①：阻塞等待队列  ②：共享、独占 ③：公平、非公平 ④：可重入 ⑤：允许中断\nAQS内部维护属性volatile ini state(32位)，表示资源的可用状态，stat三种访问方式：getstate(),setState(),comparedAndSetState()\nAQS定义两种西苑共享方式：\nExclusive-独占，只有一个线程能执行，如reentrantLock\nshare -共享多个线程同时执行，如countdownLatch,semaphare定义了两种队列：等待队列-CLH队列，一种基于双向链表数据结构的队列，FIFO\nprev  node  next   header")]),v._v(" "),_("p",[v._v("condition 条件等待队列，使每个或某些线程同时等待某个条件，只有当该条件具备时，这些等待线程会被唤醒，进而重新争夺锁\nfirstWaiter  node nextWaiter")]),v._v(" "),_("p",[v._v("ReentrantLock 是一种基于AQS框架的应用实现，是一种线程并发访问的一种手段。类似于synchronized是一种互斥锁，比它有更多的特性，可支持手动加锁，释放锁，支持加锁的公平与非公平\n加锁 lock.lock()   释放锁： lock.unlock()\n能够是想公平性是因为reentrantLock内部定义了一个sync的内部类，该类继承了abstractQueuedSynchronized,对改抽象类的部分方法做了实现，并且还定义了两个子类，fairSync  公平锁的实现，unfairSync 非公平锁的实现，\n用到了模板模式-子类根据需要做具体业务实现\nsynchronized锁是java的内置锁，不需要手动加锁释放锁，通过moniter对象（监视器锁）enter 与exit实现的，监视器锁的实现依赖底层操作系统的mUtex lock(互斥锁)1.5版本后做了重大优化，锁粗话，锁消除，偏向锁，适应性自选锁。")]),v._v(" "),_("p",[v._v("对象头存储了")]),v._v(" "),_("p",[v._v("17、Lamabda表达式底层实现原理。\n18、集合、MAP、红黑树、队列。\n19、力扣算法。")]),v._v(" "),_("h3",{attrs:{id:"数组和链表的数据结构的差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组和链表的数据结构的差异"}},[v._v("#")]),v._v(" 数组和链表的数据结构的差异")]),v._v(" "),_("p",[v._v("一、数组的知识：\n（1）在内存中，数组是一块连续的区域\n（2）数组需要预留空间（在存储之前，需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间大小，运行的时候空间的大小无法随着你的需要进行增加或减少而改变，数据量比较大的时候，可能会出现越界，数据量小会造成浪费空间）\n（3）在数组起始位置插入或删除数据效率低\n插入时：待插入的元素和它后面的所有元素都需要向后搬移\n删除数据时，待删除位置后面的所有元素都需要前移\n（4）数组的查询效率高")]),v._v(" "),_("p",[_("em",[v._v("(常见问题：同等长度的数组和链表，同时遍历哪个效率更高？)")]),v._v("\n数组初始化容量，扩容次数计算：\n数组和链表删除方式的差别，是否会出现并发修改异常：")]),v._v(" "),_("p",[v._v("MAP（map没有继承集合接口）\nhashMap的初始化标准，扩容机制，为什么线程不安全，底层用了哪些数据结构？")]),v._v(" "),_("p",[v._v("treeMap 和linked HashMap")]),v._v(" "),_("p",[v._v("currentHashMap源码？")]),v._v(" "),_("p",[v._v("HashSet 和treeSet?")]),v._v(" "),_("h3",{attrs:{id:"_1-根网-股票涨幅线-判断什么时候买入卖出-收益最大"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-根网-股票涨幅线-判断什么时候买入卖出-收益最大"}},[v._v("#")]),v._v(" 1，根网：股票涨幅线，判断什么时候买入卖出，收益最大")]),v._v(" "),_("h3",{attrs:{id:"_2-根网-有1-100牌-出牌人出一张牌-猜牌人猜牌-怎么能够快速猜出牌-博弈问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-根网-有1-100牌-出牌人出一张牌-猜牌人猜牌-怎么能够快速猜出牌-博弈问题"}},[v._v("#")]),v._v(" 2，根网：有1-100牌，出牌人出一张牌，猜牌人猜牌，怎么能够快速猜出牌（博弈问题）")]),v._v(" "),_("h3",{attrs:{id:"_1-蚂蚁金服-编写一段代码-从文本中读取1000万行-每一行是一个100以内的正整数-如何在4个cpu-读取数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-蚂蚁金服-编写一段代码-从文本中读取1000万行-每一行是一个100以内的正整数-如何在4个cpu-读取数据"}},[v._v("#")]),v._v(" 1，蚂蚁金服：编写一段代码，从文本中读取1000万行，每一行是一个100以内的正整数，如何在4个CPU，读取数据")]),v._v(" "),_("h3",{attrs:{id:"_2-蚂蚁金服-给定任意一个正整数-int表示范围内-n-求n-n的阶乘-结果的末尾有几个连续的0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-蚂蚁金服-给定任意一个正整数-int表示范围内-n-求n-n的阶乘-结果的末尾有几个连续的0"}},[v._v("#")]),v._v(" 2，蚂蚁金服：给定任意一个正整数(int表示范围内）n，求n!(n的阶乘）结果的末尾有几个连续的0")]),v._v(" "),_("h3",{attrs:{id:"_3-蚂蚁金服-完成a用户转账给b用户的功能-请进行接口设计-并实现其内部逻辑。-注意-2个用户高并发-等要考虑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-蚂蚁金服-完成a用户转账给b用户的功能-请进行接口设计-并实现其内部逻辑。-注意-2个用户高并发-等要考虑"}},[v._v("#")]),v._v(" 3，蚂蚁金服：完成A用户转账给B用户的功能，请进行接口设计，并实现其内部逻辑。（注意：2个用户高并发，等要考虑")]),v._v(" "),_("h3",{attrs:{id:"有id-age-name三个字段的表-数据有100行数据-按age排序后-查出第50-80条"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有id-age-name三个字段的表-数据有100行数据-按age排序后-查出第50-80条"}},[v._v("#")]),v._v(" 有id，age,name三个字段的表，数据有100行数据，按age排序后，查出第50-80条")]),v._v(" "),_("h3",{attrs:{id:"有1000个请求到mysql-怎么保证事务传播性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有1000个请求到mysql-怎么保证事务传播性"}},[v._v("#")]),v._v(" 有1000个请求到mysql，怎么保证事务传播性")]),v._v(" "),_("h3",{attrs:{id:"int-a-1-int-b-2-int-c-a-b-讲述下这个代码执行时堆栈的执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#int-a-1-int-b-2-int-c-a-b-讲述下这个代码执行时堆栈的执行过程"}},[v._v("#")]),v._v(" int a=1,int b=2,int c=a+b；讲述下这个代码执行时堆栈的执行过程")]),v._v(" "),_("h3",{attrs:{id:"java内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[v._v("#")]),v._v(" Java内存模型")]),v._v(" "),_("h3",{attrs:{id:"aop项目中怎么用的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aop项目中怎么用的"}},[v._v("#")]),v._v(" aop项目中怎么用的")]),v._v(" "),_("h3",{attrs:{id:"项目中多线程怎么用的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#项目中多线程怎么用的"}},[v._v("#")]),v._v(" 项目中多线程怎么用的")]),v._v(" "),_("h3",{attrs:{id:"log日志是怎么通过aop代码实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#log日志是怎么通过aop代码实现"}},[v._v("#")]),v._v(" log日志是怎么通过aop代码实现")]),v._v(" "),_("h3",{attrs:{id:"接口和抽象类区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类区别"}},[v._v("#")]),v._v(" 接口和抽象类区别")]),v._v(" "),_("h3",{attrs:{id:"http和https区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http和https区别"}},[v._v("#")]),v._v(" Http和HTTPS区别")]),v._v(" "),_("h3",{attrs:{id:"浏览器输入一个地址回车之后都发生了啥"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入一个地址回车之后都发生了啥"}},[v._v("#")]),v._v(" 浏览器输入一个地址回车之后都发生了啥")]),v._v(" "),_("h3",{attrs:{id:"你在开发过程中都遇到过哪些异常-你是怎么处理的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#你在开发过程中都遇到过哪些异常-你是怎么处理的"}},[v._v("#")]),v._v(" 你在开发过程中都遇到过哪些异常？你是怎么处理的")]),v._v(" "),_("h3",{attrs:{id:"jvm怎么保证老年代少发生gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm怎么保证老年代少发生gc"}},[v._v("#")]),v._v(" jvm怎么保证老年代少发生GC")]),v._v(" "),_("h3",{attrs:{id:"spring事务传播性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring事务传播性"}},[v._v("#")]),v._v(" spring事务传播性")]),v._v(" "),_("h3",{attrs:{id:"war报放tomcat的怎么启动的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#war报放tomcat的怎么启动的"}},[v._v("#")]),v._v(" war报放Tomcat的怎么启动的")]),v._v(" "),_("h2",{attrs:{id:"spring是单例还是多例-单例就一定安全吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring是单例还是多例-单例就一定安全吗"}},[v._v("#")]),v._v(" spring是单例还是多例，单例就一定安全吗")]),v._v(" "),_("h3",{attrs:{id:"线程的创建方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程的创建方式"}},[v._v("#")]),v._v(" 线程的创建方式")]),v._v(" "),_("h2",{attrs:{id:"两个long类型比较用什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两个long类型比较用什么"}},[v._v("#")]),v._v(" 两个Long类型比较用什么")]),v._v(" "),_("p",[v._v("Java中如果使用 == 双等于比较对象，等于比较的是两个对象的内存地址，也就是比较两个对象是否是同一个对象\n如果比较两个Long对象值是否相等，则不可以使用双等号进行比较，可以采用如下方式：\n\\1. 使用 equals 方法\nLong a = new Long(3);\nLong b = new Long(3);\nSystem.out.println(a.equals(b));\n\\2. 使用 Long 类型中的 longValue() 方法进行比较，如\nLong a = new Long(3);\nLong b = new Long(3);\nSystem.out.println(a.longValue()==b.longValue())。")]),v._v(" "),_("h3",{attrs:{id:"arraylist和linkedlist区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arraylist和linkedlist区别"}},[v._v("#")]),v._v(" ArrayList和LinkedList区别")]),v._v(" "),_("p",[v._v("jvm怎么保证老年代少发生GC")]),v._v(" "),_("p",[v._v("你在开发过程中都遇到过哪些异常？你是怎么处理的")]),v._v(" "),_("p",[v._v("LinkedList节点查找：\nLinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。\n如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。")]),v._v(" "),_("p",[v._v("LinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素，但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。\n所以在LinkedList循环遍历时，我们可以使用iterator方式迭代循环，直接拿到我们的元素，而不需要通过循环查找List。\n所以不推荐使用for循环，应使用迭代器")]),v._v(" "),_("h3",{attrs:{id:"hashmap一致性算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap一致性算法"}},[v._v("#")]),v._v(" hashmap一致性算法")]),v._v(" "),_("h3",{attrs:{id:"mysql表新加字段时-平滑的切换怎么实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql表新加字段时-平滑的切换怎么实现"}},[v._v("#")]),v._v(" mysql表新加字段时，平滑的切换怎么实现")]),v._v(" "),_("h3",{attrs:{id:"黑客攻击是限流方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#黑客攻击是限流方式"}},[v._v("#")]),v._v(" 黑客攻击是限流方式")]),v._v(" "),_("h3",{attrs:{id:"kafka防止消息重复发送-发送丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka防止消息重复发送-发送丢失"}},[v._v("#")]),v._v(" Kafka防止消息重复发送，发送丢失")]),v._v(" "),_("p",[v._v("具体实现原理是，kafka每次发送消息会生成PID和Sequence Number，并将这两个属性一起发送给broker，broker会将PID和Sequence Number跟消息绑定一起存起来，下次如果生产者重发相同消息，broker会检查PID和Sequence Number，如果相同不会再接收。")]),v._v(" "),_("p",[v._v("【一个partition同一个时刻在一个consumer group中只能有一个consumer instance在消费，从而保证消费顺序。】")]),v._v(" "),_("h3",{attrs:{id:"mysql调优-使用profiles-performance-schema性能监控"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql调优-使用profiles-performance-schema性能监控"}},[v._v("#")]),v._v(" mysql调优--使用profiles,performance_schema性能监控")]),v._v(" "),_("h3",{attrs:{id:"threadlocal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[v._v("#")]),v._v(" threadLocal")]),v._v(" "),_("h3",{attrs:{id:"es使用设计到的常用命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es使用设计到的常用命令"}},[v._v("#")]),v._v(" ES使用设计到的常用命令")]),v._v(" "),_("h3",{attrs:{id:"不同mq之间的差异点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同mq之间的差异点"}},[v._v("#")]),v._v(" 不同MQ之间的差异点")]),v._v(" "),_("h3",{attrs:{id:"es分页查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es分页查询"}},[v._v("#")]),v._v(" ES分页查询")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/nylg/picture/raw/master/elastic/deep-paging.png",alt:""}})]),v._v(" "),_("h2",{attrs:{id:"hr方面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hr方面"}},[v._v("#")]),v._v(" HR方面")]),v._v(" "),_("h3",{attrs:{id:"技术面试官问期望薪资多少-回答-这个我还没想考虑好-现在最主要的是想面试好好发挥-争取到公司岗位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#技术面试官问期望薪资多少-回答-这个我还没想考虑好-现在最主要的是想面试好好发挥-争取到公司岗位"}},[v._v("#")]),v._v(" 技术面试官问期望薪资多少，回答：这个我还没想考虑好，现在最主要的是想面试好好发挥，争取到公司岗位")]),v._v(" "),_("h3",{attrs:{id:"问个人缺点时-回答-年轻-社会阅历少-有时候好多事事后反思可以更好。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问个人缺点时-回答-年轻-社会阅历少-有时候好多事事后反思可以更好。"}},[v._v("#")]),v._v(" 问个人缺点时，回答：年轻，社会阅历少，有时候好多事事后反思可以更好。")]),v._v(" "),_("h2",{attrs:{id:"面试总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试总结"}},[v._v("#")]),v._v(" 面试总结")]),v._v(" "),_("p",[v._v("Mybatis中#和$符的区别：#{}占位符，${}拼接符。都用于动态参数传递。")]),v._v(" "),_("ul",[_("li",[v._v('#{}：防止sql注入；传入参数默认字符串，加""')]),v._v(" "),_("li",[v._v("${}：无法避免sql注入；传入参数不做处理；一般用作传入数据库对象，如表名。")])]),v._v(" "),_("p",[v._v("MyBatis中resultType和resultMap的区别：")]),v._v(" "),_("ul",[_("li",[v._v("resultType：表字段映射对应属性，大小写不敏感。字段名必须一致。可直接映射对象，")]),v._v(" "),_("li",[v._v("resultMap：手动配置表字段与对象属性的映射，字段名可以不一致。resultMap需要先定义才能使用，多用于复杂查询。比如级联查询之类的。")])]),v._v(" "),_("p",[v._v("Springboot的核心注解及作用：")]),v._v(" "),_("ul",[_("li",[v._v("@SpringBootApplication：标注在主类上，注明此为springboot应用")]),v._v(" "),_("li",[v._v("@EnableAutoConfiguration：开启自动配置注解，可根据当前类路径下的包来配置Spring bean。")]),v._v(" "),_("li",[v._v("@Configuration：Spring的注解，来代替配置文件applicationContext.xml。")]),v._v(" "),_("li",[v._v("@SpringBootConfiguration：用来修饰Spring boot配置。")]),v._v(" "),_("li",[v._v("@ComponentScan：开启包扫描注解，自动扫描包路径下的@Component 注解进行bean注入。")])]),v._v(" "),_("p",[v._v("服务器响应变慢的排查及处理：")]),v._v(" "),_("ul",[_("li",[v._v("服务器资源监控：查看服务器资源是否达到上限(内存使用率等)，可作相应的扩容")]),v._v(" "),_("li",[v._v("代码优化：服务调用链排查接口响应时间，是否需要进行优化，sql优化等。")])]),v._v(" "),_("p",[v._v("linux下常用命令：")]),v._v(" "),_("ul",[_("li",[v._v("cat /proc/meminfo：查看内存使用情况  默认单位kb")]),v._v(" "),_("li",[v._v("df -h：查看磁盘使用情况")]),v._v(" "),_("li",[v._v("free -h：显示内存信息")]),v._v(" "),_("li",[v._v("tar：压缩/解压命令")])]),v._v(" "),_("p",[v._v("hashMap与hashTable：")]),v._v(" "),_("ul",[_("li",[v._v("hashMap：存储键值对，以hash算法确定数组下标。哈希冲突。数组-联表/红黑树。线程不安全。效率高点，允许空键空值，扩容为原容量两倍")]),v._v(" "),_("li",[v._v("hashtable：线程安全，效率低。不允许空键空值。两倍+1，数组-联表。")])]),v._v(" "),_("p",[v._v("反射的原理：")]),v._v(" "),_("ul",[_("li",[v._v("类对象的对象头包含对象的类型指针(原数据指针)找到保存在方法区的元数据信息。")])]),v._v(" "),_("p",[v._v("类的生命周期：")]),v._v(" "),_("ul",[_("li",[v._v("加载-验证-准备-解析-初始化-使用-卸载。从加载到释放的全过程")])]),v._v(" "),_("p",[v._v("FullGC的触发：")]),v._v(" "),_("ul",[_("li",[v._v("老年代空间不足，元空间空间不足。system.gc")])]),v._v(" "),_("p",[v._v("Spring与Springboot的区别：")]),v._v(" "),_("p",[v._v("springboot：嵌入式容器(Tomcat、Jetty、Undertow);尽可能的自动配置")]),v._v(" "),_("p",[v._v("varchar与char：")]),v._v(" "),_("ul",[_("li",[v._v("varchar长度可变，char固定长度，默认填充。")])]),v._v(" "),_("p",[v._v("SpringMVCwebConfig在项目中一般怎么用：")]),v._v(" "),_("p",[v._v("SpringBoot自动加载怎么实现的：")]),v._v(" "),_("p",[v._v("分布式锁的使用场景及实现方式：")]),v._v(" "),_("p",[v._v("JKD1.8默认垃圾处理器：")]),v._v(" "),_("ul",[_("li",[v._v("ParallelGC")])]),v._v(" "),_("p",[v._v("shiro")]),v._v(" "),_("p",[v._v("cookie、session")]),v._v(" "),_("p",[v._v("dubbo协议服务注册与发现")]),v._v(" "),_("p",[v._v("分布式锁redis、zookeeper的实现")]),v._v(" "),_("ul",[_("li",[v._v("redis分布式锁的实现")])]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('public class RedisTool {\n\n\n    private static final String LOCK_SUCCESS = "OK";\n    private static final String SET_IF_NOT_EXIST = "NX";\n    private static final String SET_WITH_EXPIRE_TIME = "PX";\n\n\n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n\n\n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n\n\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n}\n')])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br"),_("span",{staticClass:"line-number"},[v._v("11")]),_("br"),_("span",{staticClass:"line-number"},[v._v("12")]),_("br"),_("span",{staticClass:"line-number"},[v._v("13")]),_("br"),_("span",{staticClass:"line-number"},[v._v("14")]),_("br"),_("span",{staticClass:"line-number"},[v._v("15")]),_("br"),_("span",{staticClass:"line-number"},[v._v("16")]),_("br"),_("span",{staticClass:"line-number"},[v._v("17")]),_("br"),_("span",{staticClass:"line-number"},[v._v("18")]),_("br"),_("span",{staticClass:"line-number"},[v._v("19")]),_("br"),_("span",{staticClass:"line-number"},[v._v("20")]),_("br"),_("span",{staticClass:"line-number"},[v._v("21")]),_("br"),_("span",{staticClass:"line-number"},[v._v("22")]),_("br"),_("span",{staticClass:"line-number"},[v._v("23")]),_("br"),_("span",{staticClass:"line-number"},[v._v("24")]),_("br"),_("span",{staticClass:"line-number"},[v._v("25")]),_("br"),_("span",{staticClass:"line-number"},[v._v("26")]),_("br"),_("span",{staticClass:"line-number"},[v._v("27")]),_("br"),_("span",{staticClass:"line-number"},[v._v("28")]),_("br")])]),_("ul",[_("li",[v._v("通过requestId确认加锁线程，由加锁线程进行解锁操作")]),v._v(" "),_("li",[v._v("NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。")]),v._v(" "),_("li",[v._v("PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定")]),v._v(" "),_("li",[v._v("加锁与设置超时时间是一条命令，确保原子性")])]),v._v(" "),_("p",[v._v("redis分布式锁解锁")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("public class RedisTool {\n\n\n    private static final Long RELEASE_SUCCESS = 1L;\n    /**\n     * 释放分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n\n\n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n}\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br"),_("span",{staticClass:"line-number"},[v._v("11")]),_("br"),_("span",{staticClass:"line-number"},[v._v("12")]),_("br"),_("span",{staticClass:"line-number"},[v._v("13")]),_("br"),_("span",{staticClass:"line-number"},[v._v("14")]),_("br"),_("span",{staticClass:"line-number"},[v._v("15")]),_("br"),_("span",{staticClass:"line-number"},[v._v("16")]),_("br"),_("span",{staticClass:"line-number"},[v._v("17")]),_("br"),_("span",{staticClass:"line-number"},[v._v("18")]),_("br"),_("span",{staticClass:"line-number"},[v._v("19")]),_("br"),_("span",{staticClass:"line-number"},[v._v("20")]),_("br"),_("span",{staticClass:"line-number"},[v._v("21")]),_("br"),_("span",{staticClass:"line-number"},[v._v("22")]),_("br")])]),_("ul",[_("li",[v._v("通过Lua脚本进行解锁操作。")]),v._v(" "),_("li",[v._v("使用eval()方法可以确保原子性。")]),v._v(" "),_("li",[v._v("在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。")]),v._v(" "),_("li",[v._v("获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。")])]),v._v(" "),_("p",[v._v("线程池拒绝策略")]),v._v(" "),_("ul",[_("li",[v._v("丢弃任务，抛出异常")]),v._v(" "),_("li",[v._v("丢弃任务，不抛出异常")]),v._v(" "),_("li",[v._v("丢弃队列最前面的任务，重新提交")]),v._v(" "),_("li",[v._v("由提交任务的线程去处理任务")])]),v._v(" "),_("p",[v._v("线程池队列类型")]),v._v(" "),_("ul",[_("li",[v._v("ArrayBlockingQueue(数组阻塞队列)")]),v._v(" "),_("li")]),v._v(" "),_("p",[v._v("spring事务失效")]),v._v(" "),_("ul",[_("li",[v._v("修饰非public方法")]),v._v(" "),_("li",[v._v("mysql且引擎是MyISAM，改引擎不支持事务")])]),v._v(" "),_("p",[v._v("collection的线程安全")]),v._v(" "),_("p",[v._v("hashmap对hash方法的重写")]),v._v(" "),_("ul",[_("li",[v._v("对key与value的hashcode值进行异或(位运算)运算。")])]),v._v(" "),_("p",[v._v("hashmap存储结构：")]),v._v(" "),_("ul",[_("li",[v._v("数组、链表、红黑树。")])]),v._v(" "),_("p",[v._v("hashmap初始化大小问题")]),v._v(" "),_("ul",[_("li",[v._v("初始大小为2n,是大于等于设置容量X的第一个数")]),v._v(" "),_("li",[v._v("负载因子0.75，扩容2倍。")])]),v._v(" "),_("p",[v._v("hashMap多线程扩容问题：")]),v._v(" "),_("ul",[_("li",[v._v("导致死循环")])]),v._v(" "),_("p",[v._v("分布式环境下session共享")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("黏性session,将用户锁定到某一台服务器")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("Nginx为例，在upstream模块配置ip_hash属性即可实现粘性Session")])])]),v._v(" "),_("li",[_("p",[v._v("session共享")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("所有的请求之前配置一过滤器，在请求之前操作session，其实spring-session中真正起作用的session过滤器是:SessionRepositoryFilter")])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("改写getSession方法，从session存储中获取session数据，返回自定义的HttpSession实现")]),v._v(" "),_("li",[v._v("在生成新Session后，写入sessionid到cookie中")])])])]),v._v(" "),_("p",[v._v("线程池核心参数")]),v._v(" "),_("ul",[_("li",[v._v("核心线程数、最大线程数、阻塞队列、线程空闲时间、拒绝策略。")])]),v._v(" "),_("p",[v._v("双亲委派")]),v._v(" "),_("ul",[_("li",[v._v("自己是否已经加载->向上验证是否已经加载->自己能否加载->向下验证能否加载。")])]),v._v(" "),_("p",[v._v("MQ的区别")]),v._v(" "),_("p",[v._v("rabbitMQ的组成：")]),v._v(" "),_("p",[v._v("rabbitMQ消息确认机制")]),v._v(" "),_("p",[v._v("Linux下文件授权：")]),v._v(" "),_("ul",[_("li",[v._v("ls -l：查看文件权限")]),v._v(" "),_("li",[v._v("【文件/文件夹】【owner(当前用户)权限】【group(用户组)权限】【others(其他用户)权限】")]),v._v(" "),_("li",[v._v("r 读权限read  4；w 写权限write 2；x 操作权限execute  1")])]),v._v(" "),_("p",[v._v("SpringMVC框架：")]),v._v(" "),_("p",[v._v("Redis的线程模型")]),v._v(" "),_("p",[v._v("ES的索引原理")]),v._v(" "),_("p",[v._v("mysql新增数据(存在则更新，否则增加)：")]),v._v(" "),_("ul",[_("li",[v._v("insert ignore：不存在则新增。存在则忽略不处理。")]),v._v(" "),_("li",[v._v("insert into ... ON DUPLICATE KEY UPDATE  字段名=value(传入参数)：不存在则新增，存在则更新指定字段。")])]),v._v(" "),_("p",[v._v("防止SQL注入：")]),v._v(" "),_("ul",[_("li",[v._v("sql预编译")]),v._v(" "),_("li",[v._v("规定数据长度")]),v._v(" "),_("li",[v._v("严格限制数据库权限")]),v._v(" "),_("li",[v._v("sql异常后，响应自定义异常而非SQL异常")]),v._v(" "),_("li",[v._v("过滤参数中包含的关键字")])]),v._v(" "),_("p",[v._v("跨域请求：")]),v._v(" "),_("p",[v._v("存储过程与函数：")]),v._v(" "),_("p",[v._v("存储过程：")]),v._v(" "),_("ul",[_("li",[v._v("完成特定功能的sql语句集。一次编译永久有效")]),v._v(" "),_("li",[v._v("定义：")]),v._v(" "),_("li",[v._v("调用：call 存储过程名称")]),v._v(" "),_("li",[v._v("参数类型：in、out、inout。传入、传出、即传入又传出。")])]),v._v(" "),_("p",[v._v("函数：")]),v._v(" "),_("ul",[_("li",[v._v("定义：create function 函数名()")])]),v._v(" "),_("p",[v._v("return 返回类型")]),v._v(" "),_("p",[v._v("sql语句集合")]),v._v(" "),_("ul",[_("li",[v._v("调用：select 函数名(传入参数)")]),v._v(" "),_("li",[v._v("参数：in")])]),v._v(" "),_("p",[v._v("区别")]),v._v(" "),_("ul",[_("li",[v._v("函数必须有返回值，存储过程没有。")])]),v._v(" "),_("p",[v._v("内连接和全连接：")]),v._v(" "),_("p",[v._v("数据进入老年代的条件：")]),v._v(" "),_("ul",[_("li",[v._v("分代年龄达到要求，从年轻代转往老年代")]),v._v(" "),_("li",[v._v("针对于某些垃圾回收算法，大对象直接在老年代进行内存分配。")])]),v._v(" "),_("p",[v._v("缓存预热：")]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("p",[v._v("Redis集群配置：")]),v._v(" "),_("p",[v._v("模式：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("主从")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("一主一从；一主多从。")]),v._v(" "),_("li",[v._v("数据备份，读写分离。")]),v._v(" "),_("li",[v._v("缺点：主节点故障，从节点无法接替主节点")])])])]),v._v(" "),_("p",[v._v("配置：")]),v._v(" "),_("ul",[_("li",[_("ul",[_("li",[_("ul",[_("li",[v._v("丛机配置(slaveof masterip masterport)")])])])])]),v._v(" "),_("li",[_("p",[v._v("哨兵(Sentinel)")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("与主从模式类似，但存在一个哨兵进程。监控redis实例，并在master节点挂的时候实现主从切换。并通知其他从节点。")]),v._v(" "),_("li",[v._v("哨兵至少三台，作用有(集群状态监控、消息通知、主从切换、配置中心)")]),v._v(" "),_("li",[v._v("哨兵也是分布式部署的")]),v._v(" "),_("li",[v._v("redis与哨兵服务是分开启动的")]),v._v(" "),_("li",[v._v("先启动主节点，再从节点，再哨兵。")])])])]),v._v(" "),_("p",[v._v("配置：")]),v._v(" "),_("ul",[_("li",[_("ul",[_("li",[_("ul",[_("li",[_("p",[v._v("从节点先配置主从。")])]),v._v(" "),_("li",[_("p",[v._v("主从节点配置哨兵")])]),v._v(" "),_("li",[_("p",[v._v("哨兵配置文件(sentinel.conf)")])]),v._v(" "),_("li",[_("ul",[_("li",[_("p",[v._v("sentinel monitor "),_("master-name",[_("ip",[_("port",[_("count")],1)],1)],1)],1)]),v._v(" "),_("li",[_("ul",[_("li",[v._v("matser节点名称 ip 端口号")]),v._v(" "),_("li",[v._v("count指存在count台哨兵认为master节点死亡时才会主从切换。")]),v._v(" "),_("li",[v._v("count不得大于哨兵集群的数量")])])]),v._v(" "),_("li",[_("p",[v._v("sentinel down-after-millseconds "),_("master-name",[v._v(" 30000")])],1)]),v._v(" "),_("li",[_("ul",[_("li",[v._v("超时时间，单位毫秒。多久内连接不上判定节点不可用，状态异常")])])]),v._v(" "),_("li",[_("p",[v._v("sentinel parallel-syncs "),_("master-name",[v._v(" 1")])],1)]),v._v(" "),_("li",[_("p",[v._v("sentinel auth-pass "),_("master-name",[_("password")],1)],1)]),v._v(" "),_("li",[_("ul",[_("li",[v._v("如果主节点配置有密码，需要在哨兵节点添加密码。")])])])])])])])])]),v._v(" "),_("li",[_("p",[v._v("分片集群")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("最少3master，三主三从。")]),v._v(" "),_("li",[v._v("共享16384槽位，CRC16算法确定槽位。")]),v._v(" "),_("li",[v._v("cluster nodes 查看集群节点状态。")]),v._v(" "),_("li",[v._v("主节点掉线，从节点升级为主节点，主节点再上线成为从节点。")])])])]),v._v(" "),_("p",[v._v("配置：")]),v._v(" "),_("ul",[_("li",[v._v("cluster-enabled yes(开启集群模式/每一台redis实例)")]),v._v(" "),_("li",[v._v("cluster-config-file  配置文件名(自动生成)")]),v._v(" "),_("li",[v._v("cluster-node-timeout  (单位毫秒) 节点超时时间。")])]),v._v(" "),_("p",[v._v("操作：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("启动所有节点")])]),v._v(" "),_("li",[_("p",[v._v("使用redis-trib.rb创建集群")])]),v._v(" "),_("li",[_("ul",[_("li",[_("p",[v._v("redis的src目录下")])]),v._v(" "),_("li",[_("p",[v._v("./redis-trib.rb create --replicas 1 ip1:port1 ip2:port2 ....")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("1表示每个主节点绑定一个从节点 主从1对1")])])])])]),v._v(" "),_("li",[_("p",[v._v("连接集群命令 redis cli -c -p 端口号")])]),v._v(" "),_("li",[_("p",[v._v("连接非集群   redis cli -p 端口号")])])]),v._v(" "),_("p",[v._v("扩展集群：")]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("p",[v._v("MQ集群配置：")]),v._v(" "),_("p",[v._v("拦截器(HandlerInterceptor)作用位置：")]),v._v(" "),_("ul",[_("li",[v._v("preHandle：实现该方法，请求发生前进行拦截")]),v._v(" "),_("li",[v._v("postHandle：controller执行后进行拦截")]),v._v(" "),_("li",[v._v("afterCompletion：请求完成后进行拦截。")])]),v._v(" "),_("p",[v._v("SpringMVC在Springboot中如何配置：")]),v._v(" "),_("ul",[_("li",[v._v("自定义配置类实现WebMvcConfigurer接口；使用@Configuration及@EnableWebMvc注解修饰")])]),v._v(" "),_("p",[v._v("配置哪类数据：")]),v._v(" "),_("ul",[_("li",[v._v("拦截器")]),v._v(" "),_("li",[v._v("页面跳转")]),v._v(" "),_("li",[v._v("静态资源")]),v._v(" "),_("li",[v._v("视图解析")]),v._v(" "),_("li",[v._v("跨域")])]),v._v(" "),_("p",[v._v("Mysql加锁：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("LOCK TABLES 表名 [read/write];")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("eg： lock tables table1 read：table1加读锁。")])])])]),v._v(" "),_("p",[v._v("MYSQL什么情况下导致锁表：")]),v._v(" "),_("p",[v._v("BeanFactory与ApplicationContext(应用上下文)区别：")]),v._v(" "),_("ul",[_("li",[v._v("BeanFactory获取对象时才会创建对象，ApplicationContext继承了BeanFactory，扩展了高级特性。容器启动时创建所有对象。")]),v._v(" "),_("li")]),v._v(" "),_("p",[v._v("BeanFactory与FactoryBean：")]),v._v(" "),_("p",[v._v("内存溢出及问题排查：")]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("p",[v._v("spring事务的实现原理：")]),v._v(" "),_("ul",[_("li",[v._v("事务是由AOP实现的")])]),v._v(" "),_("p",[v._v("spring事务传播机制：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("REQUIRED(必须有事务,没有事务则新建)、REQUIRES_NEW(不支持当前事务，新建事务)、NESTED、SUPPORTS(可有可无，有事务就事务执行，否则非事务执行)、NOT_SUPPORTED(非事务执行，存在事务则挂起)、 MANDATORY(强制事务，没有则抛出异常)")])]),v._v(" "),_("li",[_("p",[v._v("事务的传播特性指的是不同方法嵌套调用过程中，事务如何处理(规则)。是使用同一个事务还是不同事务，出现异常是回滚还是提交。日常使用中较为频繁的REQUIRED、REQUIRES_NEW、NESTED(嵌套事务，使用外层方法事务)。")])]),v._v(" "),_("li",[_("p",[v._v("事务传播等级可分为三类：支持当前事务、不支持当前事务、嵌套事务。")])]),v._v(" "),_("li",[_("p",[v._v("核心处理逻辑：")])]),v._v(" "),_("li",[_("ul",[_("li",[_("p",[v._v("判断内外层是否为同一个事务")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("是：异常统一在外层进行处理")]),v._v(" "),_("li",[v._v("否：内层方法有可能影响外层，但外层不会影响内层")])])])])])]),v._v(" "),_("p",[v._v("REQUIRED与NESTED回滚的区别：")]),v._v(" "),_("ul",[_("li",[v._v("REQUIRED与外层一起成功一起失败")]),v._v(" "),_("li",[v._v("NESTED内层方法异常不会影响外层提交")])]),v._v(" "),_("p",[v._v("线上GC频繁问题的解决：")]),v._v(" "),_("p",[v._v("Redis相关：")]),v._v(" "),_("p",[v._v("redis是单线程还是多线程")]),v._v(" "),_("ul",[_("li",[v._v("redis工作线程只有1个")]),v._v(" "),_("li",[v._v("I/O多路复用机制同时监听多个客户端")]),v._v(" "),_("li",[v._v("6.0版本引入了IO多线程，网络I/O处理方面使用了多线程。")])]),v._v(" "),_("p",[v._v("redis是否线程安全")]),v._v(" "),_("ul",[_("li",[v._v("redis内部是串行的。")])]),v._v(" "),_("p",[v._v("缓存穿透")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("请求没有命中缓存，请求直接落到DB上。")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("数据库跟缓存都没有该数据")]),v._v(" "),_("li",[v._v("返回null set key null")]),v._v(" "),_("li",[v._v("布隆过滤器")])])])]),v._v(" "),_("p",[v._v("缓存击穿")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("请求没有命中缓存，请求直接落到DB上。")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("数据库有数据，缓存没数据。")])])])]),v._v(" "),_("p",[v._v("缓存雪崩")]),v._v(" "),_("ul",[_("li",[v._v("大量缓存数据过期，导致请求大量落到DB。")])]),v._v(" "),_("p",[v._v("缓存淘汰策略")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("先进先出FIFO，最先进来的数据最先淘汰")])]),v._v(" "),_("li",[_("p",[v._v("最近最少使用LRU")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("双向链表+哈希表")]),v._v(" "),_("li",[v._v("新数据加到链表头部，缓存命中数据移动至头部，删除尾部")])])]),v._v(" "),_("li",[_("p",[v._v("最不经常被使用LFU  按被访问次数排序")])])]),v._v(" "),_("p",[v._v("缓存过期删除")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("主动删除")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("设置删除间隔时间，指定时间后主动删除工作")]),v._v(" "),_("li",[v._v("在redis负载大的时候，主动删除会增加redis负担。")])])]),v._v(" "),_("li",[_("p",[v._v("惰性删除")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("取值时看是否过期，没过期返回，过期则删除。")]),v._v(" "),_("li",[v._v("容易造成某些数据长期存在不被删除的情况")])])]),v._v(" "),_("li",[_("p",[v._v("定期删除")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("=主动删除+惰性删除")]),v._v(" "),_("li",[v._v("每隔一段时间，主动删除。不主动删除时执行惰性删除。")])])])]),v._v(" "),_("p",[v._v("乐观锁：实际是没加锁的，在数据提交更新时才检测是否冲突。")]),v._v(" "),_("p",[v._v("悲观锁：修改数据前先锁定。")]),v._v(" "),_("p",[v._v("IOC容器的启动流程：")]),v._v(" "),_("p",[v._v("缓存与数据库的数据一致性：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("数据不一致产生的原因就是操作没有序列化进行")])]),v._v(" "),_("li",[_("p",[v._v("读写锁 redisson  redisson的读写锁也是基于lua脚本实现的(适用于读多写少的场景)")])]),v._v(" "),_("li",[_("p",[v._v("redisson获取读写锁对象，读缓存的读操作加读锁，写操作加写锁。")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("两进程一个读 一个写 不会存在互斥问题  两个都写 则序列化进行")])])])]),v._v(" "),_("p",[v._v("threadLocal(线程局部变量) 作用及使用场景：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("让变量私有化，为每个线程提供变量的副本，以此实现线程变量的隔离，各自操作自己的变量副本，不受影响。   一般静态修饰，防止内存泄露  remove使用完毕后移除")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("原理：内部存在一个threadLocalMap,key即为threadLocal map就是value。")]),v._v(" "),_("li",[v._v("场景 多数据源配置切换")])])])]),v._v(" "),_("p",[v._v("cpu使用率飙升排查")]),v._v(" "),_("ol",[_("li",[v._v("top：实时显示正在执行进程的cpu使用率，找到消耗cpu高的进程ID")]),v._v(" "),_("li",[v._v("top -p 进程id：单独监控该进程-")]),v._v(" "),_("li",[v._v("在单独进程监控页面数据H，获取当前进程下所有线程信息")]),v._v(" "),_("li",[v._v("找到资源消耗特别高的线程编号")]),v._v(" "),_("li",[v._v("使用 "),_("strong",[v._v("jstack 进程号")]),v._v(" 命令对当前进程做dump，输出所有线程信息。")]),v._v(" "),_("li",[v._v("将第四步找到的线程编号转16进制，在dump(信息查找相应内容)")]),v._v(" "),_("li",[v._v("根据线程信息，定位到具体的代码")])]),v._v(" "),_("p",[v._v("内存占用高问题排查")]),v._v(" "),_("ol",[_("li",[v._v("与上类似，找到占用内存高的进程号")]),v._v(" "),_("li",[v._v("通过jmap命令查看详细信息。定位代码")])]),v._v(" "),_("p",[v._v("jps命令：")]),v._v(" "),_("ol",[_("li",[v._v("显示当前系统java进程及id")])]),v._v(" "),_("p",[v._v("jstack :")]),v._v(" "),_("ul",[_("li",[v._v("用于打印指定java进程的堆栈信息。")])]),v._v(" "),_("p",[v._v("jmap：")]),v._v(" "),_("ul",[_("li",[v._v("查看内存信息、实例个数及占用空间大小")]),v._v(" "),_("li",[v._v("jmap -heap pid(进程号)  查看JVM堆内存分配情况")]),v._v(" "),_("li",[v._v("jmap -histo pid    查看该进程生成的对象(实例)信息")]),v._v(" "),_("li",[v._v("jmap -histo pid | head -n 100  占内存最大的100个实例信息")]),v._v(" "),_("li",[v._v("jmap -histo:live pid   查看该进程存活对象(实例)信息")]),v._v(" "),_("li",[v._v("jmap -histo pid > 文件路径   将相关信息存储到文件中")]),v._v(" "),_("li",[v._v("jmap -dump:format=b,file=文件名 [pid]   输出堆内存dump信息")])]),v._v(" "),_("p",[v._v("死锁：")]),v._v(" "),_("ul",[_("li",[v._v("两个或以上线程在执行中因争夺资源造成的相互等待的现象。")])]),v._v(" "),_("p",[v._v("网络协议：")]),v._v(" "),_("p",[v._v("JVM优化原则")]),v._v(" "),_("ul",[_("li",[v._v("GC调优3选2(吞吐量、延迟、内存)")]),v._v(" "),_("li",[v._v("不能为了优化而优化，上线时尽量把JVM参数设置到最优。")]),v._v(" "),_("li",[v._v("先优化代码、架构，再考虑JVM优化。")])]),v._v(" "),_("p",[v._v("什么情况下需要优化")]),v._v(" "),_("ul",[_("li",[v._v("堆内存(老年代)持续上涨达到设置的最大内存值")]),v._v(" "),_("li",[v._v("fullGC频繁")]),v._v(" "),_("li",[v._v("GC停顿时间过长(超过1s)")]),v._v(" "),_("li",[v._v("应用出现内存溢出异常")]),v._v(" "),_("li",[v._v("CPU或内存使用占比过高不下")]),v._v(" "),_("li",[v._v("系统吞吐量及性能下降")])]),v._v(" "),_("p",[v._v("面向对象：")]),v._v(" "),_("ul",[_("li",[v._v("封装：隐藏类的内部实现机制(private)保护数据，隐藏细节暴露方法")]),v._v(" "),_("li",[v._v("继承：从现有类派生新类，子类可看做特殊的父类。")]),v._v(" "),_("li",[v._v("多态：类和类之间的关系，父类引用可指向子类对象。")])]),v._v(" "),_("p",[v._v("Spring事务的原理：")]),v._v(" "),_("ul",[_("li",[v._v("使用声明式事务时，事务由spring框架进行控制。")]),v._v(" "),_("li",[v._v("spring会基于此类(@Transactional修饰的)生成一个代理对象，然后在使用时如果有事务处理，会把事务的自动提交给关闭，先执行具体的业务逻辑，没问题就提交，有问题就回滚。")])]),v._v(" "),_("p",[v._v("Spring事务的失效问题：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("bean对象没有被容器管理")])]),v._v(" "),_("li",[_("p",[v._v("方法非public")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("AOP没办法为这样的方法生成一个代理")])])]),v._v(" "),_("li",[_("p",[v._v("自身调用")])]),v._v(" "),_("li",[_("p",[v._v("数据库不支持事务")])]),v._v(" "),_("li",[_("p",[v._v("数据源没有配置事务管理器")])]),v._v(" "),_("li",[_("p",[v._v("异常被捕获")])]),v._v(" "),_("li",[_("p",[v._v("异常类型错误或配置错误")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("抛出异常为配置异常的上层")]),v._v(" "),_("li",[v._v("默认配置runtimeException")])])])]),v._v(" "),_("p",[v._v("配置文件优先级问题")]),v._v(" "),_("ul",[_("li",[v._v("配置文件三类yml、yaml、properties")]),v._v(" "),_("li",[v._v("加载顺序 yml>yaml>properties")]),v._v(" "),_("li",[v._v("优先级properties>yaml>yml")])]),v._v(" "),_("p",[v._v("springboot开启事务")]),v._v(" "),_("ul",[_("li",[v._v("启动类@EnableTransactionManagement注解")]),v._v(" "),_("li",[v._v("service层访问数据库的方法上使用@Transactional注解")])]),v._v(" "),_("p",[v._v("IOC容器的加载过程")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("读取配置文件，将bean转换成BeanDefinition(Bean定义)，存入BeanDefinitionMap(key为bean的名称value是相应的bean定义(BeanDefinition))。")])]),v._v(" "),_("li",[_("ol",[_("li",[v._v("首先BeanDefinitionReader读取配置类信息")]),v._v(" "),_("li",[v._v("然后BeanDefinitionScanner扫描配置类信息，确定哪些bean可以注入")]),v._v(" "),_("li",[v._v("最后由BeanDefinitionregistry负责注册bean定义到BeanDefinitionMap。")])])])]),v._v(" "),_("p",[v._v("数据库时间索引问题")]),v._v(" "),_("p",[v._v("消息队列常见问题")]),v._v(" "),_("p",[v._v("消息丢失")]),v._v(" "),_("p",[v._v("kafka")]),v._v(" "),_("p",[v._v("生产端->kafka结点消息丢失")]),v._v(" "),_("ol",[_("li",[v._v("设置ack登记")]),v._v(" "),_("li",[v._v("开启重试策略")]),v._v(" "),_("li",[v._v("使用带有回调的send()方法")])]),v._v(" "),_("p",[v._v("kafka结点->消费者   消费者拉到消息未消费挂掉了")]),v._v(" "),_("ol",[_("li",[v._v("offersets记录消费者消费的位置")]),v._v(" "),_("li",[v._v("设置auto.commit.enable=false，每次处理完手动提交")])]),v._v(" "),_("p",[v._v("kafka结点丢失")]),v._v(" "),_("ol",[_("li",[v._v("配置多副本")])]),v._v(" "),_("p",[v._v("rabbitMQ")]),v._v(" "),_("p",[v._v("生产者消息发送失败")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("生产者开启confirm(消息确认机制)")])]),v._v(" "),_("li",[_("ol",[_("li",[v._v("设置信道confirm模式，经该信道发送的消息有唯一的标识。")])])]),v._v(" "),_("li",[_("p",[v._v("生产者事务方式发送消息")])])]),v._v(" "),_("p",[v._v("rabbitMQ接收消息后丢失")]),v._v(" "),_("ol",[_("li",[v._v("开启rabbitMQ的持久化。")]),v._v(" "),_("li",[v._v("发送消息时设置消息的deliveryMode为2，进行消息持久化")])]),v._v(" "),_("p",[v._v("消费者消息丢失")]),v._v(" "),_("ol",[_("li",[v._v("关闭自动ack，消费后进行手动ack。")])]),v._v(" "),_("p",[v._v("消息重复(重复消费)")]),v._v(" "),_("p",[v._v("Kafka")]),v._v(" "),_("p",[v._v("生产者消息重复  kafka节点响应异常，导致生产者重试。")]),v._v(" "),_("ol",[_("li",[v._v("开启kafka结点的幂等性 设置应答等级-1，存在副本且应答最小副本数大于2")]),v._v(" "),_("li",[v._v("ack=0,不重试。 存在消息丢失的风险")])]),v._v(" "),_("p",[v._v("消费者消息重复    消费后 宕机没有返回最新offset导致重复消费")]),v._v(" "),_("p",[v._v("消费者处理耗时超过max.poll.interval.ms(两次拉取时间的间隔)导致认为当前消费者已经死掉触发再平衡。")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("手动ack")])]),v._v(" "),_("li",[_("p",[v._v("消费者实现消费幂等性")])]),v._v(" "),_("li",[_("ol",[_("li",[v._v("缓存消费的消息id")]),v._v(" "),_("li",[v._v("数据库唯一索引等")])])]),v._v(" "),_("li",[_("p",[v._v("针对于处理超时的情况，可以采用消息拉去后异步处理、减少每次拉取消息量、增加两次拉取间的处理间隔等方法进行优化。")])])]),v._v(" "),_("p",[v._v("rabbitMQ")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("生产者消息幂等性，确保不存在重复消息推送")])]),v._v(" "),_("li",[_("p",[v._v("消费端也实现幂等性，确保不重复消费")])]),v._v(" "),_("li",[_("ol",[_("li",[v._v("例如主键冲突之类的。")])])])]),v._v(" "),_("p",[v._v("消息堆积")]),v._v(" "),_("p",[v._v("动态代理与静态代理")]),v._v(" "),_("p",[v._v("动态代理的两种方式")]),v._v(" "),_("ul",[_("li",[v._v("JDK代理(InvocationHandler)")]),v._v(" "),_("li",[v._v("cglib")])]),v._v(" "),_("p",[v._v("客户端负载均衡与服务端负载均衡")]),v._v(" "),_("p",[v._v("Dubbo注解")]),v._v(" "),_("ul",[_("li",[v._v("@Service：将服务注册到dubbo")]),v._v(" "),_("li",[v._v("@Reference：注入服务对象")]),v._v(" "),_("li",[v._v("@EnableDubbo：标注在启动类上，表示启用dubbo")])]),v._v(" "),_("p",[v._v("Dubbo负载均衡策略")]),v._v(" "),_("ul",[_("li",[v._v("权重随机负载(默认)")]),v._v(" "),_("li",[v._v("权重轮训负载")]),v._v(" "),_("li",[v._v("最少活跃调用数")]),v._v(" "),_("li",[v._v("哈希一致性")])]),v._v(" "),_("p",[v._v("@Resource与@Autowired")]),v._v(" "),_("ul",[_("li",[v._v("@Autowired由Spring提供，@Resource由J2EE提供")]),v._v(" "),_("li",[v._v("@Autowired只byType(按类型注入)，@Resource支持byName(按名称注入)")])])])}),[],!1,null,null,null);_.default=t.exports}}]);