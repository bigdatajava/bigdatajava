(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{563:function(t,e,a){"use strict";a.r(e);var s=a(5),n=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、tomcat处理请求过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、tomcat处理请求过程"}},[t._v("#")]),t._v(" 一、Tomcat处理请求过程")]),t._v(" "),e("p",[t._v("Tomcat通过Endpoint组件接收socket连接，接收到一个socket连接后会执行如下步骤")]),t._v(" "),e("ol",[e("li",[t._v("第一次从socket中获取数据到InputBuffer中，BIO对应的是InternalInputBuffer，父类是\nAbstractInputBuffer")]),t._v(" "),e("li",[t._v("然后基于InputBuffer进行解析数据")]),t._v(" "),e("li",[t._v("先解析请求行，把请求方法，请求uri，请求协议等封装到org.apache.coyote.Request对象中")]),t._v(" "),e("li",[t._v("org.apache.coyote.Request中的属性都是MessageBytes类型，直接可以理解为字节类型，因为从\nsocket中获取的数据都是字节，在解析过程中不用直接把字节转成字符串，并且MessageBytes虽然表\n示字节，但是它并不会真正的存储字节，还是使用ByteChunk基于InputBuffer中的字节数组来进行标\n记，标记字节数组中的哪个一个范围表示请求方法，哪个一个范围表示请求uri等等。")]),t._v(" "),e("li",[t._v("然后解析头，和解析请求行类似")]),t._v(" "),e("li",[t._v("解析完请求头后，就基于请求头来初始化一些参数，比如Connection是keepalive是close，比如是否\n有Content-length，并且对于的⻓度是多少等等，还包括当前请求在处理请求体时应该使用哪个\nInputFilter。")]),t._v(" "),e("li",[t._v("然后将请求交给容器")]),t._v(" "),e("li",[t._v("容器再将请求交给具体的servlet进行处理")]),t._v(" "),e("li",[t._v("servlet在处理请求的过程中会利用response进行响应，返回数据给客户端，一个普通的响应过程会把\n数据先写入一个缓冲区，当调用flush，或者close方法时会把缓冲区中的内容发送给socet，下面有一\n篇单独的文章讲解tomcat响应请求过程")]),t._v(" "),e("li",[t._v("servlet处理完请求后，先会检查是否需要把响应数据发送给socket")]),t._v(" "),e("li",[t._v("接着看当前请求的请求体是否处理结束，是否还有剩余数据，如果有剩余数据需要把这些数据处理掉，以便能够获取到下一个请求的数据")]),t._v(" "),e("li",[t._v("然后回到第一步开始处理下一个请求。")])]),t._v(" "),e("h2",{attrs:{id:"二、tomcat响应数据过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、tomcat响应数据过程"}},[t._v("#")]),t._v(" 二、Tomcat响应数据过程")]),t._v(" "),e("p",[t._v("当我们在Servlet中调用如下方法")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('OutputStream outputStream = resp.getOutputStream();\noutputStream.write("test".getBytes());\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("p",[t._v("resp对应的类型为ResponseFacade, 得到的outputStream的类型为CoyoteOutputStream。\n所以响应数据是通过CoyoteOutputStream这个类处理的。\n当调用outputStream的write方法写数据时，实际调用的就是CoyoteOutputStream类的write(byte[] b)\n方法。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    @Override\n    public void write(byte[] b) throws IOException {\n        write(b, 0, b.length);\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        ob.write(b, off, len);\n    }\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[t._v("在CoyoteOutputStream类中有一个属性是ob，类型为org.apache.catalina.connector.OutputBuffer\n，该属性是在构造CoyoteOutputStream对象时初始化的。先注意OutputBuffer所在的包。\n我们在调用write方法时，实际就是调用OutputBuffer的write方法，而write方法实际调用的就是该类中的\nwriteBytes(byte b[], int off, int len)：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    private void writeBytes(byte b[], int off, int len) throws IOException {\n\n        if (closed) {\n            return;\n        }\n\n        bb.append(b, off, len);\n        bytesWritten += len;\n\n        // if called from within flush(), then immediately flush\n        // remaining bytes\n        if (doFlush) {\n            // 那么每次write都把缓冲中的数据发送出去\n            bb.flushBuffer();\n        }\n    }\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br")])]),e("p",[t._v("在OutputBuffer中有一个属性叫做bb，类型是ByteChunk。在Tomcat响应流程中，可以把ByteChunk类\n当作一个缓冲区的实现，该类中有一个字节数组，名字叫做buff，默认大小为8192。")]),t._v(" "),e("p",[t._v("当我们在write字节数据时，就是把数据添加到ByteChunk对应的缓冲区buff中。当把数据添加到缓冲区\n后，如果有其他线程在执行outputSteam的flush()方法，则doFlush为true，那么则会调用\nbb.flushBuffer()。")]),t._v(" "),e("p",[t._v("这里就要考虑一个问题，我们把数据都写到了缓冲区buff中，那么buff中的数据是何时传递给socket中的\n呢？")]),t._v(" "),e("p",[t._v("在ByteChunk中有一个属性out，类型是ByteOutputChannel，它表示缓冲区中的数据该向流向哪个渠\n道，为了方便理解，可以先理解为渠道就是socket，表示把缓冲区中的数据发送给socket，当实际情况并\n不是，暂且这么理解。")]),t._v(" "),e("p",[t._v("ByteOutputChannel类中有一个方法realWriteBytes(byte buf[], int off, int len)，当调用\nout.realWriteBytes(src, off, len)方法时，就会把src数据发送给对应驱动")]),t._v(" "),e("p",[t._v("在当前这个ByteChunk中，它的out对应的仍然还是org.apache.catalina.connector.OutputBuffer，在\n这个类中存在该方法：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    public void realWriteBytes(byte buf[], int off, int cnt) throws IOException {\n        if (closed) {\n            return;\n        }\n        if (coyoteResponse == null) {\n            return;\n        }\n        // If we really have something to write\n        if (cnt > 0) {\n            // real write to the adapter\n            outputChunk.setBytes(buf, off, cnt);\n            try {\n                coyoteResponse.doWrite(outputChunk);\n            } catch (IOException e) {\n                // An IOException on a write is almost always due to\n                // the remote client aborting the request. Wrap this\n                // so that it can be handled better by the error disp\n                atcher.\n                throw new ClientAbortException(e);\n            }\n        }\n    }\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br")])]),e("p",[t._v("该方法中通过一个outputChunk来标记数据，表示标记的这些数据是要发送给socket的。而真正的发送逻\n辑交给了coyoteResponse.doWrite(outputChunk)来进行处理，coyoteResponse的类型为\norg.apache.coyote.Response。")]),t._v(" "),e("p",[t._v("具体怎么将缓冲区中所标记的数据怎么发送出去的，我们等会再看，我们先来看到底何时会触发这个发送\n动作。")]),t._v(" "),e("p",[t._v("ByteChunk中有一个方法append，表示向缓冲区buff中添加数据，其中有一个逻辑，当缓冲区满了之后就\n会调用out.realWriteBytes(src, off, len)，表示把缓冲区中的数据发送出去。缓存区的大小有一个限制，\n可以修改，默认为8192。")]),t._v(" "),e("p",[t._v("还有一种情况就算缓冲区没有满，但是在write之前调用用过flush方法，那么本次write的数据会先放入缓\n冲区，然后再把缓冲区中的数据发送出去。")]),t._v(" "),e("p",[t._v("当我们调用outputStream的flush方法时：")]),t._v(" "),e("ol",[e("li",[t._v("先判断是否发送过响应头，没有发送则先发送响应头")]),t._v(" "),e("li",[t._v("再调用ByteChunk的flushBuffer方法，把缓冲区中剩余的数据发送出去")]),t._v(" "),e("li",[t._v("因为上文中我们所理解的将缓冲区的数据发送出去，是直接发送给socket，但实际情况是把数据发送给另外一个缓冲区，这个缓冲区也是用ByteChunk类实现的，名字叫做socketBuffer。所以当我们在使用flush方法时就需要把socketBuffer中的数据真正发送给socket。\n接下来我们来看看coyoteResponse.doWrite(outputChunk);的具体实现细节。\n该发方法实际调用的是outputBuffer.doWrite(chunk, this);这里的outputBuffer的类型是\nInternalOutputBuffer，在执行doWrite方法时，调用的是父类AbstractOutputBuffer的doWrite方法。\n该doWrite方法中，首先会判断响应头是否已经发送，如果没有发送，则会构造响应头，并发响应头发送给\nsocketBuffer，发送完响应头，会调用响应的output的activeFilters，对于不同的响应体需要使用不同的\n发送逻辑。比如ChunkedOutputFilter是用来发送分块响应体的，IdentityOutputFilter是用来发送\nContent-length响应体的，VoidOutputFilter不会真正的把数据发送出去。\n在构造响应头时，会识别响应体应该通过什么OutputFilter来发送，如果响应中存在content-length那么\n则使用IdentityOutputFilter来发送响应体，否则使用ChunkedOutputFilter，当然还有一些异常情况下会\n使用VoidOutputFilter，表示不会发送响应体。\n那现在的问题的，响应体的Content-length是在什么时候确定的？\n答案是：当请求在servlet中执行完成后，会调用response.finishResponse()方法，该方法会调用\noutputBuffer.close()，该outputBuffer就是org.apache.catalina.connector.OutputBuffer，该方法会\n判断响应体是否已发送，如果在调用这个close时响应头还没有发送，则表示响应体的数据在之前一直没有\n发送过，一直存在了第一层缓冲区中，并且一直没有塞满该缓冲区，因为该缓冲区如果被塞满了，则会发\n送响应头，所以当执行到close方法是，响应头还没发送过，那么缓冲区中的数据就是响应体全部的数据，\n即，缓冲区数据的⻓度就是content-length。\n反之，在调用close方法之前，就已经发送过数据了，那么响应头中就没有content-length，就会用\nChunkedOutputFilter来发送数据。\n并且在执行close方法时，会先将响应头的数据发送给socketbuffer，然后将第一层缓冲区的数据通过对应\n的OutputFilter发送给socketbuffer，然后调用OutputFilter的end方法，IdentityOutputFilter的end方\n法实现很简单，而ChunkedOutputFilter的end方法则相对做的事情更多一点，因为\nChunkedOutputFilter的doWrite一次只会发送一块数据，所以end要负责循环调用doWrite方法，把全部\n的数据库发送完。")])]),t._v(" "),e("h2",{attrs:{id:"三、tomcat中bio和nio底层原理实现对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、tomcat中bio和nio底层原理实现对比"}},[t._v("#")]),t._v(" 三、Tomcat中BIO和NIO底层原理实现对比")]),t._v(" "),e("p",[t._v("在Tomcat7中，默认为BIO，可以通过如下配置改为NIO")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" />\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h3",{attrs:{id:"bio"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[t._v("#")]),t._v(" BIO")]),t._v(" "),e("p",[t._v("BIO的模型比较简单。")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("JioEndpoint中的Acceptor线程负责循环阻塞接收socket连接")])]),t._v(" "),e("li",[e("p",[t._v("每接收到一个socket连接就包装成SocketProcessor扔进线程池Executor中，SocketProcessor是一个Runnable")])]),t._v(" "),e("li",[e("p",[t._v("SocketProcessor负责从socket中阻塞读取数据，并且向socket中阻塞写入数据")])])]),t._v(" "),e("p",[t._v("Acceptor线程的数量默认为1个，可以通过acceptorThreadCount参数进行配置\n线程池Executor是可以配置的，比如：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="150" minSpareThreads="4"/>\n<Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" executor="tomcatThreadPool"/>\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("p",[t._v("从上面的配置可以看到，每个Connector可以对应一个线程池，默认情况下，Tomcat中每个Connector都\n会创建一个自己的线程池，并且该线程池的默认值为：")]),t._v(" "),e("ol",[e("li",[t._v("最小线程数量为10")]),t._v(" "),e("li",[t._v("最大线程数量为200")])]),t._v(" "),e("p",[t._v("如果两个Connector配置的executor是一样的话，就表示这两个Connector公用一个线程池。\n使用BIO来处理请求时，我们可以总结一下：")]),t._v(" "),e("ol",[e("li",[t._v("当请求数量比较大时，可以提高Acceptor线程的数量，提高接收请求的速率")]),t._v(" "),e("li",[t._v("当请求比较耗时是，可以提高线程池Executor的最大线程数量")])]),t._v(" "),e("p",[t._v("当然，增加线程的目的都是为了提高Tomcat的性能，但是一台机器的线程数量并不是越多越好，需要利用\n压测来最终确定一个更加符合当前业务场景的线程数量。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618135324973.png",alt:"image-20220618135324973"}})]),t._v(" "),e("h3",{attrs:{id:"nio"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nio"}},[t._v("#")]),t._v(" NIO")]),t._v(" "),e("p",[t._v("最大的特性就是非阻塞，非阻塞接收socket连接，非阻塞从socket中读取数据，非阻塞从将数据写到\nsocket中。")]),t._v(" "),e("p",[t._v("但是在Tomcat7中，只有在从socket中读取请求行，请求头数据时是非阻塞的，在读取请求体是阻塞的，\n响应数据时也是阻塞的。")]),t._v(" "),e("p",[t._v("为什么不全是非阻塞的呢？因为Tomcat7对应Servlet3.0，Servlet3.0规范中没有考虑NIO，比如我们读取\n请求体的代码得这么写：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("        ServletInputStream inputStream = req.getInputStream();\n        byte[] bytes = new byte[1024];\n        int n;\n        while ((n = inputStream.read(bytes)) > 0) {\n            System.out.println(new String(bytes, 0, n));\n        }\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("p",[t._v("inputStream.read()方法的含义就是阻塞读取数据，当读取请求体时，如果操作系统中还没有准备好，那\n么read方法就得阻塞。")]),t._v(" "),e("p",[t._v("而NIO则不一样，NIO中是一旦操作系统中的数据准备好了，那么则会通知Java程序可以读取数据了，这里\n的通知很重要，这决定了我们的Java代码到底如何实现，如果在Servlet中想利用NIO去读取数据，那么在\nServlet中肯定就要去监听是否有通知过来，比如在Servlet3.1中则增加了NIO相关的定义，如下面代码：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("        ServletInputStream inputStream = req.getInputStream();\n        inputStream.setReadListener(new ReadListener() {\n            // 有数据可用时触发\n            @Override\n            public void onDataAvailable() throws IOException {\n\n            }\n\n            // 数据全部读完了\n            @Override\n            public void onAllDataRead() throws IOException {\n\n            }\n\n            // 出现异常了\n            @Override\n            public void onError(Throwable throwable) {\n\n            }\n        });\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br")])]),e("p",[t._v("很明显可以看出来，这里有Listener，用来监听数据可读的通知，这才是真正的利用了NIO。")]),t._v(" "),e("p",[t._v("而我们这里暂时只分析Tomcat7中的NIO，Servlet3.1是在Tomcat8中实现的，所以敬请期待吧。")]),t._v(" "),e("p",[t._v("首先我们来看一下Tomcat7中使用NIO处理请求的基本流程：")]),t._v(" "),e("ol",[e("li",[t._v("利用Acceptor来阻塞获取socket连接，NIO中叫socketChannel")]),t._v(" "),e("li",[t._v("接收到socketChannel后，需要将socketChannel绑定到一个Selector中，并注册读事件，另外，基于NIO还需要一个线程来轮询Selector中是否存在就绪事件，如果存在就将就绪事件查出来，并处理该事件，在Tomcat中支持多个线程同时查询是否存在就绪事件，该线程对象为Poller，每个Poller中都包含一个Selector，这样每个Poller线程就负责轮询自己的Selector上就绪的事件，然后处理事件。")]),t._v(" "),e("li",[t._v("当Acceptro接收到一个socketChannel后，就会将socketChannel注册到某一个Poller上，确定\nPolloer的逻辑非常简单，假设现在有3个Poller，编号为1,2,3，那么Tomcat接收到的第一个\nsocketChannel注册到1号Poller上，第二个socketChannel注册到2号Poller上，第三个\nsocketChannel注册到3号Poller上，第四个socketChannel注册到1号Poller上，依次循环。")]),t._v(" "),e("li",[t._v("在某一个Poller中，除开有selector外，还有一个ConcurrentLinkedQueue队列events，events表示待执行事件，比如Tomcat要socketChannel注册到selector上，但是Tomcat并没有直接这么做，而\n是先自己生成一个PollerEvent，然后把PollerEvent加入到队列events中，然后这个队列中的事件会在Poller线程的循环过程中真正执行")]),t._v(" "),e("li",[t._v("上面说了，Poller线程中需要循环查询selector中是否存在就绪事件，而Tomcat在真正查询之前会先看一下events队列中是否存在待执行事件，如果存在就会先执行，这些事件表示需要向selector上注册事件，比如注册socketChannel的读事件和写事件，所以在真正执行events队列中的事件时就会真正的向selector上注册事件。所以只有先执行events队列中的PollerEvent，Poller线程才能有机会从selector中查询到就绪事件")]),t._v(" "),e("li",[t._v("每个Poller线程一旦查询到就绪事件，就会去处理这些事件，事件无非就是读事件和写事件")]),t._v(" "),e("li",[t._v("处理的第一步就是获取当前就绪事件对应的socketChannel，因为我们要向socketChannel中读数据或写数据")]),t._v(" "),e("li",[t._v("处理的第二步就是把socketChannel和当前要做的事情（读或写）封装为SocketProcessor对象")]),t._v(" "),e("li",[t._v("处理的第三步就是把SocketProcessor扔进线程池进行处理")]),t._v(" "),e("li",[t._v("在SocketProcessor线程运行时，就会从socketChannel读取数据（假设当前处理的是读事件），并且是非阻塞读")]),t._v(" "),e("li",[t._v("既然是非阻塞读，大概的一个流程就是，某一个Poller中的selector查询到了一个读就绪事件，然后交给一个SocketProcessor线程进行处理，SocketProcessor线程读取数据之后，如果发现请求行和请求头的数据都已经读完了，并解析完了，那么该SocketProcessor线程就会继续把解析后的请求交给Servlet进行处理，Servlet中可能会读取请求体，可能会响应数据，而不管是读请求体还是响应数据都是阻塞的，直到Servlet中的逻辑都执行完后，SocketProcessor线程才会运行结束。假如\nSocketProcessor读到了数据之后，发现请求行或请求头的数据还没有读完，那么本次读事件处理完\n毕，需要Poller线程再次查询到就绪读事件才能继续读数据，以及解析数据")]),t._v(" "),e("li",[t._v("实际上Tomcat7中的非阻塞读就只是在读取请求行和请求体数据时才是非阻塞的，至于请求体的数据，是在Servlet中通过inputstream.read()方法获取时才会真正的去获取请求体的数据，并且是阻塞的。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618135822913.png",alt:"image-20220618135822913"}})]),t._v(" "),e("p",[t._v("接下来我们来看下Tomcat7中是怎么阻塞的利用NIO来读取数据的。")]),t._v(" "),e("p",[t._v("当Servlet中通过inputstream.read()来读取请求体数据时，最终执行的是InternalNioInputBuffer.SocketInputBuffer.doRead()方法。\n在这个方法中会调用fill(true,true)，第一个参数是timeout，第二个参数是block，block等于true，表示阻塞，fill方法中就会从操作系统读取数据填充到Tomcat的buf中。")]),t._v(" "),e("p",[t._v("在接下来的阻塞读取数据流程中，主要利用的还是Selector，为什么阻塞的时候还要利用Selector呢？这是因为，socketChannel一开始是非阻塞的，我们现在如果想把它改成阻塞的，在NIO里是有一个限制的，如果一个socketChannel被设置成了非阻塞的，然后注册了事件，然后又想把socketChannel设置成阻塞的，这时是会抛异常的。所以在Tomcat中是使用的另外的方式来达到阻塞效果的。")]),t._v(" "),e("p",[t._v("所以现在的目的是，仍然基于Selector的情况下达到阻塞效果，为了达到这个效果，原理也不难。")]),t._v(" "),e("p",[t._v("在我们需要读取请求体数据时，不能直接利用之前的主Selector了（主Selector就是用来注册新socketChannel的），所以我们需要一个辅助Selector，在读取请求体数据时，新生成一个辅助Selector，这个辅助Selector用来监听当前请求的读事件，当有数据就绪时，辅助Selector就会查询到此次就绪事件（注意：这个时候主Selector是监听不到的，因为在这之前主Selector已经取消了对当前socketChannel的事件）。")]),t._v(" "),e("p",[t._v("这是辅助Selector的主要作用，具体流程如下：")]),t._v(" "),e("ol",[e("li",[t._v("inputstream.read()")]),t._v(" "),e("li",[t._v("向辅助Selector注册读事件")]),t._v(" "),e("li",[t._v("加锁（目的是达到阻塞）")]),t._v(" "),e("li",[t._v("与辅助Selector对应的有另外一个辅助Poller，辅助Poller负责轮询辅助Selector上发生的就绪事件，\n一旦轮询到就绪事件就会解锁，从而解阻塞")]),t._v(" "),e("li",[t._v("从socketChannel中读数据")]),t._v(" "),e("li",[t._v("返回，本次read结束")])]),t._v(" "),e("p",[t._v("默认情况下，辅助Selector是NioBlockingSelector对象，每次read都使用同一个NioBlockingSelector\n对象，在NioBlockingSelector对象中存在一个BlockPoller线程，BlockPoller就是辅助Poller。\n对于响应也是类似的思路，也是先注册写事件，阻塞，都有写就绪事件时就解阻塞，开始写入数据。")]),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("在Tomcat7，虽然有NIO，但是不够彻底，相比如BIO，优点仅限于能利用较少的线程同时接收更多的请\n求，但是在真正处理请求时，想比如BIO并没有太多的优势，如果在处理一个请求时既不用读取请求，也不\n需要响应很多的数据那么NIO模式还是会拥有更大的吞吐量，所以如果要优化的话，将BIO改成NIO也是可\n以的。")]),t._v(" "),e("h2",{attrs:{id:"四、tomcat中的类加载器与安全机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、tomcat中的类加载器与安全机制"}},[t._v("#")]),t._v(" 四、Tomcat中的类加载器与安全机制")]),t._v(" "),e("h3",{attrs:{id:"类加载器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[t._v("#")]),t._v(" 类加载器")]),t._v(" "),e("p",[t._v("Java中的类遵循按需加载。\n所谓类加载器，就是用于加载 Java 类到 Java 虚拟机中的组件，它负责读取 Java 字节码，并转换成\njava.lang.Class 类的一个实例，使字节码.class 文件得以运行。一般类加载器负责根据一个指定的类找到\n对应的字节码，然后根据这些字节码定义一个 Java 类。另外，它还可以加载资源，包括图像文件和配置\n文件。\n类加载器在实际使用中给我们带来的好处是，它可以使 Java 类动态地加载到 JVM 中并运行，即可在程序\n运行时再加载类，提供了很灵活的动态加载方式。")]),t._v(" "),e("ul",[e("li",[t._v("启动类加载器（Bootstrap ClassLoader）：加载对象是 Java 核心库，把一些核心的 Java 类加载进\nJVM 中，这个加载器使用原生代码（C/C++）实现，并不是继承 java.lang.ClassLoader，它是所有\n其他类加载器的最终父加载器，负责加载 <JAVA_HOME>/jre/lib 目录下 JVM 指定的类库。其实它\n属于 JVM 整体的一部分，JVM 一启动就将这些指定的类加载到内存中，避免以后过多的 I/O 操作，\n提高系统的运行效率。启动类加载器无法被 Java 程序直接使用。")]),t._v(" "),e("li",[t._v("扩展类加载器（Extension ClassLoader）：加载的对象为 Java 的扩展库，即加载\n<JAVA_HOME>/jre/lib/ext 目录里面的类。这个类由启动类加载器加载，但因为启动类加载器并非\n用 Java 实现，已经脱离了 Java 体系，所以如果尝试调用扩展类加载器的 getParent()方法获取父加\n载器会得到 null。然而，它的父类加载器是启动类加载器。")]),t._v(" "),e("li",[t._v("应用程序类加载器（Application ClassLoader）：亦叫系统类加载器（System ClassLoader），它\n负责加载用户类路径（CLASSPATH）指定的类库，如果程序没有自己定义类加载器，就默认使用应用\n类加载器")])]),t._v(" "),e("p",[t._v("程序类加载器。它也由启动类加载器加载，但它的父加载类被设置成了扩展类加载器。如果要使用这个\n加载器，可通过 ClassLoader.getSystemClassLoader()获取。")]),t._v(" "),e("h4",{attrs:{id:"双亲委派"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派"}},[t._v("#")]),t._v(" 双亲委派")]),t._v(" "),e("p",[t._v("双亲委派模型会在类加载器加载类时首先委托给父类加载器加载，除非父类加载器不能加载才自己加载。\n这种模型要求，除了顶层的启动类加载器外，其他的类加载器都要有自己的父类加载器。假如有一个类要\n加载进来，一个类加载器并不会⻢上尝试自己将其加载，而是委派给父类加载器，父类加载器收到后又尝\n试委派给其父类加载器，以此类推，直到委派给启动类加载器，这样一层一层往上委派。只有当父类加载\n器反馈自己没法完成这个加载时，子加载器才会尝试自己加载。通过这个机制，保证了 Java 应用所使用\n的都是同一个版本的 Java 核心库的类，同时这个机制也保证了安全性。设想如果应用程序类加载器想要\n加载一个有破坏性的 java.lang.System 类，双亲委派模型会一层层向上委派，最终委派给启动类加载\n器，而启动类加载器检查到缓存中已经有了这个类，并不会再加载这个有破坏性的 System 类。\n另外，类加载器还拥有全盘负责机制，即当一个类加载器加载一个类时，这个类所依赖的、引用的其他所\n有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。\n在 Java 中，我们用完全匹配类名来标识一个类，即用包名和类名。而在 JVM 中，一个类由完全匹配类名\n和一个类加载器的实例 ID 作为唯一标识。也就是说，同一个虚拟机可以有两个包名、类名都相同的类，只\n要它们由两个不同的类加载器加载。当我们在 Java 中说两个类是否相等时，必须在针对同一个类加载器\n加载的前提下才有意义，否则，就算是同样的字节码，由不同的类加载器加载，这两个类也不是相等的。\n这种特征为我们提供了隔离机制，在 Tomcat 服务器中它是十分有用的。")]),t._v(" "),e("h4",{attrs:{id:"urlclassloader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#urlclassloader"}},[t._v("#")]),t._v(" URLClassLoader")]),t._v(" "),e("p",[t._v("我们在使用自定义类加载去加载类时，我们需要指明该去哪些资源中进行加载，所以JDK提供了\nURLClassLoader来方便我们使用，我们在创建URLClassLoader时需要传入一些URLs，然后在使用这个\nURLClassLoader加载类时就会从这些资源中去加载。")]),t._v(" "),e("h4",{attrs:{id:"tomcat中自定义的类加载器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat中自定义的类加载器"}},[t._v("#")]),t._v(" Tomcat中自定义的类加载器")]),t._v(" "),e("p",[t._v("Tomcat 拥有不同的自定义类加载器，以实现对各种资源库的控制。一般来说，Tomcat 主要用类加载器\n解决以下 4 个问题。")]),t._v(" "),e("ul",[e("li",[t._v("同一个Tomcat中，各个Web应用之间各自使用的Java类库要互相隔离。")]),t._v(" "),e("li",[t._v("同一个Tomcat中，各个Web应用之间可以提供共享的Java类库。")]),t._v(" "),e("li",[t._v("为了使Tomcat不受Web应用的影响，应该使服务器的类库与应用程序的类库互相独立。")]),t._v(" "),e("li",[t._v("Tomcat支持热部署。")])]),t._v(" "),e("p",[t._v("在 Tomcat中，最重要的一个类加载器是 Common 类加载器，它的父类加载器是应用程序类加载器，负责加载 $CATALINA_ BASE/lib、$CATALINA_HOME/lib 两个目录下所有的.class 文件与.jar 文件。")]),t._v(" "),e("p",[t._v("Tomcat中一般会有多个WebApp类加载器-WebAppClassLoader ，每个类加载器负责加载一个 Web 程序。它的父类加载器是Common类加载器。")]),t._v(" "),e("p",[t._v("由于每个 Web 应用都有自己的 WebApp 类加载器，很好地使多个 Web 应用程序之间互相隔离且能通过创建新的 WebApp类加载器达到热部署。这种类加载器结构能有效使 Tomcat 不受 Web 应用程序影响，而 Common 类加载器的存在使多个 Web 应用程序能够互相共享类库。")]),t._v(" "),e("h3",{attrs:{id:"tomcat中类加载器架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat中类加载器架构"}},[t._v("#")]),t._v(" Tomcat中类加载器架构")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/bigdatajava/picture/blob/master/algo/1.png",target:"_blank",rel:"noopener noreferrer"}},[t._v("picture/algo/1.png at master · bigdatajava/picture"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618140844956.png",alt:"image-20220618140844956"}})]),t._v(" "),e("h3",{attrs:{id:"安全机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全机制"}},[t._v("#")]),t._v(" 安全机制")]),t._v(" "),e("p",[t._v("Tomcat中设置了了一些安全策略，默认的策略文件为conf/catalina.policy。")]),t._v(" "),e("p",[t._v("Tomcat中设置了安全策略，规定了Tomcat在运行过程中拥有的权限，Tomcat管理者可以修改该权限，但是Tomcat中有一些类是必须能够被访问到的，所有Tomcat中在启动过程中会提前去加载这些类，如果发现没有对应的权限，那么将会启动失败")]),t._v(" "),e("h2",{attrs:{id:"五、tomcat的架构-生命周期-事件监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、tomcat的架构-生命周期-事件监听"}},[t._v("#")]),t._v(" 五、Tomcat的架构，生命周期，事件监听")]),t._v(" "),e("h3",{attrs:{id:"tomcat架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat架构"}},[t._v("#")]),t._v(" Tomcat架构")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618141220595.png",alt:"image-20220618141220595"}})]),t._v(" "),e("h3",{attrs:{id:"tomcat生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat生命周期"}},[t._v("#")]),t._v(" Tomcat生命周期")]),t._v(" "),e("p",[t._v("Tomcat架构是一种树状的层级管理结构，组件会有自己的父节点，也可能会有自己的孩子节点，每个节点都是组件，每个组件都有生命周期，为了管理方便，子节点的生命周期都是交由父节点来管理的。")]),t._v(" "),e("p",[t._v("每个组件生命周期的管理主要由一个接口org.apache.catalina.Lifecycle和一个枚举org.apache.catalina.LifecycleState来表示。")]),t._v(" "),e("h4",{attrs:{id:"lifecycle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lifecycle"}},[t._v("#")]),t._v(" Lifecycle")]),t._v(" "),e("p",[t._v("org.apache.catalina.Lifecycle接口定义了组件所有执行的动作，核心的有三个：")]),t._v(" "),e("ol",[e("li",[t._v("init()，组件进行初始化")]),t._v(" "),e("li",[t._v("start()，启动组件")]),t._v(" "),e("li",[t._v("stop()，停止组件")]),t._v(" "),e("li",[t._v("destroy()，销毁组件")]),t._v(" "),e("li",[t._v("getState()，获取组件当前状态")])]),t._v(" "),e("h4",{attrs:{id:"lifecyclestate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lifecyclestate"}},[t._v("#")]),t._v(" LifecycleState")]),t._v(" "),e("p",[t._v("org.apache.catalina.LifecycleState是一个枚举，表示组件的所有生命周期。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("NEW(false, null),\nINITIALIZING(false, Lifecycle.BEFORE_INIT_EVENT),\nINITIALIZED(false, Lifecycle.AFTER_INIT_EVENT),\nSTARTING_PREP(false, Lifecycle.BEFORE_START_EVENT),\nSTARTING(true, Lifecycle.START_EVENT),\nSTARTED(true, Lifecycle.AFTER_START_EVENT),\nSTOPPING_PREP(true, Lifecycle.BEFORE_STOP_EVENT),\nSTOPPING(false, Lifecycle.STOP_EVENT),\nSTOPPED(false, Lifecycle.AFTER_STOP_EVENT),\nDESTROYING(false, Lifecycle.BEFORE_DESTROY_EVENT),\nDESTROYED(false, Lifecycle.AFTER_DESTROY_EVENT),\nFAILED(false, null);\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])]),e("ul",[e("li",[t._v("枚举值表示状态")]),t._v(" "),e("li",[t._v("第一个参数表示当前状态下组件可不可用")]),t._v(" "),e("li",[t._v("第二个参数表示当变为当前状态时出发相应事件")])]),t._v(" "),e("h4",{attrs:{id:"生命周期流转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期流转"}},[t._v("#")]),t._v(" 生命周期流转")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618141556348.png",alt:"image-20220618141556348"}})]),t._v(" "),e("ol",[e("li",[t._v("所有状态都能转变为FAILED")]),t._v(" "),e("li",[t._v("一个组件在STARTING_PREP、STARTING、STARTED状态调用start()方法不会产生影响")]),t._v(" "),e("li",[t._v("一个组件在NEW状态调用start()方法时，会先调用init()方法")]),t._v(" "),e("li",[t._v("一个组件在STOPPING_PREP、STOPPING、STOPPED状态调用stop方法不会产生影响")]),t._v(" "),e("li",[t._v("一个组件在NEW状态调用stop()方法是，会将状态直接改为STOPPED。当组件自己启动失败去停止\n时，需要将子组件也进行停止，尽管某些子组件还没有启动。")]),t._v(" "),e("li",[t._v("其他状态相互转换都会抛异常")]),t._v(" "),e("li",[t._v("合法的状态转换发生时都会触发相应的LifecycleEvent事件，非合法的转换不会触发事件。")])]),t._v(" "),e("h3",{attrs:{id:"tomcat事件监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat事件监听"}},[t._v("#")]),t._v(" Tomcat事件监听")]),t._v(" "),e("h4",{attrs:{id:"事件触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件触发"}},[t._v("#")]),t._v(" "),e("strong",[t._v("事件触发")])]),t._v(" "),e("p",[t._v("Tomcat中每个组件的状态会发送变化，变化的时候会抛出一些事件，Tomcat支持定义事件监听器来监听\n并消费这些事件。")]),t._v(" "),e("h4",{attrs:{id:"事件执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件执行"}},[t._v("#")]),t._v(" 事件执行")]),t._v(" "),e("p",[t._v("实现事件监听功能的类为org.apache.catalina.util.LifecycleBase。每个组件都会继承这个类。")]),t._v(" "),e("p",[t._v("该类中有一个属性： "),e("code",[t._v("List<LifecycleListener> lifecycleListeners")]),t._v(" ; 该属性用来保存事件监\n听器，也就是说每个组件拥有一个事件监听器列表。\n该类中有一个方法：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    protected void fireLifecycleEvent(String type, Object data) {\n        LifecycleEvent event = new LifecycleEvent(this, type, data);\n        for (LifecycleListener listener : lifecycleListeners) {\n            listener.lifecycleEvent(event);\n        }\n    }\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("p",[t._v("当组件的状态发生变化时，会调用fireLifecycleEvent触发事件执行。比如当Server初始化时，会调用：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("setStateInternal(LifecycleState.STARTING_PREP, null, false);\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("该方法内部会执行：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("   String lifecycleEvent = state.getLifecycleEvent();\n    if(lifecycleEvent !=null){\n        fireLifecycleEvent(lifecycleEvent, data);\n    }\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h4",{attrs:{id:"事件监听器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件监听器"}},[t._v("#")]),t._v(" 事件监听器")]),t._v(" "),e("p",[t._v("程序员可以自定义事件监听器，只需实现LifecycleListener接口即可，比如：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class NamingContextListener implements LifecycleListene{...}\nclass FrameworkListener implements LifecycleListener{...}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("p",[t._v("定义好事件监听器后，每个组件就可以调用父类LifecycleBase中的addLifecycleListener()方法添加事件\n监听器到该组件的监听器列表中。")]),t._v(" "),e("h4",{attrs:{id:"总结-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("虽然说是事件监听，但实际上并不是异步触发，而是主动调用事件监听器")]),t._v(" "),e("h2",{attrs:{id:"六、tomcat启动过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、tomcat启动过程"}},[t._v("#")]),t._v(" 六、Tomcat启动过程")]),t._v(" "),e("h3",{attrs:{id:"解析server-xml"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析server-xml"}},[t._v("#")]),t._v(" 解析server.xml")]),t._v(" "),e("ol",[e("li",[t._v("Catalina catalina = new Catalina(); // 没做其他事情")]),t._v(" "),e("li",[t._v("catalina.setAwait(true);")]),t._v(" "),e("li",[t._v("以下步骤是解析servler.xml")]),t._v(" "),e("li",[t._v("StandardServer server = new StandardServer(); // 没做其他事情")]),t._v(" "),e("li",[t._v("catalina.setServer(server);")]),t._v(" "),e("li",[t._v("server.addLifecycleListener(...);")]),t._v(" "),e("li",[t._v("StandardService service = new StandardService(); // 没做其他事情")]),t._v(" "),e("li",[t._v("server.addService(service);")]),t._v(" "),e("li",[t._v("Connector connector = new Connector(); // 会根据配置初始化protocolHandler")])]),t._v(" "),e("ul",[e("li",[t._v("a. endpoint = new JIoEndpoint(); // 初始化Endpoint， JioEndpoint中会\nsetMaxConnections(0);")]),t._v(" "),e("li",[t._v("b. cHandler = new Http11ConnectionHandler(this); //")]),t._v(" "),e("li",[t._v("c. ((JIoEndpoint) endpoint).setHandler(cHandler); // endpoint对应的连接处理器")])]),t._v(" "),e("ol",{attrs:{start:"10"}},[e("li",[t._v("service.addConnector(connector);")]),t._v(" "),e("li",[t._v("Engine engine = new StandardEngine(); // pipeline.setBasic(new StandardEngineValve());")]),t._v(" "),e("li",[t._v("service.setContainer(engine);")]),t._v(" "),e("li",[t._v("Host host = new StandardHost(); // pipeline.setBasic(new StandardHostValve());")]),t._v(" "),e("li",[t._v("engine.addChild(host);")]),t._v(" "),e("li",[t._v("Context context = new StandardContext(); // pipeline.setBasic(new StandardContextValve());")]),t._v(" "),e("li",[t._v("host.addChild(context);")]),t._v(" "),e("li",[t._v("engine.setParentClassLoader(Catalina.class.getClassLoader()); // 实际调用的是ContainerBase.setParentClassLoader方法，设置属性parentClassLoader为shareClassLoader")]),t._v(" "),e("li",[t._v("server.setCatalina(catalina);")]),t._v(" "),e("li",[t._v("server.init(); // 开始初始化")]),t._v(" "),e("li",[t._v("catalina.start(); // 开始启动")])]),t._v(" "),e("h4",{attrs:{id:"总结-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结-3"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("解析server.xml最主要的作用就是")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("把server.xml中定义的节点都生成对应的java对象，比如在解析某一个Host节点时就会对应生成一个\nStandardHost对象")])]),t._v(" "),e("li",[e("p",[t._v("把server.xml中定义的节点的层级关系解析出来，比如StandardContext对\n象.addChild(StandardHost对象)")])]),t._v(" "),e("li",[e("p",[t._v("设置每个容器的pipeline的基础Valve")])])]),t._v(" "),e("h3",{attrs:{id:"初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618143959476.png",alt:"image-20220618143959476"}})]),t._v(" "),e("h4",{attrs:{id:"总结-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结-4"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("初始化做得事情比较少，最重要的可能就是endpoint的bind的了。")]),t._v(" "),e("h3",{attrs:{id:"启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动"}},[t._v("#")]),t._v(" 启动")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618144250195.png",alt:"image-20220618144250195"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618144304430.png",alt:"image-20220618144304430"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618144412055.png",alt:"image-20220618144412055"}})]),t._v(" "),e("p",[e("strong",[t._v("启动")])]),t._v(" "),e("p",[t._v("启动做的事情就比较多了，主要分为以下几个步骤")]),t._v(" "),e("h4",{attrs:{id:"启动容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动容器"}},[t._v("#")]),t._v(" 启动容器")]),t._v(" "),e("p",[t._v("启动容器主要是部署应用，部署应用分为两部分：")]),t._v(" "),e("p",[t._v("1.部署server.xml中定义的context")]),t._v(" "),e("p",[t._v("部署webapp文件夹下的context")]),t._v(" "),e("p",[t._v("部署一个应用主要分为以下步骤")]),t._v(" "),e("ol",[e("li",[t._v("生成Context对象，server.xml中定义的Context在解析server.xml时就已经生成了，webapp文件夹下\n的是在部署之前生成的")]),t._v(" "),e("li",[t._v("为每个应用生成一个WebappClassLoader")]),t._v(" "),e("li",[t._v("解析web.xml")]),t._v(" "),e("li",[t._v("设置Context对象中的属性，比如有哪些Wrapper")])]),t._v(" "),e("h4",{attrs:{id:"启动connector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动connector"}},[t._v("#")]),t._v(" 启动Connector")]),t._v(" "),e("p",[t._v("主要是：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("启动Endpoint开始接收请求")])]),t._v(" "),e("li",[e("p",[t._v("构造Mapper对象，用来处理请求时，快速解析出当前请求对应哪个Context，哪个Wrapper")])])]),t._v(" "),e("h2",{attrs:{id:"七、tomcat热部署与热加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、tomcat热部署与热加载"}},[t._v("#")]),t._v(" 七、Tomcat热部署与热加载")]),t._v(" "),e("p",[t._v("热部署和热加载是类似的，都是在不重启Tomcat的情况下，使得应用的最新代码生效。\n热部署表示重新部署应用，它的执行主体是Host，表示主机。\n热加载表示重新加载class，它的执行主体是Context，表示应用。")]),t._v(" "),e("h3",{attrs:{id:"tomcat中的后台线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat中的后台线程"}},[t._v("#")]),t._v(" Tomcat中的后台线程")]),t._v(" "),e("p",[t._v("热部署和热加载都需要监听相应的文件或文件夹是否发生了变化。它们都是由Tomcat的后台线程触发的。")]),t._v(" "),e("p",[t._v("BackgroundProcessor就表示后台线程。")]),t._v(" "),e("p",[t._v("每个容器都可以拥有一个BackgroundProcessor，但是默认情况下只有Engine容器会在启动的时候启动\n一个BackgroundProcessor线程。")]),t._v(" "),e("p",[t._v("该线程会每隔一段时间（可以设置，单位为秒），去执行后台任务，先执行本容器定义的后台任务，然后\n再执行子容器的定义的后台任务，子容器的任务执行完成后会继续执行其子容器的任务，直到没有子容器\n为止。从这里可以看出就算每个容器自己开启一个BackgroundProcessor，也只不过是多了一个执行相\n同任务的线程而已，执行任务的效率有所提升。")]),t._v(" "),e("p",[t._v("对于后台任务，所有容器会有一些统一的任务需要执行：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("集群服务器心跳")])]),t._v(" "),e("li",[e("p",[t._v("如果一个容器拥有自己的类加载器，那么查看是否需要进行热加载")])]),t._v(" "),e("li",[e("p",[t._v("检查Session是否过期")])]),t._v(" "),e("li",[e("p",[t._v("执行每个容器对于的Realm对应的后台任务")])]),t._v(" "),e("li",[e("p",[t._v("执行每个容器中pipeline中的每个valve的后台任务")])]),t._v(" "),e("li",[e("p",[t._v("发布PERIODIC_EVENT事件")])])]),t._v(" "),e("p",[t._v("在这个过程中的第2步中会触发热加载，第6步中会触发热部署")]),t._v(" "),e("h3",{attrs:{id:"热加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#热加载"}},[t._v("#")]),t._v(" 热加载")]),t._v(" "),e("p",[t._v("我们可以在Context上配置reloadable属性为true，这样就表示该应用开启了热加载功能，默认是false。\n热加载触发的条件是：WEB-INF/classes目录下的文件发生了变化，WEB-INF/lib目录下的jar包添加、\n删除、修改都会触发热加载。")]),t._v(" "),e("p",[t._v("热加载大致流程为：")]),t._v(" "),e("ol",[e("li",[t._v("设置当前Context不能接受以及处理请求标志为true")]),t._v(" "),e("li",[t._v("停止当前Context")]),t._v(" "),e("li",[t._v("启动当前Context")]),t._v(" "),e("li",[t._v("设置当前Context不能接受以及处理请求标志为false")])]),t._v(" "),e("p",[t._v("我们着重来分析一下第2、3步。\n我们不妨先来分析第3步-启动当前Context的过程中会发生什么事情：")]),t._v(" "),e("ol",[e("li",[t._v("创建一个每个应用都单独自定义的WebappClassLoader")]),t._v(" "),e("li",[t._v("解析web.xml文件，这一步会做很多事情，但是主要的目的是寻找定义的Servlet并把它添加到Context\n中去，而对于寻找Servlet需要进行两个方面的寻找，一是从web.xml中寻找定义的Servlet，二是从寻\n找class文件中添加了@WebServlet注解的类。大家很有可能认为，此时是不是会去加载我们定义的\nServlet类，可以告诉大家的是，这个时候不会，Servlet类的加载是在后面步骤发生的，那么这里就有\n疑问了，我们要看一个类上是不是存在一个@WebServlet注解，应该要先加载这个类呀？Tomcat并没\n有这么做，它是直接先把class文件当做一个普通文件，然后看这个文件对应的地方是否存在一个\nWebServlet注解，如果存在，则认为这个class文件是一个Servlet，然后把这个class的全名封装到\nServlet对象中去，然后将Servlet对象添加到Context对象中。在解析web.xml时也是类似了，对于我\n们定义的Servlet，最后都会生成一个Servlet对象，然后记录一个这个Servlet对象对应的class的全\n名，最后把Servlet对象添加到Context中去。")]),t._v(" "),e("li",[t._v("我们在使用Servlet的时候还会用其他的一些注解比如@ServletSecurity、@RunAs等等，对于这些注解是有特定功能的，Tomcat为了识别这个注解，此时就要去真正加载我们的Servlet类了。当然要不要识别这些注解是可以配置的，如果不识别，那么这一步就不会发生了，那么Servlet类的加载就会在有请求过来时才会进行类的加载。")])]),t._v(" "),e("p",[t._v("加载类过程：")]),t._v(" "),e("ol",[e("li",[t._v("调用WebappClassLoaderBase的loadClass方法进行类的加载，该方法传递一个类的全限定名。")]),t._v(" "),e("li",[t._v("要加载一个类，先得找到这个类在哪里，对应的是哪个classs文件，所以Tomcat中有一个缓存对象，\n该对象保存了一个类的全限定名对应的资源路径。当然，在第一次加载这个类时，这个缓存是空的，所\n以这个时候就要去寻找这个类对应的class文件地址，找到之后再缓存。接下来就来分析是怎么找到这\n个class文件地址的。")]),t._v(" "),e("li",[t._v("其实查找很容易，现在WEB-INF/classes/目录下是否存在这个类，如果不存在就看WEB-INF/lib/目录下的JAR包中是否存在这个类，最终如果找到就将进行缓存，保存一个类的全限定名对应的class文件地址或jar包地址。")]),t._v(" "),e("li",[t._v("当知道这个类在哪了之后，就可以defineClass了，最终得到一个class对象，并且也会将这个class对象设置到我们的缓存中，所以上文说的缓存中，其实是这么一个映射关系，一个类的全限定名对应这个类的文件地址以及这个类的class对象。")]),t._v(" "),e("li",[t._v("所以当下次再有情况需要加载class时，就可以直接取缓存中的对应的class对象了。")])]),t._v(" "),e("p",[t._v("这是第3步，我们在来看第2步：\n对于第2步-停止当前Context，其实所做的事情比较单一，就是清空和销毁，而其中跟类加载相关就是清空上文中的缓存对象。")]),t._v(" "),e("p",[t._v("这样，我们的热加载就是先清空所有东⻄，然后重新启动我们应用，但是因为这个的触发条件基本上是class类发生了变化，所以热加载的过程中关于应用其他的一些属性是没有发生变化的，比如你现在想在Context中添加一个Vavle是不会触发热加载的，而如果要达到这个效果就要用到热部署。")]),t._v(" "),e("blockquote",[e("p",[t._v("注意：虽然我们在热加载的过程发现它是先停止再启动，做法看似粗暴，但是这样是性价比比较高的，\n并且这种方式至少比重启Tomcat效率要高很多。")])]),t._v(" "),e("blockquote",[e("p",[t._v("注意：热加载不能用于war包")])]),t._v(" "),e("p",[t._v("关于类的加载，这里有一点是需要注意的，对于一个class文件所表示的类，同一个类加载器的不同实例，都可以加载这个类，并且得到的class对象是不同的，回到热加载，我们举一个例子，我们现在有一个A类，一个自定义的WebappClassloader类，一开始先用一个WebappClassloader实例加载A类，那么在\njvm中就会存在一个A类的class对象，然后进行热加载，先停止，再启动，在停止的时候会杀掉当前应用的所有线程（除开真正执行代码的线程），再启动时又会生成一个WebappClassloader实例来加载A类，如果热加载之前的那个A类的class对象还没有被回收的话，那么此时jvm中其实会存在两个A类的class对\n象，这是不冲突，因为class对象的唯一标志是类加载器实例对象+类的全限定名。")]),t._v(" "),e("h3",{attrs:{id:"热部署"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#热部署"}},[t._v("#")]),t._v(" 热部署")]),t._v(" "),e("p",[t._v("BackgroundProcessor线程第六步会发出一个PERIODIC_EVENT事件，而HostConfig监听了此事件，当接收到此事件后就会执行热部署的检查与操作。")]),t._v(" "),e("p",[t._v("对于一个文件夹部署的应用，通常会检查以下资源是否发生变动：")]),t._v(" "),e("ul",[e("li",[t._v("/tomcat-7/webapps/应用名.war")]),t._v(" "),e("li",[t._v("/tomcat-7/webapps/应用名")]),t._v(" "),e("li",[t._v("/tomcat-7/webapps/应用名/META-INF/context.xml")]),t._v(" "),e("li",[t._v("/tomcat-7/conf/Catalina/localhost/应用名.xml")]),t._v(" "),e("li",[t._v("/tomcat-7/conf/context.xml")])]),t._v(" "),e("p",[t._v("对于一个War部署的应用，会检查以下资源是否发生变动：")]),t._v(" "),e("ul",[e("li",[t._v("/tomcat-7/webapps/应用名.war")]),t._v(" "),e("li",[t._v("/tomcat-7/conf/Catalina/localhost/应用名.xml")]),t._v(" "),e("li",[t._v("/tomcat-7/conf/context.xml")])]),t._v(" "),e("p",[t._v("对于一个描述符部署的应用，会检查以下资源是否发生变动：")]),t._v(" "),e("ul",[e("li",[t._v("/tomcat-7/conf/Catalina/localhost/应用名.xml")]),t._v(" "),e("li",[t._v("指定的DocBase目录")]),t._v(" "),e("li",[t._v("/tomcat-7/conf/context.xml")])]),t._v(" "),e("p",[t._v("一旦这些文件或目录发生了变化，就会触发热部署，当然热部署也是有开关的，在Host上，默认是开启\n的。这里需要注意的是，对于一个目录是否发生了变化，Tomcat只判断了这个目录的修改时间是否发生了\n变化，所以和热加载是不冲突的，因为热加载监听的是WEB-INF/classes和WEB-INF/lib目录，而热部\n署监听的是应用名那一层的目录。")]),t._v(" "),e("p",[t._v("在讲热部署的过程之前，我们要先讲一下应用部署的优先级，对于一个应用，我们可以在四个地方进行定\n义：")]),t._v(" "),e("ol",[e("li",[t._v("server.xml中的context节点")]),t._v(" "),e("li",[t._v("/tomcat-7/conf/Catalina/localhost/应用名.xml")]),t._v(" "),e("li",[t._v("/tomcat-7/webapps/应用名.war")]),t._v(" "),e("li",[t._v("/tomcat-7/webapps/应用名")])]),t._v(" "),e("p",[t._v("优先级就是上面所列的顺序，意思是同一个应用名，如果你在这个四个地方都配置了，那么优先级低的将不起作用。因为Tomcat在部署一个应用的时候，会先查一下这个应用名是否已经被部署过了。热部署的过程：如果发生改变的是文件夹，比如/tomcat-7/webapps/应用名，那么不会做什么事情，只是会更新一下记录的修改时间，这是因为这个/tomcat-7/webapps/应用名目录下的文件，要么是jsp文件，要么是其他文件，而Tomcat只会管jsp文件，而对于jsp文件如果发生了修改，jsp自带的机制会处理修改的。")]),t._v(" "),e("p",[t._v("如果发生改变的是/tomcat-7/conf/Catalina/localhost/应用名.xml文件，那么就是先undeploy，然后再deploy，和热加载其实类似。对于undeploy就不多说了，就是讲当前应用从host从移除，这就包括了当前应用的停止和销毁，然后还会从已部署列表中移除当前应用，然后调用deployApps()就可以重新部署应用了。")]),t._v(" "),e("h2",{attrs:{id:"八、tomcat中关于session的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八、tomcat中关于session的实现"}},[t._v("#")]),t._v(" 八、Tomcat中关于session的实现")]),t._v(" "),e("h3",{attrs:{id:"标准会话对象-standardsession"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标准会话对象-standardsession"}},[t._v("#")]),t._v(" 标准会话对象-StandardSession")]),t._v(" "),e("ul",[e("li",[t._v("Session 接口定义了 Tomcat 内部用来操作会话的一些方法。")]),t._v(" "),e("li",[t._v("Serializable 则是序列化接口，实现它是为了方便传输及持久化。")]),t._v(" "),e("li",[t._v("HTTPSession 是 Servlet 规范中为会话操作而定义的一些方法，作为一个标准 Web 容器，实现它是\n必然的。")])]),t._v(" "),e("p",[t._v("一个最简单的标准会话应该包括 ID 和 Map<String，Object> 结构的属性。其中，ID 用于表示会话编\n号，它必须是全局唯一的，属性用于存储会话相关信息，以 KV 结构存储。另外，它还应该包括会话创建\n时间、事件监听器，并且提供 Web 层面访问的外观类等。")]),t._v(" "),e("h3",{attrs:{id:"标准会话管理器-standardmanager"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标准会话管理器-standardmanager"}},[t._v("#")]),t._v(" 标准会话管理器-StandardManager")]),t._v(" "),e("p",[t._v("用于保存状态的会话对象已经有了，现在就需要一个管理器来管理所有会话。例如，会话 ID 生成，根据会\n话 ID 找出对应的会话，对于过期的会话进行销毁等操作。用一句话描述标准会话管理器：提供一个专⻔管\n理某个 Web 应用所有会话的容器，并且会在 Web 应用启动、停止时进行会话重加载和持久化。")]),t._v(" "),e("p",[t._v("会话管理主要提供的功能包括会话 ID 生成器、后台处理（处理过期会话）、持久化模块及会话集的维护。\n如下图所示，标准会话管理器包含了 SessionIdGenerator 组件、backgroundProcess 模块、持久化模\n块以及会话集合。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618145938265.png",alt:"image-20220618145938265"}})]),t._v(" "),e("p",[t._v("首先看 SessionIdGenerator，它负责为每个会话生成、分配一个唯一标识。例如，最终会生成类似\n「326257DA6DB76F8D2E38F2C4540D1DEA」字符串的会话标识。具体的默认生成算法主要依靠 JDK\n提供的 SHA1PRNG 算法。在集群环境中，为了方便识别会话归属，它最终生成的会话标识类似于\n「326257DA6DB76F8D2E38F2C4540D1DEA.tomcat1」，后面会加上 Tomcat 的集群标识 jvmRoute\n变量的值，这里假设其中一个集群标识配置为「tomcat1」。如果你想置换随机数生成算法，可以通过配\n置 server.xml 的 Manager 节点 secureRandomAlgorithm 及 secureRandomClass 属性达到修改算法\n的效果。")]),t._v(" "),e("p",[t._v("然后看如何对过期会话进行处理。负责判断会话是否过期的逻辑主要在 backgroundProcess 模块\n中，在 Tomcat 容器中会有一条线程专⻔用于执行后台处理。当然，也包括标准会话管理器的\nbackgroundProcess，它不断循环判断所有的会话中是否有过期的，一旦过期，则从会话集中删除此会\n话。")]),t._v(" "),e("p",[t._v("最后是关于持久化模块和会话集的维护。由于标准会话旨在提供一个简单便捷的管理器，因此持久化\n和重加载操作并不会太灵活且扩展性弱，Tomcat 会在每个 StandardContext（Web 应用）停止时调用\n管理器将属于此 Web 应用的所有会话持久化到磁盘中。文件名为 SESSIONS.ser，而目录路径则由\nserver.xml 的 Manager 节点 pathname 指定或 Javax.servlet. context.tempdir 变量指定，默认存放\n路径为%CATALINA_HOME%/work/Catalina/localhost/ WebName/SESSIONS.ser。当 Web 应用启\n动时，又会加载这些持久化的会话，加载完成后，SESSIONS.ser 文件将会被删除，所以每次启动成功后\n就不会看到此文件的存在。另外，会话集的维护是指提供创建新会话对象、删除指定会话对象及更新会话\n对象的功能。")]),t._v(" "),e("h2",{attrs:{id:"九、spring-boot启动扫描servlet"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#九、spring-boot启动扫描servlet"}},[t._v("#")]),t._v(" 九、Spring Boot启动扫描Servlet")]),t._v(" "),e("ol",[e("li",[t._v("@ServletComponentScan负责扫描@WebServlet，每个Servlet对应一个\nServletContextInitializer(接口)，对应的实现类是ServletRegistrationBean")]),t._v(" "),e("li",[t._v("SpringApplication.run(Application.class)里面会去创建一个\nServletWebServerApplicationContext，最终会调用该类的onRefresh方法")]),t._v(" "),e("li",[t._v("调用createWebServer方法创建并启动Tomcat")]),t._v(" "),e("li",[t._v("在创建的Tomcat的过程中会创建一个TomcatStarter，并且在创建TomcatStarter时将\nServletContextInitializer传进去，TomcatStarter实现了ServletContainerInitializer接口，该接口是Servlet规范中的接口")]),t._v(" "),e("li",[t._v("启动Tomcat")]),t._v(" "),e("li",[t._v("启动Tomcat后，Tomcat会负责调用TomcatStarter中的onStartup方法")]),t._v(" "),e("li",[t._v("循环调用每个ServletContextInitializer的onStartup方法，并且把servletContext传给\nServletContextInitializer")]),t._v(" "),e("li",[t._v("最终在ServletRegistrationBean中将ServletRegistrationBean对应的Servlet添加到servletContext\n中")])]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("h2",{attrs:{id:"tomcat源码编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tomcat源码编译"}},[t._v("#")]),t._v(" Tomcat源码编译")]),t._v(" "),e("p",[t._v("链接：https://pan.baidu.com/s/1h_u8AuGojdHqwYsKS24YGw&shfl=sharepset\n提取码：hulx")]),t._v(" "),e("p",[t._v("源码地址：https://gitee.com/archguide/tomcat")]),t._v(" "),e("h2",{attrs:{id:"idea中运行tomcat-9源码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#idea中运行tomcat-9源码"}},[t._v("#")]),t._v(" IDEA中运行Tomcat 9源码")]),t._v(" "),e("h3",{attrs:{id:"使用idea从github上克隆源码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用idea从github上克隆源码"}},[t._v("#")]),t._v(" 使用IDEA从GITHUB上克隆源码")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150537834.png",alt:"image-20220618150537834"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150556989.png",alt:"image-20220618150556989"}})]),t._v(" "),e("h3",{attrs:{id:"源码克隆下来后-不能直接运行-需要用ant进行编译-主要目的是下载依赖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码克隆下来后-不能直接运行-需要用ant进行编译-主要目的是下载依赖"}},[t._v("#")]),t._v(" 源码克隆下来后，不能直接运行，需要用ant进行编译，主要目的是下载依赖")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150614452.png",alt:"image-20220618150614452"}}),t._v("\n在用ant编译之前，建议先修改build.properties.default文件中的base.path的值，ant编译时需要去下载\n第三方jar包，base.path将指定这些jar存放的位置。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150644143.png",alt:"image-20220618150644143"}})]),t._v(" "),e("p",[t._v("修改完成后，在源码目录下使用命令行执行ant ide-intellij进行编译。执行命令后需要等待一段时间。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150659892.png",alt:"image-20220618150659892"}})]),t._v(" "),e("p",[t._v("执行成功后在工程目录结构中多出一个文件夹，该文件夹保存了Tomcat源码所依赖的jar。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150720479.png",alt:"image-20220618150720479"}})]),t._v(" "),e("p",[t._v("我们要把该文件夹下的jar加入到classpath中去，进入到Project Structure。把下载的依赖添加进来")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150739778.png",alt:"image-20220618150739778"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150752587.png",alt:"image-20220618150752587"}})]),t._v(" "),e("h3",{attrs:{id:"依赖添加进来后-可以尝试使用idea构建工程了。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖添加进来后-可以尝试使用idea构建工程了。"}},[t._v("#")]),t._v(" 依赖添加进来后，可以尝试使用IDEA构建工程了。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150802817.png",alt:"image-20220618150802817"}})]),t._v(" "),e("p",[t._v("构建过程中可能会报错，比如：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150823352.png",alt:"image-20220618150823352"}})]),t._v(" "),e("p",[t._v("该modules下的几个模块都是maven工程，右键pom.xml文件点击Add as Maven Project，点击后会自动下载依赖，从而解决构建报错，其他模块也类似。\n对三个模块都下载依赖后，重新构建后，可能会报如下错误：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150846554.png",alt:"image-20220618150846554"}})]),t._v(" "),e("p",[t._v("提示ant包不存在，需要引入ant.jar的依赖，还是一样，打开Project Structure，选择tomcat Module，\n添加依赖，将ant.jar添加进来，这里需要注意，Tomcat默认用的是ant-1.9.8.jar，所以可以提前把这个\njar下载在电脑上，然后引入此jar。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150904181.png",alt:"image-20220618150904181"}})]),t._v(" "),e("p",[t._v("但是Apply的时候，会提示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150923203.png",alt:"image-20220618150923203"}})]),t._v(" "),e("p",[t._v("这个我也不知道怎么办了...，解决办法是，将ant-1.9.8.jar保存在tomcat-build-jars文件夹下，然后右键\n该jar，点击Add as Library。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150940612.png",alt:"image-20220618150940612"}})]),t._v(" "),e("p",[t._v("点击ok，可以绕过刚刚的错误。重新构建，仍然会报错：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618150955411.png",alt:"image-20220618150955411"}})]),t._v(" "),e("p",[t._v("将@VERSION@改成9即可，再次重新构建，构建没有问题了。")]),t._v(" "),e("p",[t._v("如果构建后没有报错，但是下图的这个Java文件中还是报红色，这应该是IDEA的问题，只需要手动的使用\nIDEA的快捷提示重新import一下依赖即可。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151018694.png",alt:"image-20220618151018694"}})]),t._v(" "),e("h3",{attrs:{id:"构建成功后-运行源代码。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建成功后-运行源代码。"}},[t._v("#")]),t._v(" 构建成功后，运行源代码。")]),t._v(" "),e("p",[t._v("Tomcat的启动类是org.apache.catalina.startup.Bootstrap类。直接运行此类中的Main方法可以看到\nTomcat的启动日志。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151033710.png",alt:"image-20220618151033710"}})]),t._v(" "),e("p",[t._v("但是我的机器上有乱码，Tomcat做了国际化.\n增加运行参数：-Duser.language=en。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151053393.png",alt:"image-20220618151053393"}})]),t._v(" "),e("p",[t._v("增加之后再运行就没有问题了。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151103095.png",alt:"image-20220618151103095"}})]),t._v(" "),e("p",[t._v("但是此时访问localhost:8080，仍然会报错，看不到我们想看到的熟悉的Tomcat欢迎⻚")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151116901.png",alt:"image-20220618151116901"}})]),t._v(" "),e("p",[t._v("这是因为Tomcat内部使用了SPI机制来初始化jsp相关的东⻄，手动运行源码的过程中默认不会去初始化\njsp相关。")]),t._v(" "),e("p",[t._v("我们找到")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151140467.png",alt:"image-20220618151140467"}})]),t._v(" "),e("p",[t._v("在工程目录下新建resouces文件夹，然后新建META-INF文件夹，然后将上图中的services文件夹复制到\nMETA-INF文件中，最后将resources文件夹加入到classpath中。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151155039.png",alt:"image-20220618151155039"}})]),t._v(" "),e("p",[t._v("重新运行Bootstrap，访问正常。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/image-20220618151207033.png",alt:"image-20220618151207033"}})]),t._v(" "),e("p",[t._v("​")])])}),[],!1,null,null,null);e.default=n.exports}}]);