(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{430:function(t,e,i){"use strict";i.r(e);var v=i(5),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"综述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#综述"}},[t._v("#")]),t._v(" 综述")]),t._v(" "),e("blockquote",[e("p",[t._v("Ra bbitMQ 官方地址：http://www.Ra bbitMQ.com/")])]),t._v(" "),e("p",[t._v("2007年，Rabbit 技术公司基于 AMQP 标准开发的 Ra bbitMQ 1.0 发布。Ra bbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。")]),t._v(" "),e("p",[t._v("Ra bbitMQ基础架构：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831211758810.png",alt:"image-20210831211758810"}})]),t._v(" "),e("h2",{attrs:{id:"相关概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[t._v("#")]),t._v(" 相关概念")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("Broker")]),t._v("：接收和分发消息的应用，Ra bbitMQ Server就是 Message Broker")]),t._v(" "),e("li",[e("strong",[t._v("Virtual host")]),t._v("：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 Ra bbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等")]),t._v(" "),e("li",[e("strong",[t._v("Connection")]),t._v("：publisher／consumer 和 broker 之间的 TCP 连接")]),t._v(" "),e("li",[e("strong",[t._v("Channel")]),t._v("：如果每一次访问 Ra bbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销")]),t._v(" "),e("li",[e("strong",[t._v("Exchange")]),t._v("：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)")]),t._v(" "),e("li",[e("strong",[t._v("Queue")]),t._v("：消息最终被送到这里等待 consumer 取走")]),t._v(" "),e("li",[e("strong",[t._v("Binding")]),t._v("：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据")])]),t._v(" "),e("h2",{attrs:{id:"快速入门案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速入门案例"}},[t._v("#")]),t._v(" 快速入门案例")]),t._v(" "),e("p",[t._v("https://gitee.com/nylg/picture/tree/master/file/Ra bbitMQ")]),t._v(" "),e("p",[t._v("https://gitee.com/nylg/picture/tree/master/file/Ra bbitMQ-demo")]),t._v(" "),e("p",[t._v("需求：使用简单模式完成消息传递")]),t._v(" "),e("p",[t._v("步骤：")]),t._v(" "),e("ol",[e("li",[t._v("创建工程（生成者、消费者）")]),t._v(" "),e("li",[t._v("分别添加依赖")]),t._v(" "),e("li",[t._v("编写生产者发送消息")]),t._v(" "),e("li",[t._v("编写消费者接收消息")])]),t._v(" "),e("p",[t._v("上述的入门案例中其实使用的是如下的简单模式：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831214931386.png",alt:"image-20210831214931386"}})]),t._v(" "),e("p",[t._v("在上图的模型中，有以下概念：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("P：生产者，也就是要发送消息的程序")])]),t._v(" "),e("li",[e("p",[t._v("C：消费者：消息的接收者，会一直等待消息到来")])]),t._v(" "),e("li",[e("p",[t._v("queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息")])])]),t._v(" "),e("h2",{attrs:{id:"工作模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工作模式"}},[t._v("#")]),t._v(" 工作模式")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831212426101.png",alt:"image-20210831212426101"}})]),t._v(" "),e("p",[t._v("Ra bbitMQ 提供了 6 种工作模式：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("简单模式")]),t._v(" "),e("blockquote",[e("p",[t._v("一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）")])])]),t._v(" "),e("li",[e("p",[t._v("work queues")]),t._v(" "),e("p",[t._v("一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）")])]),t._v(" "),e("li",[e("p",[t._v("Publish/Subscribe 发布与订阅模式")]),t._v(" "),e("blockquote",[e("p",[t._v("需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。")])])]),t._v(" "),e("li",[e("p",[t._v("Routing 路由模式")]),t._v(" "),e("blockquote",[e("p",[t._v("需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。")])])]),t._v(" "),e("li",[e("p",[t._v("Topics 主题模式")]),t._v(" "),e("blockquote",[e("p",[t._v("需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配符方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。")])])]),t._v(" "),e("li",[e("p",[t._v("RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）")])])]),t._v(" "),e("blockquote",[e("p",[t._v("官网对应模式介绍：https://www.Ra bbitMQ.com/getstarted.html")])]),t._v(" "),e("p",[t._v("1.简单模式 HelloWorld")]),t._v(" "),e("h3",{attrs:{id:"work-queues工作队列模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#work-queues工作队列模式"}},[t._v("#")]),t._v(" Work queues工作队列模式")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831215130880.png",alt:"image-20210831215130880"}})]),t._v(" "),e("p",[t._v("**Work Queues：**与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。")]),t._v(" "),e("p",[e("strong",[t._v("应用场景")]),t._v("：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。")]),t._v(" "),e("p",[e("strong",[t._v("代码编写")]),t._v("：Work Queues 与入门程序的简单模式的代码几乎是一样的。可以完全复制，并多复制一个消费者进行多个消费者同时对消费消息的测试。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831215336932.png",alt:"image-20210831215336932"}})]),t._v(" "),e("p",[t._v("总结：")]),t._v(" "),e("ol",[e("li",[t._v("在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是"),e("strong",[t._v("竞争")]),t._v("的关系。")]),t._v(" "),e("li",[t._v("Work Queues对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。例如：短信服务部署多个，只需要有一个节点成功发送即可。")])]),t._v(" "),e("h3",{attrs:{id:"pub-sub订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pub-sub订阅模式"}},[t._v("#")]),t._v(" Pub/Sub订阅模式")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831215558511.png",alt:"image-20210831215558511"}})]),t._v(" "),e("p",[t._v("在订阅模型中，多了一个 "),e("strong",[t._v("Exchange")]),t._v(" 角色，而且过程略有变化：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）")])]),t._v(" "),e("li",[e("p",[t._v("C：消费者，消息的接收者，会一直等待消息到来")])]),t._v(" "),e("li",[e("p",[t._v("Queue：消息队列，接收消息、缓存消息")])]),t._v(" "),e("li",[e("p",[t._v("Exchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Fanout：广播，将消息交给所有绑定到交换机的队列")])]),t._v(" "),e("li",[e("p",[t._v("Direct：定向，把消息交给符合指定routing key 的队列")])]),t._v(" "),e("li",[e("p",[t._v("Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列")])])])])]),t._v(" "),e("blockquote",[e("p",[t._v("Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！")])]),t._v(" "),e("p",[e("strong",[t._v("使用场景")])]),t._v(" "),e("p",[t._v("发布订阅模式因为所有消费者获得相同的消息，所以特别适合“数据提供商与应用商“。")]),t._v(" "),e("p",[t._v("例如:中国气象局提供“天气预报”送入交换机，网易、新浪、百度、搜狐等门户接入通过队列绑定到该交换机，自动获取气象局推送的气象数据。")]),t._v(" "),e("p",[e("strong",[t._v("总结")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。")])]),t._v(" "),e("li",[e("p",[t._v("发布订阅模式与工作队列模式的区别：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机")])]),t._v(" "),e("li",[e("p",[t._v("发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)")])]),t._v(" "),e("li",[e("p",[t._v("发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机")])])])])]),t._v(" "),e("h3",{attrs:{id:"routing-路由模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#routing-路由模式"}},[t._v("#")]),t._v(" Routing "),e("strong",[t._v("路由模式")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）")])]),t._v(" "),e("li",[e("p",[t._v("消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey")])]),t._v(" "),e("li",[e("p",[t._v("Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831220311536.png",alt:"image-20210831220311536"}})]),t._v(" "),e("p",[t._v("图解：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key")])]),t._v(" "),e("li",[e("p",[t._v("X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列")])]),t._v(" "),e("li",[e("p",[t._v("C1：消费者，其所在队列指定了需要 routing key 为 error 的消息")])]),t._v(" "),e("li",[e("p",[t._v("C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息")])])]),t._v(" "),e("p",[e("strong",[t._v("总结")])]),t._v(" "),e("p",[e("strong",[t._v("Routing")]),t._v(" 模式要求队列在绑定交换机时要指定 "),e("strong",[t._v("routing key")]),t._v("，消息会转发到符合 routing key 的队列。")]),t._v(" "),e("h3",{attrs:{id:"topics-通配符模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#topics-通配符模式"}},[t._v("#")]),t._v(" Topics "),e("strong",[t._v("通配符模式")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用"),e("strong",[t._v("通配符")]),t._v("！")])]),t._v(" "),e("li",[e("p",[t._v("Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert")])]),t._v(" "),e("li",[e("p",[t._v("通配符规则：# 匹配一个或多个词，* 匹配不多不少恰好1个词，例如：item.# 能够匹配 item.insert.abc 或者 item.insert，item.* 只能匹配 item.insert")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831220554073.png",alt:"image-20210831220554073"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831220602415.png",alt:"image-20210831220602415"}})]),t._v(" "),e("p",[t._v("图解：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到")])]),t._v(" "),e("li",[e("p",[t._v("黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配")])])]),t._v(" "),e("p",[e("strong",[t._v("总结")])]),t._v(" "),e("p",[t._v("Topic 主题模式可以实现 Pub/Sub 发布与订阅模式和 Routing 路由模式的功能，只是 Topic 在配置routing key 的时候可以使用通配符，显得更加灵活。")]),t._v(" "),e("h2",{attrs:{id:"ra-bbitmq消息确认机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ra-bbitmq消息确认机制"}},[t._v("#")]),t._v(" Ra bbitMQ消息确认机制")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Ra bbitMQ在传递消息的过程中充当了代理人（Broker）的角色，那生产者（Producer）怎样知道消息被正确投递到Broker了呢？")])]),t._v(" "),e("li",[e("p",[t._v("Ra bbitMQ提供了监听器（Listener）来接收消息投递的状态。")])]),t._v(" "),e("li",[e("p",[t._v("消息确认涉及两种状态：Confirm和Return")])])]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("Confirm")]),t._v("：Confirm代表生产者将消息送到Broker时产生的状态，后续会出现两种情况:")]),t._v(" "),e("ul",[e("li",[t._v("ack代表Broker已经将数据接收。")]),t._v(" "),e("li",[t._v("nack代表Broker拒收消息。原因有多种，队列已满，限流，IO异常...")])]),t._v(" "),e("p",[e("strong",[t._v("Return")]),t._v("：Return代表消息被Broker正常接收(ack)后，但Broker没有对应的队列进行投递时产生的状态，消息被退回给生产者。")]),t._v(" "),e("p",[t._v("注意:上面两种状态只代表生产者与Broker之间消息投递的情况。与消费者是否接收/确认消息无关。")])]),t._v(" "),e("h2",{attrs:{id:"高级特性-消息的可靠投递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-消息的可靠投递"}},[t._v("#")]),t._v(" 高级特性：消息的可靠投递")]),t._v(" "),e("p",[t._v("在使用 Ra bbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。Ra bbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("confirm 确认模式")])]),t._v(" "),e("li",[e("p",[t._v("return 退回模式")])])]),t._v(" "),e("p",[t._v("Ra bbitMQ 整个消息投递的路径为：")]),t._v(" "),e("p",[t._v("producer---\x3erabbitmq broker---\x3eexchange---\x3equeue---\x3econsumer")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("消息从 producer 到 exchange 则会返回一个 confirmCallback 。")])]),t._v(" "),e("li",[e("p",[t._v("消息从 exchange--\x3equeue 投递失败则会返回一个 returnCallback 。")])])]),t._v(" "),e("p",[t._v("我们将利用这两个 callback 控制消息的可靠性投递")]),t._v(" "),e("blockquote",[e("ul",[e("li",[e("p",[t._v('设置ConnectionFactory的publisher-confirms="true" 开启 确认模式。')])]),t._v(" "),e("li",[e("p",[t._v("使用rabbitTemplate.setConfirmCallback设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。")])]),t._v(" "),e("li",[e("p",[t._v('设置ConnectionFactory的publisher-returns="true" 开启 退回模式。')])]),t._v(" "),e("li",[e("p",[t._v("使用rabbitTemplate.setReturnCallback设置退回函数，当消息从exchange路由到queue失败后，如果设置了rabbitTemplate.setMandatory(true)参数，则会将消息退回给producer。并执行回调函数returnedMessage。")])])])]),t._v(" "),e("h2",{attrs:{id:"高级特性-consumer-ack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-consumer-ack"}},[t._v("#")]),t._v(" 高级特性：Consumer ACK")]),t._v(" "),e("p",[t._v("ack指Acknowledge，确认。 表示消费端收到消息后的确认方式。")]),t._v(" "),e("p",[t._v("有三种确认方式：")]),t._v(" "),e("ul",[e("li",[t._v('自动确认：acknowledge="none"')]),t._v(" "),e("li",[t._v('手动确认：acknowledge="manual"')]),t._v(" "),e("li",[t._v('根据异常情况确认：acknowledge="auto"，（这种方式使用麻烦，不作讲解）')])]),t._v(" "),e("p",[t._v("其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 Ra bbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。")]),t._v(" "),e("blockquote",[e("ul",[e("li",[e("p",[t._v("在rabbit:listener-container标签中设置acknowledge属性，设置ack方式 none：自动确认，manual：手动确认")])]),t._v(" "),e("li",[e("p",[t._v("如果在消费端没有出现异常，则调用channel.basicAck(deliveryTag,false);方法确认签收消息")])]),t._v(" "),e("li",[e("p",[t._v("如果出现异常，则在catch中调用 basicNack或 basicReject，拒绝消息，让MQ重新发送消息。")])])])]),t._v(" "),e("p",[t._v("消息可靠性总结")]),t._v(" "),e("blockquote",[e("ol",[e("li",[e("p",[t._v("持久化")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("exchange要持久化")])]),t._v(" "),e("li",[e("p",[t._v("queue要持久化")])]),t._v(" "),e("li",[e("p",[t._v("message要持久化")])])])]),t._v(" "),e("li",[e("p",[t._v("生产方确认Confirm")])]),t._v(" "),e("li",[e("p",[t._v("消费方确认Ack")])]),t._v(" "),e("li",[e("p",[t._v("Broker高可用")])])])]),t._v(" "),e("h2",{attrs:{id:"高级特性-消费端限流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-消费端限流"}},[t._v("#")]),t._v(" 高级特性：消费端限流")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831224945321.png",alt:"image-20210831224945321"}})]),t._v(" "),e("p",[t._v("总结：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在"),e("a",{attrs:{href:"rabbit:listener-container"}},[t._v("rabbit:listener-container")]),t._v(" 中配置 prefetch属性设置消费端一次拉取多少消息")])]),t._v(" "),e("li",[e("p",[t._v('消费端的确认模式一定为手动确认。acknowledge="manual"')])])]),t._v(" "),e("h2",{attrs:{id:"高级特性-ttl"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-ttl"}},[t._v("#")]),t._v(" 高级特性：TTL")]),t._v(" "),e("p",[t._v("TTL 全称 Time To Live（存活时间/过期时间）。")]),t._v(" "),e("p",[t._v("当消息到达存活时间后，还没有被消费，会被自动清除。")]),t._v(" "),e("p",[t._v("Ra bbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831225117394.png",alt:"image-20210831225117394"}})]),t._v(" "),e("p",[t._v("总结：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。")])]),t._v(" "),e("li",[e("p",[t._v("设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。")])]),t._v(" "),e("li",[e("p",[t._v("如果两者都进行了设置，以时间短的为准。")])])]),t._v(" "),e("h2",{attrs:{id:"高级特性-死信队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-死信队列"}},[t._v("#")]),t._v(" 高级特性：死信队列")]),t._v(" "),e("p",[t._v("死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831225250877.png",alt:"image-20210831225250877"}})]),t._v(" "),e("p",[e("strong",[t._v("消息成为死信的三种情况：")])]),t._v(" "),e("ol",[e("li",[t._v("队列消息长度到达限制；")]),t._v(" "),e("li",[t._v("消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；")]),t._v(" "),e("li",[t._v("原队列存在消息过期设置，消息到达超时时间未被消费；")])]),t._v(" "),e("p",[e("strong",[t._v("队列绑定死信交换机：")])]),t._v(" "),e("p",[t._v("给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831225357313.png",alt:"image-20210831225357313"}})]),t._v(" "),e("p",[t._v("总结：")]),t._v(" "),e("ol",[e("li",[t._v("死信交换机和死信队列和普通的没有区别")]),t._v(" "),e("li",[t._v("当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列")]),t._v(" "),e("li",[t._v("消息成为死信的三种情况：\n"),e("ul",[e("li",[t._v("队列消息长度到达限制；")]),t._v(" "),e("li",[t._v("消费者拒接消费消息，并且不重回队列；")]),t._v(" "),e("li",[t._v("原队列存在消息过期设置，消息到达超时时间未被消费；")])])])]),t._v(" "),e("h2",{attrs:{id:"高级特性-延迟队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-延迟队列"}},[t._v("#")]),t._v(" 高级特性：延迟队列")]),t._v(" "),e("p",[t._v("延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。")]),t._v(" "),e("p",[t._v("需求：")]),t._v(" "),e("ol",[e("li",[t._v("下单后，30分钟未支付，取消订单，回滚库存。")]),t._v(" "),e("li",[t._v("新用户注册成功7天后，发送短信问候。")])]),t._v(" "),e("p",[t._v("实现方式：")]),t._v(" "),e("ol",[e("li",[t._v("定时器")]),t._v(" "),e("li",[t._v("延迟队列")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831225531743.png",alt:"image-20210831225531743"}})]),t._v(" "),e("p",[t._v("很可惜，在Ra bbitMQ中并未提供延迟队列功能。")]),t._v(" "),e("p",[t._v("但是可以使用：TTL+死信队列 组合实现延迟队列的效果。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831225558357.png",alt:"image-20210831225558357"}})]),t._v(" "),e("p",[t._v("总结：")]),t._v(" "),e("ol",[e("li",[t._v("延迟队列 指消息进入队列后，可以被延迟一定时间，再进行消费")]),t._v(" "),e("li",[t._v("Ra bbitMQ没有提供延迟队列功能，但是可以使用 ： TTL + DLX 来实现延迟队列效果。")])]),t._v(" "),e("h2",{attrs:{id:"高级特性-消息幂等性保障"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级特性-消息幂等性保障"}},[t._v("#")]),t._v(" 高级特性：消息幂等性保障")]),t._v(" "),e("p",[t._v("幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。")]),t._v(" "),e("p",[t._v("在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。")]),t._v(" "),e("p",[e("strong",[t._v("消息幂等性保障-乐观锁机制")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/rabbitmq/image-20210831225812256.png",alt:"image-20210831225812256"}})])])}),[],!1,null,null,null);e.default=_.exports}}]);