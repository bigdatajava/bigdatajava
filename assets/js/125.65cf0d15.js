(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{492:function(n,s,t){"use strict";t.r(s);var a=t(5),r=Object(a.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("p",[n._v("String在方法中的传递方式(调用外部方法给String变量赋值时，未得到预期结果)\n示例：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public class StringTraining {\n　　public static void changeStr(String str){\n　　　　str = "137878";\n　　}\n　　public static void main(String[] args){\n　　　　String a = "b";\n　　　　changeStr(a);\n　　　　System.out.println(a);\n　　}\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("输出仍旧为b")]),n._v(" "),s("p",[n._v("分析：首先栈中存的是堆中对象的地址，因为String对象的特殊性（String有自己的常量池），当遇到常量池中没有的字符串时，String会开辟新的内存空间（生成新对象）。实例中，将a的值（“b”的地址）赋值给了str，从而起初示例中a引用指向“b”，str初始值也是指向“b”；然而当给str重新赋值时，str指向了另一个内存空间（即存储的是新字符串的地址，相当于给str重新赋值了），因此str指向“137878”，对a没影响。")]),n._v(" "),s("p",[n._v("情景：当调用外部方法改变String的值是无法生效的，比如我想用外部方法进行参数校验，当某个String类型参数为空或null时，我给这个参数赋一个默认值，这个赋值动作是无效的，因而当用到该参数时，仍旧会报空指针。")])])}),[],!1,null,null,null);s.default=r.exports}}]);