(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{421:function(e,r,t){"use strict";t.r(r);var o=t(5),p=Object(o.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("ol",[r("li",[e._v("分布式配置中心")]),e._v(" "),r("li",[e._v("分布式注册中心")]),e._v(" "),r("li",[e._v("分布式锁")]),e._v(" "),r("li",[e._v("分布式队列")]),e._v(" "),r("li",[e._v("集群选举")]),e._v(" "),r("li",[e._v("分布式屏障")]),e._v(" "),r("li",[e._v("发布/订阅")])]),e._v(" "),r("h2",{attrs:{id:"zookeeper非公平锁-公平锁-共享锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper非公平锁-公平锁-共享锁"}},[e._v("#")]),e._v(" zookeeper非公平锁/公平锁/共享锁")]),e._v(" "),r("h3",{attrs:{id:"非公平锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非公平锁"}},[e._v("#")]),e._v(" 非公平锁")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/image-20210831124903155.png",alt:"image-20210831124903155"}})]),e._v(" "),r("p",[e._v("如上实现方式在并发问题比较严重的情况下，性能会下降的比较厉害，主要原因是，所有的连接 都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时 收到事件，再次并发竞争，这就是羊群效应。如何避免呢，我们看下面这种方式。")]),e._v(" "),r("h3",{attrs:{id:"公平锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#公平锁"}},[e._v("#")]),e._v(" 公平锁")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/image-20210831124923948.png",alt:"image-20210831124923948"}})]),e._v(" "),r("ol",[r("li",[e._v("请求进来，直接在/lock节点下创建一个临时顺序节点")]),e._v(" "),r("li",[e._v("判断自己是不是lock节点下，最小的节点\n"),r("ul",[r("li",[e._v("是最小的，获得锁")]),e._v(" "),r("li",[e._v("不是，对前面的节点进行监听（watch）")])])]),e._v(" "),r("li",[e._v("获得锁的请求，处理完释放锁，即delete节点，然后后继第一个节点将收到通知，重复第二步判断")])]),e._v(" "),r("blockquote",[r("p",[e._v("幽灵节点问题")])]),e._v(" "),r("blockquote",[r("p",[e._v("/local：容器节点（子节点全部删除后，主节点会自动删除）")]),e._v(" "),r("p",[e._v("/x-000001是临时顺序节点")])]),e._v(" "),r("p",[e._v("如上借助于临时顺序节点，可以避免同时多个节点的并发竞争锁，缓解了服务端压力。这种实现方式所有加锁请求都进行排队加锁，是"),r("strong",[e._v("公平锁")]),e._v("的具体实现。")]),e._v(" "),r("p",[e._v("前面这两种加锁方式有一个共同的特质，就是都是"),r("strong",[e._v("互斥锁")]),e._v("，同一时间只能有一个请求占用，如果是大量的并发上来，性能是会急剧下降的，所有的请求都得加锁，那是不是真的所有的请求都需要加锁呢？答案是否定的，比如如果数据没有进行任何修改的话，是不需要加锁的，但是如果读数据的请求还没读完，这个时候来了一个写请求，怎么办呢？有人已经在读数据了，这个时候是不能写数据的，不然数据就不正确了。直到前面读锁全部释放掉以后，写请求才能执行，所以需要给这个读请求加一个标识（读锁），让写请求知道，这个时候是不能修改数据的。不然数据就不一致了。如果已经有人在写数据了，再来一个请求写数据，也是不允许的，这样也会导致数据的不一致，所以所有的写请求，都需要加一个写锁，是为了避免同时对共享数据进行写操作。")]),e._v(" "),r("p",[e._v("举个例子")]),e._v(" "),r("p",[e._v("1、读写并发不一致")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/42.png",alt:""}})]),e._v(" "),r("p",[e._v("2、双写不一致情况")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/43.png",alt:""}})]),e._v(" "),r("h3",{attrs:{id:"共享锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#共享锁"}},[e._v("#")]),e._v(" 共享锁")]),e._v(" "),r("p",[e._v("Zookeeper 共享锁实现原理")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/44.png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[e._v("#")]),e._v(" 分布式锁")]),e._v(" "),r("p",[r("strong",[e._v("整个Zookeeper就是一个多节点分布式一致性算法的实现，底层采用的实现协议是ZAB。")])]),e._v(" "),r("h3",{attrs:{id:"zab协议介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zab协议介绍"}},[e._v("#")]),e._v(" ZAB协议介绍")]),e._v(" "),r("p",[e._v("ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。")]),e._v(" "),r("p",[e._v("Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper 并没有使用 Paxos ，而是采用了 ZAB 协议，ZAB是Paxos算法的一种简化实现。")]),e._v(" "),r("p",[e._v("ZAB 协议定义："),r("strong",[e._v("ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持")]),e._v(" "),r("strong",[e._v("崩溃恢复")]),e._v(" "),r("strong",[e._v("和")]),e._v(" "),r("strong",[e._v("原子广播")]),e._v(" "),r("strong",[e._v("的协议")]),e._v("。下面我们会重点讲这两个东西。")]),e._v(" "),r("p",[e._v("基于该协议，Zookeeper 实现了一种 主备模式 的系统架构来保持集群中各个副本之间数据一致性。具体如下图所示：")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/80.png",alt:""}})]),e._v(" "),r("p",[e._v("上图显示了 Zookeeper 如何处理集群中的数据。所有客户端写入数据都是写入到Leader节点，然后，由 Leader 复制到Follower节点中，从而保证数据一致性。")]),e._v(" "),r("p",[e._v("那么复制过程又是如何的呢？复制过程类似两阶段提交(2PC)，ZAB 只需要 Follower(含leader自己的ack) 有一半以上返回 Ack 信息就可以执行提交，大大减小了同步阻塞。也提高了可用性。")]),e._v(" "),r("p",[e._v("简单介绍完，开始重点介绍 消息广播 和 崩溃恢复。"),r("strong",[e._v("整个 Zookeeper 就是在这两个模式之间切换。")]),e._v(" 简而言之，当 Leader 服务可以正常使用，就进入消息广播模式，当 Leader 不可用时，则进入崩溃恢复模式。")]),e._v(" "),r("h3",{attrs:{id:"消息广播"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息广播"}},[e._v("#")]),e._v(" 消息广播")]),e._v(" "),r("p",[e._v("ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 "),r("strong",[e._v("两阶段提交过程")]),e._v("。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数(含leader自己)成功响应，则执行 commit 操作。")]),e._v(" "),r("p",[r("strong",[e._v("整个广播流程如下：")])]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/81.png",alt:""}})]),e._v(" "),r("p",[e._v("通过以上步骤，就能够保持集群之间数据的一致性。")]),e._v(" "),r("p",[r("strong",[e._v("还有一些细节：")])]),e._v(" "),r("ol",[r("li",[e._v("Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务ID（ZXID），ZAB 协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理，主要通过消息队列实现。")]),e._v(" "),r("li",[e._v("在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。")]),e._v(" "),r("li",[e._v("zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到客户端的写请求，也会转发到 Leader 服务器进行处理，Follower只能处理读请求。")]),e._v(" "),r("li",[r("strong",[e._v("ZAB协议规定了如果一个事务在一台机器上被处理(commit)成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。")])])]),e._v(" "),r("h3",{attrs:{id:"崩溃恢复"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复"}},[e._v("#")]),e._v(" 崩溃恢复")]),e._v(" "),r("p",[e._v("刚刚我们说消息广播过程中，Leader 崩溃怎么办？还能保证数据一致吗？")]),e._v(" "),r("p",[e._v("实际上，当 Leader 崩溃，即进入我们开头所说的崩溃恢复模式（崩溃即：Leader 失去与过半 Follwer 的联系）。下面来详细讲述。")]),e._v(" "),r("p",[e._v("假设1：Leader 在复制数据给所有 Follwer 之后，还没来得及收到Follower的ack返回就崩溃，怎么办？")]),e._v(" "),r("p",[e._v("假设2：Leader 在收到 ack 并提交了自己，同时发送了部分 commit 出去之后崩溃怎么办？")]),e._v(" "),r("p",[r("strong",[e._v("针对这些问题，ZAB 定义了 2 个原则：")])]),e._v(" "),r("ol",[r("li",[e._v("ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。")]),e._v(" "),r("li",[e._v("ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。")])]),e._v(" "),r("p",[e._v("所以，ZAB 设计了下面这样一个选举算法：")]),e._v(" "),r("p",[r("strong",[e._v("能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。")])]),e._v(" "),r("p",[e._v("针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器 ZXID 最大的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。")]),e._v(" "),r("p",[e._v("而且这么做有一个好处是："),r("strong",[e._v("可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。")])]),e._v(" "),r("p",[r("strong",[e._v("数据同步")])]),e._v(" "),r("p",[e._v("当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。")]),e._v(" "),r("p",[e._v("当 Follwer 服务器成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。")]),e._v(" "),r("p",[e._v("实际上，Leader 服务器处理或丢弃事务都是依赖着 ZXID 的，那么这个 ZXID 如何生成呢？")]),e._v(" "),r("p",[e._v("答：在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。")]),e._v(" "),r("p",[e._v("而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值(leader选举周期)，当一轮新的选举结束后，会对这个值加一，并且事务id又从0开始自增。")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/82.png",alt:""}})]),e._v(" "),r("p",[e._v("高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的 Leader。简化了数据恢复流程。")]),e._v(" "),r("p",[e._v("基于这样的策略：当 Follower 连接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。")]),e._v(" "),r("p",[r("strong",[e._v("ZAB写数据源码流程图")]),e._v("**(务必跟着视频看)**")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/Zookeeper%E5%86%99%E6%95%B0%E6%8D%AEZAB%E5%8D%8F%E8%AE%AE%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.jpg",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"注册中心"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注册中心"}},[e._v("#")]),e._v(" 注册中心")]),e._v(" "),r("p",[r("strong",[e._v("注册中心场景分析：")])]),e._v(" "),r("ol",[r("li",[e._v("在分布式服务体系结构比较简单的场景下，我们的服务可能是这样的")])]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/45.png",alt:""}})]),e._v(" "),r("p",[e._v("现在 Order-Service 需要调用外部服务的 User-Service ,对于外部的服务依赖，我们直接配置在我们的服务配置文件中,在服务调用关系比较简单的场景，是完全OK的。随着服务的扩张，User-Service 可能需要进行集群部署，如下：")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/46.png",alt:""}})]),e._v(" "),r("p",[e._v("如果系统的调用不是很复杂，可以通过配置管理，然后实现一个简单的客户端负载均衡也是OK的，但是随着业务的发展，服务模块进行更加细粒度的划分，业务也变得更加复杂，再使用简单的配置文件管理，将变得难以维护。当然我们可以再前面加一个服务代理，比如nginx做反向代理， 如下")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/47.png",alt:""}})]),e._v(" "),r("p",[e._v("如果我们是如下场景呢？")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/48.png",alt:""}})]),e._v(" "),r("p",[e._v("服务不再是A-B,B-C 那么简单，而是错综复杂的微小服务的调用")]),e._v(" "),r("p",[e._v("这个时候我们可以借助于Zookeeper的基本特性来实现一个注册中心,什么是注册中心，顾名思义，就是让众多的服务，都在Zookeeper中进行注册，啥是注册，注册就是把自己的一些服务信息，比如IP，端口，还有一些更加具体的服务信息，都写到 Zookeeper节点上， 这样有需要的服务就可以直接从zookeeper上面去拿，怎么拿呢？ 这时我们可以定义统一的名称，比如，User-Service, 那所有的"),r("strong",[e._v("用户服务")]),e._v("在"),r("strong",[e._v("启动")]),e._v("的时候，都在User-Service 这个节点下面创建一个子节点（临时节点），这个子节点保持唯一就好，代表了每个服务实例的唯一标识，有依赖"),r("strong",[e._v("用户服务")]),e._v("的比如"),r("strong",[e._v("Order-Service")]),e._v(" 就可以通过"),r("strong",[e._v("User-Service")]),e._v(" 这个父节点，就能获取所有的User-Service 子节点，并且获取所有的子节点信息（IP，端口等信息），拿到子节点的数据后"),r("strong",[e._v("Order-Service")]),e._v("可以对其进行缓存，然后实现一个客户端的负载均衡，同时还可以对这个User-Service 目录进行监听， 这样有新的节点加入，或者退出，"),r("strong",[e._v("Order-Service")]),e._v("都能收到通知，这样"),r("strong",[e._v("Order-Service")]),e._v("重新获取所有子节点，且进行数据更新。这个用户服务的子节点的类型为临时节点。 第一节课有讲过，Zookeeper中临时节点生命周期是和SESSION绑定的，如果SESSION超时了，对应的节点会被删除，被删除时，Zookeeper 会通知对该节点父节点进行监听的客户端, 这样对应的客户端又可以刷新本地缓存了。当有新服务加入时，同样也会通知对应的客户端，刷新本地缓存，要达到这个目标需要客户端重复的注册对父节点的监听。这样就实现了服务的自动注册和自动退出。")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/49.png",alt:""}})]),e._v(" "),r("p",[e._v("Spring Cloud 生态也提供了Zookeeper注册中心的实现，这个项目叫 Spring Cloud Zookeeper 下面我们来进行实战。")]),e._v(" "),r("p",[e._v("项目说明：")]),e._v(" "),r("p",[e._v("为了简化需求，我们以两个服务来进行讲解，实际使用时可以举一反三")]),e._v(" "),r("p",[e._v("​    user-center : 用户服务")]),e._v(" "),r("p",[e._v("product-center: 产品服务")]),e._v(" "),r("p",[e._v("用户调用产品服务，且实现客户端的负载均衡，产品服务自动加入集群，自动退出服务。")]),e._v(" "),r("p",[r("strong",[e._v("项目构建")])]),e._v(" "),r("p",[e._v("\\1. 创建user-center 项目")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/50.png",alt:""}})]),e._v(" "),r("p",[e._v("同样的方式创建一个 product-center")]),e._v(" "),r("p",[e._v("\\2. 解压项目用idea打开，用maven导入项目")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/51.png",alt:""}})]),e._v(" "),r("p",[e._v("同样的方式引入product-center 项目")]),e._v(" "),r("p",[e._v("\\3. 配置zookeeper")]),e._v(" "),r("p",[e._v("user-center 服务：")]),e._v(" "),r("p",[r("strong",[e._v("application.properties")])]),e._v(" "),r("p",[e._v("​                spring.application.name=user-center #zookeeper 连接地址 ，  #如果使用了 spring cloud zookeeper config这个配置应该配置在 bootstrap.yml/bootstrap.properties中 spring.cloud.zookeeper.connect-string=192.168.109.200:2181 #将本服务注册到zookeeper，如果不希望自己被发现可以配置为false, 默认为 true  spring.cloud.zookeeper.discovery.register=true")]),e._v(" "),r("p",[e._v("代码编写：")]),e._v(" "),r("p",[e._v("配置 Resttemplate  支持负载均衡方式")]),e._v(" "),r("p",[e._v("​                @SpringBootApplication public class UserCenterApplication {    public static void main(String[] args) {      SpringApplication.run(UserCenterApplication.class, args);   }          @Bean   @LoadBalanced   public RestTemplate restTemplate(){      return new RestTemplate();   } }")]),e._v(" "),r("p",[e._v("编写测试类：")]),e._v(" "),r("p",[e._v("TestController， Spring Cloud 支持 Feign, Spring RestTemplate,WebClient 以 逻辑名称，替代具体url的形式访问。")]),e._v(" "),r("p",[e._v('​                import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController public class TestController {     @Autowired    private RestTemplate restTemplate;     @GetMapping("/test")    public String test(){        return this.restTemplate.getForObject( "http://product-center/getInfo" ,String.class);    } }')]),e._v(" "),r("p",[e._v("product-center 服务：")]),e._v(" "),r("p",[r("strong",[e._v("application.properties")])]),e._v(" "),r("p",[e._v("​                spring.application.name=user-center #zookeeper 连接地址 spring.cloud.zookeeper.connect-string=192.168.109.200:2181 #将本服务注册到zookeeper spring.cloud.zookeeper.discovery.register=true")]),e._v(" "),r("p",[e._v("主类，接收一个getInfo 请求")]),e._v(" "),r("p",[e._v('​                @SpringBootApplication @RestController public class ProductCenterApplication {    @Value("${server.port}")   private String port;    @Value( "${spring.application.name}" )   private String name;    @GetMapping("/getInfo")   public String getServerPortAndName(){       return  this.name +" : "+ this.port;   }   public static void main(String[] args) {      SpringApplication.run(ProductCenterApplication.class, args);   } }')]),e._v(" "),r("p",[e._v("启动两个product-center 实例")]),e._v(" "),r("p",[e._v("通过idea 配置，启动多个实例，用端口区分不同的应用")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/52.png",alt:""}})]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/53.png",alt:""}})]),e._v(" "),r("p",[e._v("启动一个user-center 实例，默认8080端口")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/54.png",alt:""}})]),e._v(" "),r("p",[e._v("启动服务 ：访问 http://localhost:8080/test")]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/55.png",alt:""}})]),e._v(" "),r("p",[e._v("​    "),r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/56.png",alt:""}})]),e._v(" "),r("p",[e._v("已经实现了，服务端的自动发现和客户端负载均衡。")]),e._v(" "),r("p",[e._v("停掉product-center: 10002，再次访问")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/57.png",alt:""}})]),e._v(" "),r("p",[e._v("一定的超时时间过去之后，product-center: 10002 会从zookeeper中剔除，zookeeper会通知客户端，进行本地缓存刷新，再次访问， 已经实现了失效节点的自动退出。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/58.png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"leader选举在分布式场景中的应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#leader选举在分布式场景中的应用"}},[e._v("#")]),e._v(" Leader选举在分布式场景中的应用")]),e._v(" "),r("p",[r("strong",[e._v("启动或leader宕机选举leader流程")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/75.png",alt:""}})]),e._v(" "),r("p",[r("strong",[e._v("leader选举多层队列架构")])]),e._v(" "),r("p",[e._v("整个zookeeper选举底层可以分为选举应用层和消息传输层，应用层有自己的队列统一接收和发送选票，传输层也设计了自己的队列，但是按发送的机器分了队列，避免给每台机器发送消息时相互影响，比如某台机器如果出问题发送不成功则不会影响对正常机器的消息发送。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/76.jpg",alt:""}})]),e._v(" "),r("p",[r("strong",[e._v("Leader选举源码流程图")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://404500.oss-cn-beijing.aliyuncs.com/picture/zookeeper/Leader%E9%80%89%E4%B8%BE%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.jpg",alt:""}})])])}),[],!1,null,null,null);r.default=p.exports}}]);