<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Tomcat | wen chao</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3129839_xft6cqs5gc.css">
    <meta name="description" content="架构进阶之路...">
    <meta name="keywords" content="全栈博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,js,ES6,TypeScript,vue">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.237ce36e.css" as="style"><link rel="preload" href="/assets/js/app.b2807c2b.js" as="script"><link rel="preload" href="/assets/js/2.eeaab5de.js" as="script"><link rel="preload" href="/assets/js/193.415828fe.js" as="script"><link rel="prefetch" href="/assets/js/10.30d760c8.js"><link rel="prefetch" href="/assets/js/100.d2a91f05.js"><link rel="prefetch" href="/assets/js/101.aa15113f.js"><link rel="prefetch" href="/assets/js/102.303aae62.js"><link rel="prefetch" href="/assets/js/103.39dbd83e.js"><link rel="prefetch" href="/assets/js/104.30434bc2.js"><link rel="prefetch" href="/assets/js/105.68d90558.js"><link rel="prefetch" href="/assets/js/106.2a47de1c.js"><link rel="prefetch" href="/assets/js/107.6c92802c.js"><link rel="prefetch" href="/assets/js/108.1a019470.js"><link rel="prefetch" href="/assets/js/109.f2cc4655.js"><link rel="prefetch" href="/assets/js/11.8c97a85c.js"><link rel="prefetch" href="/assets/js/110.8630d06d.js"><link rel="prefetch" href="/assets/js/111.fdf10f1a.js"><link rel="prefetch" href="/assets/js/112.ea841a58.js"><link rel="prefetch" href="/assets/js/113.bd8e761d.js"><link rel="prefetch" href="/assets/js/114.63ed667a.js"><link rel="prefetch" href="/assets/js/115.909a8353.js"><link rel="prefetch" href="/assets/js/116.62dab6c0.js"><link rel="prefetch" href="/assets/js/117.d0ef1d76.js"><link rel="prefetch" href="/assets/js/118.39e6e925.js"><link rel="prefetch" href="/assets/js/119.e0265f93.js"><link rel="prefetch" href="/assets/js/12.156b3963.js"><link rel="prefetch" href="/assets/js/120.4be98e6e.js"><link rel="prefetch" href="/assets/js/121.518d8dd5.js"><link rel="prefetch" href="/assets/js/122.477dd94b.js"><link rel="prefetch" href="/assets/js/123.d6065aca.js"><link rel="prefetch" href="/assets/js/124.c6f965c7.js"><link rel="prefetch" href="/assets/js/125.3ee79c35.js"><link rel="prefetch" href="/assets/js/126.bcc69ad9.js"><link rel="prefetch" href="/assets/js/127.8f3ce1ac.js"><link rel="prefetch" href="/assets/js/128.03c90841.js"><link rel="prefetch" href="/assets/js/129.ab248cd9.js"><link rel="prefetch" href="/assets/js/13.c67aac42.js"><link rel="prefetch" href="/assets/js/130.dd64983e.js"><link rel="prefetch" href="/assets/js/131.6ffe6940.js"><link rel="prefetch" href="/assets/js/132.2a8fed26.js"><link rel="prefetch" href="/assets/js/133.6a7673eb.js"><link rel="prefetch" href="/assets/js/134.c00b7bf2.js"><link rel="prefetch" href="/assets/js/135.59d75ce6.js"><link rel="prefetch" href="/assets/js/136.bcd27d57.js"><link rel="prefetch" href="/assets/js/137.75dd3384.js"><link rel="prefetch" href="/assets/js/138.a2ababbf.js"><link rel="prefetch" href="/assets/js/139.6aa75eaa.js"><link rel="prefetch" href="/assets/js/14.8ab9a27a.js"><link rel="prefetch" href="/assets/js/140.58295019.js"><link rel="prefetch" href="/assets/js/141.8d05c3a5.js"><link rel="prefetch" href="/assets/js/142.18498abf.js"><link rel="prefetch" href="/assets/js/143.20c6bdde.js"><link rel="prefetch" href="/assets/js/144.ac94f8ff.js"><link rel="prefetch" href="/assets/js/145.e135dd8a.js"><link rel="prefetch" href="/assets/js/146.13a537e3.js"><link rel="prefetch" href="/assets/js/147.016b19e9.js"><link rel="prefetch" href="/assets/js/148.d3a909f2.js"><link rel="prefetch" href="/assets/js/149.90d05716.js"><link rel="prefetch" href="/assets/js/15.2b8ce9c5.js"><link rel="prefetch" href="/assets/js/150.e61c5f29.js"><link rel="prefetch" href="/assets/js/151.c81aa646.js"><link rel="prefetch" href="/assets/js/152.82944cc0.js"><link rel="prefetch" href="/assets/js/153.410a3789.js"><link rel="prefetch" href="/assets/js/154.cc1235ef.js"><link rel="prefetch" href="/assets/js/155.1e7fae81.js"><link rel="prefetch" href="/assets/js/156.cfaa0244.js"><link rel="prefetch" href="/assets/js/157.47981f53.js"><link rel="prefetch" href="/assets/js/158.e9c295a1.js"><link rel="prefetch" href="/assets/js/159.50ba3574.js"><link rel="prefetch" href="/assets/js/16.a8b0b084.js"><link rel="prefetch" href="/assets/js/160.5845ca9d.js"><link rel="prefetch" href="/assets/js/161.0e97694f.js"><link rel="prefetch" href="/assets/js/162.3c77226a.js"><link rel="prefetch" href="/assets/js/163.17c9ec79.js"><link rel="prefetch" href="/assets/js/164.7736f87d.js"><link rel="prefetch" href="/assets/js/165.ff7b4f9e.js"><link rel="prefetch" href="/assets/js/166.6956307c.js"><link rel="prefetch" href="/assets/js/167.366611f7.js"><link rel="prefetch" href="/assets/js/168.57345d6b.js"><link rel="prefetch" href="/assets/js/169.25420ee7.js"><link rel="prefetch" href="/assets/js/17.68e41786.js"><link rel="prefetch" href="/assets/js/170.bedd4eac.js"><link rel="prefetch" href="/assets/js/171.374570cf.js"><link rel="prefetch" href="/assets/js/172.2f8bf4a8.js"><link rel="prefetch" href="/assets/js/173.42ea0d36.js"><link rel="prefetch" href="/assets/js/174.0ccfd7c6.js"><link rel="prefetch" href="/assets/js/175.7ab333d2.js"><link rel="prefetch" href="/assets/js/176.c7266816.js"><link rel="prefetch" href="/assets/js/177.d0a95fb6.js"><link rel="prefetch" href="/assets/js/178.2bb652ad.js"><link rel="prefetch" href="/assets/js/179.a8eab386.js"><link rel="prefetch" href="/assets/js/18.8e0d47a1.js"><link rel="prefetch" href="/assets/js/180.9fd22be7.js"><link rel="prefetch" href="/assets/js/181.5d5358d4.js"><link rel="prefetch" href="/assets/js/182.af7d36e2.js"><link rel="prefetch" href="/assets/js/183.dddc555d.js"><link rel="prefetch" href="/assets/js/184.a3396baf.js"><link rel="prefetch" href="/assets/js/185.2f7da675.js"><link rel="prefetch" href="/assets/js/186.92639766.js"><link rel="prefetch" href="/assets/js/187.711debd8.js"><link rel="prefetch" href="/assets/js/188.149256e6.js"><link rel="prefetch" href="/assets/js/189.c118aa93.js"><link rel="prefetch" href="/assets/js/19.770d847c.js"><link rel="prefetch" href="/assets/js/190.4d85ee4e.js"><link rel="prefetch" href="/assets/js/191.ff095a9a.js"><link rel="prefetch" href="/assets/js/192.4b5fe55c.js"><link rel="prefetch" href="/assets/js/194.ce801921.js"><link rel="prefetch" href="/assets/js/195.c668b288.js"><link rel="prefetch" href="/assets/js/196.8825af00.js"><link rel="prefetch" href="/assets/js/197.d09dcd8b.js"><link rel="prefetch" href="/assets/js/198.396382cf.js"><link rel="prefetch" href="/assets/js/199.facc6630.js"><link rel="prefetch" href="/assets/js/20.97979961.js"><link rel="prefetch" href="/assets/js/200.db1ff45e.js"><link rel="prefetch" href="/assets/js/201.ab79fbd5.js"><link rel="prefetch" href="/assets/js/202.46e8525c.js"><link rel="prefetch" href="/assets/js/203.2cc13ae9.js"><link rel="prefetch" href="/assets/js/204.3c8a5bcd.js"><link rel="prefetch" href="/assets/js/205.3d0d8394.js"><link rel="prefetch" href="/assets/js/206.261623f6.js"><link rel="prefetch" href="/assets/js/207.6260c0aa.js"><link rel="prefetch" href="/assets/js/208.0fd63045.js"><link rel="prefetch" href="/assets/js/209.e5eaeeca.js"><link rel="prefetch" href="/assets/js/21.e6565c56.js"><link rel="prefetch" href="/assets/js/210.bccc650e.js"><link rel="prefetch" href="/assets/js/211.c238d796.js"><link rel="prefetch" href="/assets/js/212.dd4703ab.js"><link rel="prefetch" href="/assets/js/213.110becf0.js"><link rel="prefetch" href="/assets/js/214.a90d9da2.js"><link rel="prefetch" href="/assets/js/215.81872845.js"><link rel="prefetch" href="/assets/js/216.2ae9609f.js"><link rel="prefetch" href="/assets/js/217.567657f9.js"><link rel="prefetch" href="/assets/js/218.bc570e81.js"><link rel="prefetch" href="/assets/js/219.32a64945.js"><link rel="prefetch" href="/assets/js/22.92562bc3.js"><link rel="prefetch" href="/assets/js/220.d1605ea9.js"><link rel="prefetch" href="/assets/js/221.c1483dee.js"><link rel="prefetch" href="/assets/js/222.188d3bb6.js"><link rel="prefetch" href="/assets/js/223.b4d7fc4a.js"><link rel="prefetch" href="/assets/js/224.5495522d.js"><link rel="prefetch" href="/assets/js/225.ea320f20.js"><link rel="prefetch" href="/assets/js/226.1f245007.js"><link rel="prefetch" href="/assets/js/227.280e3176.js"><link rel="prefetch" href="/assets/js/228.7ea12e2e.js"><link rel="prefetch" href="/assets/js/229.0697746f.js"><link rel="prefetch" href="/assets/js/23.4b595789.js"><link rel="prefetch" href="/assets/js/230.8efdd773.js"><link rel="prefetch" href="/assets/js/231.44bfbfb5.js"><link rel="prefetch" href="/assets/js/232.24dc2667.js"><link rel="prefetch" href="/assets/js/233.6c77b12b.js"><link rel="prefetch" href="/assets/js/234.1ea57e5c.js"><link rel="prefetch" href="/assets/js/235.efb990b9.js"><link rel="prefetch" href="/assets/js/236.2e8820ed.js"><link rel="prefetch" href="/assets/js/237.b108feed.js"><link rel="prefetch" href="/assets/js/238.22baaff8.js"><link rel="prefetch" href="/assets/js/239.ac2c0eba.js"><link rel="prefetch" href="/assets/js/24.b1f29ab1.js"><link rel="prefetch" href="/assets/js/240.1f419e38.js"><link rel="prefetch" href="/assets/js/241.e23fbc50.js"><link rel="prefetch" href="/assets/js/242.83b3226c.js"><link rel="prefetch" href="/assets/js/243.1ce8a9be.js"><link rel="prefetch" href="/assets/js/244.d7c93bdb.js"><link rel="prefetch" href="/assets/js/245.a1b402c0.js"><link rel="prefetch" href="/assets/js/246.7eeb5e18.js"><link rel="prefetch" href="/assets/js/247.b2c0ab4a.js"><link rel="prefetch" href="/assets/js/248.5b2dd7ed.js"><link rel="prefetch" href="/assets/js/249.6278d6f1.js"><link rel="prefetch" href="/assets/js/25.748022ff.js"><link rel="prefetch" href="/assets/js/250.e3114578.js"><link rel="prefetch" href="/assets/js/251.1f576677.js"><link rel="prefetch" href="/assets/js/252.7e83dd55.js"><link rel="prefetch" href="/assets/js/253.ab219365.js"><link rel="prefetch" href="/assets/js/254.31655221.js"><link rel="prefetch" href="/assets/js/255.402ba0fd.js"><link rel="prefetch" href="/assets/js/256.2f1f131a.js"><link rel="prefetch" href="/assets/js/257.cd0dac87.js"><link rel="prefetch" href="/assets/js/258.5e84f5d0.js"><link rel="prefetch" href="/assets/js/259.72cf210e.js"><link rel="prefetch" href="/assets/js/26.d566b8b1.js"><link rel="prefetch" href="/assets/js/260.ddfd8bc7.js"><link rel="prefetch" href="/assets/js/261.b074e8b6.js"><link rel="prefetch" href="/assets/js/262.e0b94776.js"><link rel="prefetch" href="/assets/js/263.2e66950f.js"><link rel="prefetch" href="/assets/js/264.f3ac339f.js"><link rel="prefetch" href="/assets/js/265.384c189b.js"><link rel="prefetch" href="/assets/js/266.635a72af.js"><link rel="prefetch" href="/assets/js/267.c9ede946.js"><link rel="prefetch" href="/assets/js/268.9ec888f5.js"><link rel="prefetch" href="/assets/js/269.2a81258c.js"><link rel="prefetch" href="/assets/js/27.3085f660.js"><link rel="prefetch" href="/assets/js/270.973f0998.js"><link rel="prefetch" href="/assets/js/271.de24bbf3.js"><link rel="prefetch" href="/assets/js/272.68e83c3c.js"><link rel="prefetch" href="/assets/js/273.d740150b.js"><link rel="prefetch" href="/assets/js/274.dc1b1f0c.js"><link rel="prefetch" href="/assets/js/275.cf028a33.js"><link rel="prefetch" href="/assets/js/276.351dbc96.js"><link rel="prefetch" href="/assets/js/277.6a9f5699.js"><link rel="prefetch" href="/assets/js/278.0c28ac6f.js"><link rel="prefetch" href="/assets/js/279.b14576ac.js"><link rel="prefetch" href="/assets/js/28.47957820.js"><link rel="prefetch" href="/assets/js/280.906a73b1.js"><link rel="prefetch" href="/assets/js/281.4173499d.js"><link rel="prefetch" href="/assets/js/282.43873aa6.js"><link rel="prefetch" href="/assets/js/283.2a3d0552.js"><link rel="prefetch" href="/assets/js/284.2c7aa3fb.js"><link rel="prefetch" href="/assets/js/285.a62f9799.js"><link rel="prefetch" href="/assets/js/286.2f0b6532.js"><link rel="prefetch" href="/assets/js/287.d770d01f.js"><link rel="prefetch" href="/assets/js/288.97207297.js"><link rel="prefetch" href="/assets/js/289.ddf5a46c.js"><link rel="prefetch" href="/assets/js/29.716c8a52.js"><link rel="prefetch" href="/assets/js/290.9f1b4436.js"><link rel="prefetch" href="/assets/js/291.885ac485.js"><link rel="prefetch" href="/assets/js/292.b1fe886b.js"><link rel="prefetch" href="/assets/js/293.f597359f.js"><link rel="prefetch" href="/assets/js/294.f559040e.js"><link rel="prefetch" href="/assets/js/295.ef66e1a4.js"><link rel="prefetch" href="/assets/js/296.47009685.js"><link rel="prefetch" href="/assets/js/297.fb7d20ba.js"><link rel="prefetch" href="/assets/js/298.cb1631f8.js"><link rel="prefetch" href="/assets/js/299.25f28097.js"><link rel="prefetch" href="/assets/js/3.9c10c990.js"><link rel="prefetch" href="/assets/js/30.b35b7ad0.js"><link rel="prefetch" href="/assets/js/300.ab5c587e.js"><link rel="prefetch" href="/assets/js/301.544c6982.js"><link rel="prefetch" href="/assets/js/302.70396486.js"><link rel="prefetch" href="/assets/js/303.fa1f3a02.js"><link rel="prefetch" href="/assets/js/304.c344682e.js"><link rel="prefetch" href="/assets/js/305.a0620b1d.js"><link rel="prefetch" href="/assets/js/306.8cb43e28.js"><link rel="prefetch" href="/assets/js/307.ee4d9e2d.js"><link rel="prefetch" href="/assets/js/308.bb04656d.js"><link rel="prefetch" href="/assets/js/309.b3e3c0be.js"><link rel="prefetch" href="/assets/js/31.af0fa05e.js"><link rel="prefetch" href="/assets/js/310.162df0c7.js"><link rel="prefetch" href="/assets/js/311.1a5e341e.js"><link rel="prefetch" href="/assets/js/312.9fe4ed85.js"><link rel="prefetch" href="/assets/js/313.e187b781.js"><link rel="prefetch" href="/assets/js/314.c832b372.js"><link rel="prefetch" href="/assets/js/315.66b7260d.js"><link rel="prefetch" href="/assets/js/316.074c1e65.js"><link rel="prefetch" href="/assets/js/317.9210b762.js"><link rel="prefetch" href="/assets/js/318.50ac3392.js"><link rel="prefetch" href="/assets/js/319.996a4c1b.js"><link rel="prefetch" href="/assets/js/32.81b4ee4b.js"><link rel="prefetch" href="/assets/js/320.661c3aa7.js"><link rel="prefetch" href="/assets/js/321.91d065c2.js"><link rel="prefetch" href="/assets/js/322.21d177e9.js"><link rel="prefetch" href="/assets/js/323.c240199c.js"><link rel="prefetch" href="/assets/js/324.fc71e18c.js"><link rel="prefetch" href="/assets/js/325.d441ab5e.js"><link rel="prefetch" href="/assets/js/326.6065a9e1.js"><link rel="prefetch" href="/assets/js/327.b68a9e0f.js"><link rel="prefetch" href="/assets/js/328.082fa547.js"><link rel="prefetch" href="/assets/js/329.17abf0b7.js"><link rel="prefetch" href="/assets/js/33.c41edd68.js"><link rel="prefetch" href="/assets/js/330.076712a3.js"><link rel="prefetch" href="/assets/js/331.b883690e.js"><link rel="prefetch" href="/assets/js/332.a942e6bd.js"><link rel="prefetch" href="/assets/js/333.e193acf6.js"><link rel="prefetch" href="/assets/js/334.5721c074.js"><link rel="prefetch" href="/assets/js/335.b759f5ec.js"><link rel="prefetch" href="/assets/js/336.8f786a4b.js"><link rel="prefetch" href="/assets/js/337.8ef80b90.js"><link rel="prefetch" href="/assets/js/338.8c63fda7.js"><link rel="prefetch" href="/assets/js/339.3df2ba0b.js"><link rel="prefetch" href="/assets/js/34.e166f3d5.js"><link rel="prefetch" href="/assets/js/340.e54bd836.js"><link rel="prefetch" href="/assets/js/341.1de3160e.js"><link rel="prefetch" href="/assets/js/342.52f64508.js"><link rel="prefetch" href="/assets/js/343.f56c914e.js"><link rel="prefetch" href="/assets/js/344.63033532.js"><link rel="prefetch" href="/assets/js/345.b23610d1.js"><link rel="prefetch" href="/assets/js/346.2c817177.js"><link rel="prefetch" href="/assets/js/347.bb20d78f.js"><link rel="prefetch" href="/assets/js/348.bba2b968.js"><link rel="prefetch" href="/assets/js/349.620d4fde.js"><link rel="prefetch" href="/assets/js/35.827d2ea3.js"><link rel="prefetch" href="/assets/js/350.a24a894c.js"><link rel="prefetch" href="/assets/js/351.9fc8ae8f.js"><link rel="prefetch" href="/assets/js/352.9229b958.js"><link rel="prefetch" href="/assets/js/353.ffe6628c.js"><link rel="prefetch" href="/assets/js/354.4f883a51.js"><link rel="prefetch" href="/assets/js/355.3232e481.js"><link rel="prefetch" href="/assets/js/356.52bb9172.js"><link rel="prefetch" href="/assets/js/357.4ee29887.js"><link rel="prefetch" href="/assets/js/358.22886190.js"><link rel="prefetch" href="/assets/js/359.1f40fcc5.js"><link rel="prefetch" href="/assets/js/36.7c80731a.js"><link rel="prefetch" href="/assets/js/360.630b9c12.js"><link rel="prefetch" href="/assets/js/37.6608ea0a.js"><link rel="prefetch" href="/assets/js/38.4c69b602.js"><link rel="prefetch" href="/assets/js/39.19f940a6.js"><link rel="prefetch" href="/assets/js/4.55a001d1.js"><link rel="prefetch" href="/assets/js/40.d3257c4f.js"><link rel="prefetch" href="/assets/js/41.89db1eaf.js"><link rel="prefetch" href="/assets/js/42.4a12d693.js"><link rel="prefetch" href="/assets/js/43.cbe3ed47.js"><link rel="prefetch" href="/assets/js/44.61c79193.js"><link rel="prefetch" href="/assets/js/45.ce5ed428.js"><link rel="prefetch" href="/assets/js/46.eea0f2fa.js"><link rel="prefetch" href="/assets/js/47.f3bd04d8.js"><link rel="prefetch" href="/assets/js/48.ed81abeb.js"><link rel="prefetch" href="/assets/js/49.978d3cae.js"><link rel="prefetch" href="/assets/js/5.fe551af2.js"><link rel="prefetch" href="/assets/js/50.e21176fc.js"><link rel="prefetch" href="/assets/js/51.2f5a0327.js"><link rel="prefetch" href="/assets/js/52.125f820a.js"><link rel="prefetch" href="/assets/js/53.4a1c114d.js"><link rel="prefetch" href="/assets/js/54.dfe3253b.js"><link rel="prefetch" href="/assets/js/55.5959dcbb.js"><link rel="prefetch" href="/assets/js/56.9d18670e.js"><link rel="prefetch" href="/assets/js/57.c238fb54.js"><link rel="prefetch" href="/assets/js/58.e221eedb.js"><link rel="prefetch" href="/assets/js/59.f628533d.js"><link rel="prefetch" href="/assets/js/6.4670d323.js"><link rel="prefetch" href="/assets/js/60.919ac5be.js"><link rel="prefetch" href="/assets/js/61.3a63b17e.js"><link rel="prefetch" href="/assets/js/62.e61011ad.js"><link rel="prefetch" href="/assets/js/63.55200ef4.js"><link rel="prefetch" href="/assets/js/64.7c19f83d.js"><link rel="prefetch" href="/assets/js/65.833da817.js"><link rel="prefetch" href="/assets/js/66.13f4f83f.js"><link rel="prefetch" href="/assets/js/67.0c77e799.js"><link rel="prefetch" href="/assets/js/68.cc0e543d.js"><link rel="prefetch" href="/assets/js/69.555bef08.js"><link rel="prefetch" href="/assets/js/7.90cda232.js"><link rel="prefetch" href="/assets/js/70.5d2ec40f.js"><link rel="prefetch" href="/assets/js/71.81f1af4b.js"><link rel="prefetch" href="/assets/js/72.8a66936f.js"><link rel="prefetch" href="/assets/js/73.2655fba2.js"><link rel="prefetch" href="/assets/js/74.ba0b3153.js"><link rel="prefetch" href="/assets/js/75.536955ba.js"><link rel="prefetch" href="/assets/js/76.3a946a81.js"><link rel="prefetch" href="/assets/js/77.9b243f6c.js"><link rel="prefetch" href="/assets/js/78.f580a907.js"><link rel="prefetch" href="/assets/js/79.38cbcc11.js"><link rel="prefetch" href="/assets/js/8.9cebf18a.js"><link rel="prefetch" href="/assets/js/80.e82012e8.js"><link rel="prefetch" href="/assets/js/81.73c65f97.js"><link rel="prefetch" href="/assets/js/82.ddfa06dd.js"><link rel="prefetch" href="/assets/js/83.b75fcea2.js"><link rel="prefetch" href="/assets/js/84.5e0efc6d.js"><link rel="prefetch" href="/assets/js/85.3a495ae2.js"><link rel="prefetch" href="/assets/js/86.1ebe8967.js"><link rel="prefetch" href="/assets/js/87.cd673062.js"><link rel="prefetch" href="/assets/js/88.f50e4960.js"><link rel="prefetch" href="/assets/js/89.06660ffb.js"><link rel="prefetch" href="/assets/js/9.04fce59d.js"><link rel="prefetch" href="/assets/js/90.aa61aeaf.js"><link rel="prefetch" href="/assets/js/91.865e8535.js"><link rel="prefetch" href="/assets/js/92.fd2d2a62.js"><link rel="prefetch" href="/assets/js/93.b185de83.js"><link rel="prefetch" href="/assets/js/94.f5290c38.js"><link rel="prefetch" href="/assets/js/95.be5b7fed.js"><link rel="prefetch" href="/assets/js/96.d442acd0.js"><link rel="prefetch" href="/assets/js/97.2f9b0746.js"><link rel="prefetch" href="/assets/js/98.3bba4945.js"><link rel="prefetch" href="/assets/js/99.cd82a6ed.js">
    <link rel="stylesheet" href="/assets/css/0.styles.237ce36e.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="wen chao" class="logo"> <span class="site-name can-hide">wen chao</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Algorithm" class="dropdown-title"><a href="/Algorithm/" class="link-title">Algorithm</a> <span class="title" style="display:none;">Algorithm</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d8e764/" class="nav-link">Theory</a></li><li class="dropdown-item"><!----> <a href="/pages/81a4bd/" class="nav-link">LeetCode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><a href="/Spring/" class="link-title">Spring</a> <span class="title" style="display:none;">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/373439/" class="nav-link">Spring</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Technology" class="dropdown-title"><a href="/Technology/" class="link-title">Technology</a> <span class="title" style="display:none;">Technology</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/3b6841/" class="nav-link">DB</a></li><li class="dropdown-item"><!----> <a href="/pages/d7857e/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b89362/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/ec8b81/" class="nav-link">MongoDB</a></li><li class="dropdown-item"><!----> <a href="/pages/4e3ff1/" class="nav-link">Zookeeper</a></li><li class="dropdown-item"><!----> <a href="/pages/a75fef/" class="nav-link">MQ</a></li><li class="dropdown-item"><!----> <a href="/pages/b194d7/" class="nav-link">Dubbo</a></li><li class="dropdown-item"><!----> <a href="/pages/371f2f/" class="nav-link">ElasticSearch</a></li><li class="dropdown-item"><!----> <a href="/pages/027aa3/" class="nav-link">Workflow</a></li><li class="dropdown-item"><!----> <a href="/pages/73ab4b/" class="nav-link">OAuth2</a></li><li class="dropdown-item"><!----> <a href="/pages/d7a38a/" class="nav-link">JPA</a></li><li class="dropdown-item"><!----> <a href="/pages/eb5dc1/" class="nav-link">Liquibase</a></li><li class="dropdown-item"><!----> <a href="/pages/e54277/" class="nav-link">Lombok</a></li><li class="dropdown-item"><!----> <a href="/pages/62e4f6/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/13c836/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/pages/b50b3d/" class="nav-link">Mini Program</a></li><li class="dropdown-item"><!----> <a href="/pages/09d3b8/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/pages/a526c7/" class="nav-link">Log</a></li><li class="dropdown-item"><!----> <a href="/pages/59cf4f/" class="nav-link">JDK</a></li><li class="dropdown-item"><!----> <a href="/pages/d50dab/" class="nav-link">Thymeleaf</a></li><li class="dropdown-item"><!----> <a href="/pages/97abaa/" class="nav-link">Maven</a></li><li class="dropdown-item"><!----> <a href="/pages/7879f1/" class="nav-link">Mybatis</a></li><li class="dropdown-item"><!----> <a href="/pages/745b7c/" class="nav-link">Network</a></li><li class="dropdown-item"><!----> <a href="/pages/274dac/" class="nav-link">Raspberrypi</a></li><li class="dropdown-item"><!----> <a href="/pages/87c097/" class="nav-link">Node</a></li><li class="dropdown-item"><!----> <a href="/pages/927664/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/2c3f19/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Other" class="dropdown-title"><a href="/Other/" class="link-title">Other</a> <span class="title" style="display:none;">Other</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/fea344/" class="nav-link">Book</a></li><li class="dropdown-item"><!----> <a href="/pages/d62f72/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/f3d338/" class="nav-link">问题</a></li><li class="dropdown-item"><!----> <a href="/pages/ff202b/" class="nav-link">友链</a></li><li class="dropdown-item"><!----> <a href="/pages/2b746e/" class="nav-link">证券</a></li></ul></div></div><div class="nav-item"><a href="/About/" class="nav-link">About</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Index" class="dropdown-title"><a href="/archives/" class="link-title">Index</a> <span class="title" style="display:none;">Index</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/touxiang-lanse.png"> <div class="blogger-info"><h3>wen chao</h3> <span>持之以恒做正确有价值的事!</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Algorithm" class="dropdown-title"><a href="/Algorithm/" class="link-title">Algorithm</a> <span class="title" style="display:none;">Algorithm</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d8e764/" class="nav-link">Theory</a></li><li class="dropdown-item"><!----> <a href="/pages/81a4bd/" class="nav-link">LeetCode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><a href="/Spring/" class="link-title">Spring</a> <span class="title" style="display:none;">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/373439/" class="nav-link">Spring</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Technology" class="dropdown-title"><a href="/Technology/" class="link-title">Technology</a> <span class="title" style="display:none;">Technology</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/3b6841/" class="nav-link">DB</a></li><li class="dropdown-item"><!----> <a href="/pages/d7857e/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b89362/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/ec8b81/" class="nav-link">MongoDB</a></li><li class="dropdown-item"><!----> <a href="/pages/4e3ff1/" class="nav-link">Zookeeper</a></li><li class="dropdown-item"><!----> <a href="/pages/a75fef/" class="nav-link">MQ</a></li><li class="dropdown-item"><!----> <a href="/pages/b194d7/" class="nav-link">Dubbo</a></li><li class="dropdown-item"><!----> <a href="/pages/371f2f/" class="nav-link">ElasticSearch</a></li><li class="dropdown-item"><!----> <a href="/pages/027aa3/" class="nav-link">Workflow</a></li><li class="dropdown-item"><!----> <a href="/pages/73ab4b/" class="nav-link">OAuth2</a></li><li class="dropdown-item"><!----> <a href="/pages/d7a38a/" class="nav-link">JPA</a></li><li class="dropdown-item"><!----> <a href="/pages/eb5dc1/" class="nav-link">Liquibase</a></li><li class="dropdown-item"><!----> <a href="/pages/e54277/" class="nav-link">Lombok</a></li><li class="dropdown-item"><!----> <a href="/pages/62e4f6/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/13c836/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/pages/b50b3d/" class="nav-link">Mini Program</a></li><li class="dropdown-item"><!----> <a href="/pages/09d3b8/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/pages/a526c7/" class="nav-link">Log</a></li><li class="dropdown-item"><!----> <a href="/pages/59cf4f/" class="nav-link">JDK</a></li><li class="dropdown-item"><!----> <a href="/pages/d50dab/" class="nav-link">Thymeleaf</a></li><li class="dropdown-item"><!----> <a href="/pages/97abaa/" class="nav-link">Maven</a></li><li class="dropdown-item"><!----> <a href="/pages/7879f1/" class="nav-link">Mybatis</a></li><li class="dropdown-item"><!----> <a href="/pages/745b7c/" class="nav-link">Network</a></li><li class="dropdown-item"><!----> <a href="/pages/274dac/" class="nav-link">Raspberrypi</a></li><li class="dropdown-item"><!----> <a href="/pages/87c097/" class="nav-link">Node</a></li><li class="dropdown-item"><!----> <a href="/pages/927664/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/2c3f19/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Other" class="dropdown-title"><a href="/Other/" class="link-title">Other</a> <span class="title" style="display:none;">Other</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/fea344/" class="nav-link">Book</a></li><li class="dropdown-item"><!----> <a href="/pages/d62f72/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/f3d338/" class="nav-link">问题</a></li><li class="dropdown-item"><!----> <a href="/pages/ff202b/" class="nav-link">友链</a></li><li class="dropdown-item"><!----> <a href="/pages/2b746e/" class="nav-link">证券</a></li></ul></div></div><div class="nav-item"><a href="/About/" class="nav-link">About</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Index" class="dropdown-title"><a href="/archives/" class="link-title">Index</a> <span class="title" style="display:none;">Index</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Book</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>性能调优专题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1e3ac2/" class="sidebar-link">Java日志体系</a></li><li><a href="/pages/fea344/" class="sidebar-link">从JDK源码级别彻底剖析JVM类加载机制</a></li><li><a href="/pages/5c6dd7/" class="sidebar-link">JVM内存模型深度剖析与优化</a></li><li><a href="/pages/58de01/" class="sidebar-link">JVM对象创建与内存分配机制深度剖析</a></li><li><a href="/pages/2e5674/" class="sidebar-link">class文件结构</a></li><li><a href="/pages/cd229a/" class="sidebar-link">垃圾收集器ParNew&amp;CMS与底层三色标记算法详解</a></li><li><a href="/pages/ceb47b/" class="sidebar-link">垃圾收集器G1&amp;ZGC详解</a></li><li><a href="/pages/5bd770/" class="sidebar-link">JVM调优工具详解及调优实战</a></li><li><a href="/pages/6770e0/" class="sidebar-link">JVM调优实战及常量池详解</a></li><li><a href="/pages/0a8a34/" aria-current="page" class="active sidebar-link">Tomcat</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#一、tomcat处理请求过程" class="sidebar-link">一、Tomcat处理请求过程</a></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#二、tomcat响应数据过程" class="sidebar-link">二、Tomcat响应数据过程</a></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#三、tomcat中bio和nio底层原理实现对比" class="sidebar-link">三、Tomcat中BIO和NIO底层原理实现对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#bio" class="sidebar-link">BIO</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#nio" class="sidebar-link">NIO</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#四、tomcat中的类加载器与安全机制" class="sidebar-link">四、Tomcat中的类加载器与安全机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#类加载器" class="sidebar-link">类加载器</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#双亲委派" class="sidebar-link">双亲委派</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#urlclassloader" class="sidebar-link">URLClassLoader</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#tomcat中自定义的类加载器" class="sidebar-link">Tomcat中自定义的类加载器</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#tomcat中类加载器架构" class="sidebar-link">Tomcat中类加载器架构</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#安全机制" class="sidebar-link">安全机制</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#五、tomcat的架构-生命周期-事件监听" class="sidebar-link">五、Tomcat的架构，生命周期，事件监听</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#tomcat架构" class="sidebar-link">Tomcat架构</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#tomcat生命周期" class="sidebar-link">Tomcat生命周期</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#lifecycle" class="sidebar-link">Lifecycle</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#lifecyclestate" class="sidebar-link">LifecycleState</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#生命周期流转" class="sidebar-link">生命周期流转</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#tomcat事件监听" class="sidebar-link">Tomcat事件监听</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#事件触发" class="sidebar-link">事件触发</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#事件执行" class="sidebar-link">事件执行</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#事件监听器" class="sidebar-link">事件监听器</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#总结-2" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#六、tomcat启动过程" class="sidebar-link">六、Tomcat启动过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#解析server-xml" class="sidebar-link">解析server.xml</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#总结-3" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#初始化" class="sidebar-link">初始化</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#总结-4" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#启动" class="sidebar-link">启动</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#启动容器" class="sidebar-link">启动容器</a></li><li class="sidebar-sub-header level4"><a href="/pages/0a8a34/#启动connector" class="sidebar-link">启动Connector</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#七、tomcat热部署与热加载" class="sidebar-link">七、Tomcat热部署与热加载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#tomcat中的后台线程" class="sidebar-link">Tomcat中的后台线程</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#热加载" class="sidebar-link">热加载</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#热部署" class="sidebar-link">热部署</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#八、tomcat中关于session的实现" class="sidebar-link">八、Tomcat中关于session的实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#标准会话对象-standardsession" class="sidebar-link">标准会话对象-StandardSession</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#标准会话管理器-standardmanager" class="sidebar-link">标准会话管理器-StandardManager</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#九、spring-boot启动扫描servlet" class="sidebar-link">九、Spring Boot启动扫描Servlet</a></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#tomcat源码编译" class="sidebar-link">Tomcat源码编译</a></li><li class="sidebar-sub-header level2"><a href="/pages/0a8a34/#idea中运行tomcat-9源码" class="sidebar-link">IDEA中运行Tomcat 9源码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#使用idea从github上克隆源码" class="sidebar-link">使用IDEA从GITHUB上克隆源码</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#源码克隆下来后-不能直接运行-需要用ant进行编译-主要目的是下载依赖" class="sidebar-link">源码克隆下来后，不能直接运行，需要用ant进行编译，主要目的是下载依赖</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#依赖添加进来后-可以尝试使用idea构建工程了。" class="sidebar-link">依赖添加进来后，可以尝试使用IDEA构建工程了。</a></li><li class="sidebar-sub-header level3"><a href="/pages/0a8a34/#构建成功后-运行源代码。" class="sidebar-link">构建成功后，运行源代码。</a></li></ul></li></ul></li><li><a href="/pages/75f963/" class="sidebar-link">MySQL的内部组件结构</a></li><li><a href="/pages/40f348/" class="sidebar-link">索引底层原理</a></li><li><a href="/pages/937d63/" class="sidebar-link">Explain详解</a></li><li><a href="/pages/30cf7d/" class="sidebar-link">Mysql索引优化实战</a></li><li><a href="/pages/58ceb4/" class="sidebar-link">深入理解MVCC与BufferPool缓存机制</a></li><li><a href="/pages/067377/" class="sidebar-link">深入理解Mysql事务隔离级别与锁机制</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>并发编程专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>源码框架专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>微服务专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>项目实战专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>设计模式专题</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>问题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>友链</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>证券</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/Other/#Other" data-v-06225672>Other</a></li><li data-v-06225672><a href="/Other/#Book" data-v-06225672>Book</a></li><li data-v-06225672><a href="/Other/#性能调优专题" data-v-06225672>性能调优专题</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://nylg.gitee.io" target="_blank" title="作者" class="beLink" data-v-06225672>wen chao</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-06-18</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Tomcat<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="一、tomcat处理请求过程"><a href="#一、tomcat处理请求过程" class="header-anchor">#</a> 一、Tomcat处理请求过程</h2> <p>Tomcat通过Endpoint组件接收socket连接，接收到一个socket连接后会执行如下步骤</p> <ol><li>第一次从socket中获取数据到InputBuffer中，BIO对应的是InternalInputBuffer，父类是
AbstractInputBuffer</li> <li>然后基于InputBuffer进行解析数据</li> <li>先解析请求行，把请求方法，请求uri，请求协议等封装到org.apache.coyote.Request对象中</li> <li>org.apache.coyote.Request中的属性都是MessageBytes类型，直接可以理解为字节类型，因为从
socket中获取的数据都是字节，在解析过程中不用直接把字节转成字符串，并且MessageBytes虽然表
示字节，但是它并不会真正的存储字节，还是使用ByteChunk基于InputBuffer中的字节数组来进行标
记，标记字节数组中的哪个一个范围表示请求方法，哪个一个范围表示请求uri等等。</li> <li>然后解析头，和解析请求行类似</li> <li>解析完请求头后，就基于请求头来初始化一些参数，比如Connection是keepalive是close，比如是否
有Content-length，并且对于的⻓度是多少等等，还包括当前请求在处理请求体时应该使用哪个
InputFilter。</li> <li>然后将请求交给容器</li> <li>容器再将请求交给具体的servlet进行处理</li> <li>servlet在处理请求的过程中会利用response进行响应，返回数据给客户端，一个普通的响应过程会把
数据先写入一个缓冲区，当调用flush，或者close方法时会把缓冲区中的内容发送给socet，下面有一
篇单独的文章讲解tomcat响应请求过程</li> <li>servlet处理完请求后，先会检查是否需要把响应数据发送给socket</li> <li>接着看当前请求的请求体是否处理结束，是否还有剩余数据，如果有剩余数据需要把这些数据处理掉，以便能够获取到下一个请求的数据</li> <li>然后回到第一步开始处理下一个请求。</li></ol> <h2 id="二、tomcat响应数据过程"><a href="#二、tomcat响应数据过程" class="header-anchor">#</a> 二、Tomcat响应数据过程</h2> <p>当我们在Servlet中调用如下方法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>OutputStream outputStream = resp.getOutputStream();
outputStream.write(&quot;test&quot;.getBytes());
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>resp对应的类型为ResponseFacade, 得到的outputStream的类型为CoyoteOutputStream。
所以响应数据是通过CoyoteOutputStream这个类处理的。
当调用outputStream的write方法写数据时，实际调用的就是CoyoteOutputStream类的write(byte[] b)
方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    @Override
    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }

    @Override
    public void write(byte[] b, int off, int len) throws IOException {
        ob.write(b, off, len);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在CoyoteOutputStream类中有一个属性是ob，类型为org.apache.catalina.connector.OutputBuffer
，该属性是在构造CoyoteOutputStream对象时初始化的。先注意OutputBuffer所在的包。
我们在调用write方法时，实际就是调用OutputBuffer的write方法，而write方法实际调用的就是该类中的
writeBytes(byte b[], int off, int len)：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    private void writeBytes(byte b[], int off, int len) throws IOException {

        if (closed) {
            return;
        }

        bb.append(b, off, len);
        bytesWritten += len;

        // if called from within flush(), then immediately flush
        // remaining bytes
        if (doFlush) {
            // 那么每次write都把缓冲中的数据发送出去
            bb.flushBuffer();
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在OutputBuffer中有一个属性叫做bb，类型是ByteChunk。在Tomcat响应流程中，可以把ByteChunk类
当作一个缓冲区的实现，该类中有一个字节数组，名字叫做buff，默认大小为8192。</p> <p>当我们在write字节数据时，就是把数据添加到ByteChunk对应的缓冲区buff中。当把数据添加到缓冲区
后，如果有其他线程在执行outputSteam的flush()方法，则doFlush为true，那么则会调用
bb.flushBuffer()。</p> <p>这里就要考虑一个问题，我们把数据都写到了缓冲区buff中，那么buff中的数据是何时传递给socket中的
呢？</p> <p>在ByteChunk中有一个属性out，类型是ByteOutputChannel，它表示缓冲区中的数据该向流向哪个渠
道，为了方便理解，可以先理解为渠道就是socket，表示把缓冲区中的数据发送给socket，当实际情况并
不是，暂且这么理解。</p> <p>ByteOutputChannel类中有一个方法realWriteBytes(byte buf[], int off, int len)，当调用
out.realWriteBytes(src, off, len)方法时，就会把src数据发送给对应驱动</p> <p>在当前这个ByteChunk中，它的out对应的仍然还是org.apache.catalina.connector.OutputBuffer，在
这个类中存在该方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    public void realWriteBytes(byte buf[], int off, int cnt) throws IOException {
        if (closed) {
            return;
        }
        if (coyoteResponse == null) {
            return;
        }
        // If we really have something to write
        if (cnt &gt; 0) {
            // real write to the adapter
            outputChunk.setBytes(buf, off, cnt);
            try {
                coyoteResponse.doWrite(outputChunk);
            } catch (IOException e) {
                // An IOException on a write is almost always due to
                // the remote client aborting the request. Wrap this
                // so that it can be handled better by the error disp
                atcher.
                throw new ClientAbortException(e);
            }
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>该方法中通过一个outputChunk来标记数据，表示标记的这些数据是要发送给socket的。而真正的发送逻
辑交给了coyoteResponse.doWrite(outputChunk)来进行处理，coyoteResponse的类型为
org.apache.coyote.Response。</p> <p>具体怎么将缓冲区中所标记的数据怎么发送出去的，我们等会再看，我们先来看到底何时会触发这个发送
动作。</p> <p>ByteChunk中有一个方法append，表示向缓冲区buff中添加数据，其中有一个逻辑，当缓冲区满了之后就
会调用out.realWriteBytes(src, off, len)，表示把缓冲区中的数据发送出去。缓存区的大小有一个限制，
可以修改，默认为8192。</p> <p>还有一种情况就算缓冲区没有满，但是在write之前调用用过flush方法，那么本次write的数据会先放入缓
冲区，然后再把缓冲区中的数据发送出去。</p> <p>当我们调用outputStream的flush方法时：</p> <ol><li>先判断是否发送过响应头，没有发送则先发送响应头</li> <li>再调用ByteChunk的flushBuffer方法，把缓冲区中剩余的数据发送出去</li> <li>因为上文中我们所理解的将缓冲区的数据发送出去，是直接发送给socket，但实际情况是把数据发送给另外一个缓冲区，这个缓冲区也是用ByteChunk类实现的，名字叫做socketBuffer。所以当我们在使用flush方法时就需要把socketBuffer中的数据真正发送给socket。
接下来我们来看看coyoteResponse.doWrite(outputChunk);的具体实现细节。
该发方法实际调用的是outputBuffer.doWrite(chunk, this);这里的outputBuffer的类型是
InternalOutputBuffer，在执行doWrite方法时，调用的是父类AbstractOutputBuffer的doWrite方法。
该doWrite方法中，首先会判断响应头是否已经发送，如果没有发送，则会构造响应头，并发响应头发送给
socketBuffer，发送完响应头，会调用响应的output的activeFilters，对于不同的响应体需要使用不同的
发送逻辑。比如ChunkedOutputFilter是用来发送分块响应体的，IdentityOutputFilter是用来发送
Content-length响应体的，VoidOutputFilter不会真正的把数据发送出去。
在构造响应头时，会识别响应体应该通过什么OutputFilter来发送，如果响应中存在content-length那么
则使用IdentityOutputFilter来发送响应体，否则使用ChunkedOutputFilter，当然还有一些异常情况下会
使用VoidOutputFilter，表示不会发送响应体。
那现在的问题的，响应体的Content-length是在什么时候确定的？
答案是：当请求在servlet中执行完成后，会调用response.finishResponse()方法，该方法会调用
outputBuffer.close()，该outputBuffer就是org.apache.catalina.connector.OutputBuffer，该方法会
判断响应体是否已发送，如果在调用这个close时响应头还没有发送，则表示响应体的数据在之前一直没有
发送过，一直存在了第一层缓冲区中，并且一直没有塞满该缓冲区，因为该缓冲区如果被塞满了，则会发
送响应头，所以当执行到close方法是，响应头还没发送过，那么缓冲区中的数据就是响应体全部的数据，
即，缓冲区数据的⻓度就是content-length。
反之，在调用close方法之前，就已经发送过数据了，那么响应头中就没有content-length，就会用
ChunkedOutputFilter来发送数据。
并且在执行close方法时，会先将响应头的数据发送给socketbuffer，然后将第一层缓冲区的数据通过对应
的OutputFilter发送给socketbuffer，然后调用OutputFilter的end方法，IdentityOutputFilter的end方
法实现很简单，而ChunkedOutputFilter的end方法则相对做的事情更多一点，因为
ChunkedOutputFilter的doWrite一次只会发送一块数据，所以end要负责循环调用doWrite方法，把全部
的数据库发送完。</li></ol> <h2 id="三、tomcat中bio和nio底层原理实现对比"><a href="#三、tomcat中bio和nio底层原理实现对比" class="header-anchor">#</a> 三、Tomcat中BIO和NIO底层原理实现对比</h2> <p>在Tomcat7中，默认为BIO，可以通过如下配置改为NIO</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="bio"><a href="#bio" class="header-anchor">#</a> BIO</h3> <p>BIO的模型比较简单。</p> <ol><li><p>JioEndpoint中的Acceptor线程负责循环阻塞接收socket连接</p></li> <li><p>每接收到一个socket连接就包装成SocketProcessor扔进线程池Executor中，SocketProcessor是一个Runnable</p></li> <li><p>SocketProcessor负责从socket中阻塞读取数据，并且向socket中阻塞写入数据</p></li></ol> <p>Acceptor线程的数量默认为1个，可以通过acceptorThreadCount参数进行配置
线程池Executor是可以配置的，比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;
&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; executor=&quot;tomcatThreadPool&quot;/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>从上面的配置可以看到，每个Connector可以对应一个线程池，默认情况下，Tomcat中每个Connector都
会创建一个自己的线程池，并且该线程池的默认值为：</p> <ol><li>最小线程数量为10</li> <li>最大线程数量为200</li></ol> <p>如果两个Connector配置的executor是一样的话，就表示这两个Connector公用一个线程池。
使用BIO来处理请求时，我们可以总结一下：</p> <ol><li>当请求数量比较大时，可以提高Acceptor线程的数量，提高接收请求的速率</li> <li>当请求比较耗时是，可以提高线程池Executor的最大线程数量</li></ol> <p>当然，增加线程的目的都是为了提高Tomcat的性能，但是一台机器的线程数量并不是越多越好，需要利用
压测来最终确定一个更加符合当前业务场景的线程数量。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618135324973.png" alt="image-20220618135324973"></p> <h3 id="nio"><a href="#nio" class="header-anchor">#</a> NIO</h3> <p>最大的特性就是非阻塞，非阻塞接收socket连接，非阻塞从socket中读取数据，非阻塞从将数据写到
socket中。</p> <p>但是在Tomcat7中，只有在从socket中读取请求行，请求头数据时是非阻塞的，在读取请求体是阻塞的，
响应数据时也是阻塞的。</p> <p>为什么不全是非阻塞的呢？因为Tomcat7对应Servlet3.0，Servlet3.0规范中没有考虑NIO，比如我们读取
请求体的代码得这么写：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        ServletInputStream inputStream = req.getInputStream();
        byte[] bytes = new byte[1024];
        int n;
        while ((n = inputStream.read(bytes)) &gt; 0) {
            System.out.println(new String(bytes, 0, n));
        }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>inputStream.read()方法的含义就是阻塞读取数据，当读取请求体时，如果操作系统中还没有准备好，那
么read方法就得阻塞。</p> <p>而NIO则不一样，NIO中是一旦操作系统中的数据准备好了，那么则会通知Java程序可以读取数据了，这里
的通知很重要，这决定了我们的Java代码到底如何实现，如果在Servlet中想利用NIO去读取数据，那么在
Servlet中肯定就要去监听是否有通知过来，比如在Servlet3.1中则增加了NIO相关的定义，如下面代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        ServletInputStream inputStream = req.getInputStream();
        inputStream.setReadListener(new ReadListener() {
            // 有数据可用时触发
            @Override
            public void onDataAvailable() throws IOException {

            }

            // 数据全部读完了
            @Override
            public void onAllDataRead() throws IOException {

            }

            // 出现异常了
            @Override
            public void onError(Throwable throwable) {

            }
        });
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>很明显可以看出来，这里有Listener，用来监听数据可读的通知，这才是真正的利用了NIO。</p> <p>而我们这里暂时只分析Tomcat7中的NIO，Servlet3.1是在Tomcat8中实现的，所以敬请期待吧。</p> <p>首先我们来看一下Tomcat7中使用NIO处理请求的基本流程：</p> <ol><li>利用Acceptor来阻塞获取socket连接，NIO中叫socketChannel</li> <li>接收到socketChannel后，需要将socketChannel绑定到一个Selector中，并注册读事件，另外，基于NIO还需要一个线程来轮询Selector中是否存在就绪事件，如果存在就将就绪事件查出来，并处理该事件，在Tomcat中支持多个线程同时查询是否存在就绪事件，该线程对象为Poller，每个Poller中都包含一个Selector，这样每个Poller线程就负责轮询自己的Selector上就绪的事件，然后处理事件。</li> <li>当Acceptro接收到一个socketChannel后，就会将socketChannel注册到某一个Poller上，确定
Polloer的逻辑非常简单，假设现在有3个Poller，编号为1,2,3，那么Tomcat接收到的第一个
socketChannel注册到1号Poller上，第二个socketChannel注册到2号Poller上，第三个
socketChannel注册到3号Poller上，第四个socketChannel注册到1号Poller上，依次循环。</li> <li>在某一个Poller中，除开有selector外，还有一个ConcurrentLinkedQueue队列events，events表示待执行事件，比如Tomcat要socketChannel注册到selector上，但是Tomcat并没有直接这么做，而
是先自己生成一个PollerEvent，然后把PollerEvent加入到队列events中，然后这个队列中的事件会在Poller线程的循环过程中真正执行</li> <li>上面说了，Poller线程中需要循环查询selector中是否存在就绪事件，而Tomcat在真正查询之前会先看一下events队列中是否存在待执行事件，如果存在就会先执行，这些事件表示需要向selector上注册事件，比如注册socketChannel的读事件和写事件，所以在真正执行events队列中的事件时就会真正的向selector上注册事件。所以只有先执行events队列中的PollerEvent，Poller线程才能有机会从selector中查询到就绪事件</li> <li>每个Poller线程一旦查询到就绪事件，就会去处理这些事件，事件无非就是读事件和写事件</li> <li>处理的第一步就是获取当前就绪事件对应的socketChannel，因为我们要向socketChannel中读数据或写数据</li> <li>处理的第二步就是把socketChannel和当前要做的事情（读或写）封装为SocketProcessor对象</li> <li>处理的第三步就是把SocketProcessor扔进线程池进行处理</li> <li>在SocketProcessor线程运行时，就会从socketChannel读取数据（假设当前处理的是读事件），并且是非阻塞读</li> <li>既然是非阻塞读，大概的一个流程就是，某一个Poller中的selector查询到了一个读就绪事件，然后交给一个SocketProcessor线程进行处理，SocketProcessor线程读取数据之后，如果发现请求行和请求头的数据都已经读完了，并解析完了，那么该SocketProcessor线程就会继续把解析后的请求交给Servlet进行处理，Servlet中可能会读取请求体，可能会响应数据，而不管是读请求体还是响应数据都是阻塞的，直到Servlet中的逻辑都执行完后，SocketProcessor线程才会运行结束。假如
SocketProcessor读到了数据之后，发现请求行或请求头的数据还没有读完，那么本次读事件处理完
毕，需要Poller线程再次查询到就绪读事件才能继续读数据，以及解析数据</li> <li>实际上Tomcat7中的非阻塞读就只是在读取请求行和请求体数据时才是非阻塞的，至于请求体的数据，是在Servlet中通过inputstream.read()方法获取时才会真正的去获取请求体的数据，并且是阻塞的。</li></ol> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618135822913.png" alt="image-20220618135822913"></p> <p>接下来我们来看下Tomcat7中是怎么阻塞的利用NIO来读取数据的。</p> <p>当Servlet中通过inputstream.read()来读取请求体数据时，最终执行的是InternalNioInputBuffer.SocketInputBuffer.doRead()方法。
在这个方法中会调用fill(true,true)，第一个参数是timeout，第二个参数是block，block等于true，表示阻塞，fill方法中就会从操作系统读取数据填充到Tomcat的buf中。</p> <p>在接下来的阻塞读取数据流程中，主要利用的还是Selector，为什么阻塞的时候还要利用Selector呢？这是因为，socketChannel一开始是非阻塞的，我们现在如果想把它改成阻塞的，在NIO里是有一个限制的，如果一个socketChannel被设置成了非阻塞的，然后注册了事件，然后又想把socketChannel设置成阻塞的，这时是会抛异常的。所以在Tomcat中是使用的另外的方式来达到阻塞效果的。</p> <p>所以现在的目的是，仍然基于Selector的情况下达到阻塞效果，为了达到这个效果，原理也不难。</p> <p>在我们需要读取请求体数据时，不能直接利用之前的主Selector了（主Selector就是用来注册新socketChannel的），所以我们需要一个辅助Selector，在读取请求体数据时，新生成一个辅助Selector，这个辅助Selector用来监听当前请求的读事件，当有数据就绪时，辅助Selector就会查询到此次就绪事件（注意：这个时候主Selector是监听不到的，因为在这之前主Selector已经取消了对当前socketChannel的事件）。</p> <p>这是辅助Selector的主要作用，具体流程如下：</p> <ol><li>inputstream.read()</li> <li>向辅助Selector注册读事件</li> <li>加锁（目的是达到阻塞）</li> <li>与辅助Selector对应的有另外一个辅助Poller，辅助Poller负责轮询辅助Selector上发生的就绪事件，
一旦轮询到就绪事件就会解锁，从而解阻塞</li> <li>从socketChannel中读数据</li> <li>返回，本次read结束</li></ol> <p>默认情况下，辅助Selector是NioBlockingSelector对象，每次read都使用同一个NioBlockingSelector
对象，在NioBlockingSelector对象中存在一个BlockPoller线程，BlockPoller就是辅助Poller。
对于响应也是类似的思路，也是先注册写事件，阻塞，都有写就绪事件时就解阻塞，开始写入数据。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>在Tomcat7，虽然有NIO，但是不够彻底，相比如BIO，优点仅限于能利用较少的线程同时接收更多的请
求，但是在真正处理请求时，想比如BIO并没有太多的优势，如果在处理一个请求时既不用读取请求，也不
需要响应很多的数据那么NIO模式还是会拥有更大的吞吐量，所以如果要优化的话，将BIO改成NIO也是可
以的。</p> <h2 id="四、tomcat中的类加载器与安全机制"><a href="#四、tomcat中的类加载器与安全机制" class="header-anchor">#</a> 四、Tomcat中的类加载器与安全机制</h2> <h3 id="类加载器"><a href="#类加载器" class="header-anchor">#</a> 类加载器</h3> <p>Java中的类遵循按需加载。
所谓类加载器，就是用于加载 Java 类到 Java 虚拟机中的组件，它负责读取 Java 字节码，并转换成
java.lang.Class 类的一个实例，使字节码.class 文件得以运行。一般类加载器负责根据一个指定的类找到
对应的字节码，然后根据这些字节码定义一个 Java 类。另外，它还可以加载资源，包括图像文件和配置
文件。
类加载器在实际使用中给我们带来的好处是，它可以使 Java 类动态地加载到 JVM 中并运行，即可在程序
运行时再加载类，提供了很灵活的动态加载方式。</p> <ul><li>启动类加载器（Bootstrap ClassLoader）：加载对象是 Java 核心库，把一些核心的 Java 类加载进
JVM 中，这个加载器使用原生代码（C/C++）实现，并不是继承 java.lang.ClassLoader，它是所有
其他类加载器的最终父加载器，负责加载 &lt;JAVA_HOME&gt;/jre/lib 目录下 JVM 指定的类库。其实它
属于 JVM 整体的一部分，JVM 一启动就将这些指定的类加载到内存中，避免以后过多的 I/O 操作，
提高系统的运行效率。启动类加载器无法被 Java 程序直接使用。</li> <li>扩展类加载器（Extension ClassLoader）：加载的对象为 Java 的扩展库，即加载
&lt;JAVA_HOME&gt;/jre/lib/ext 目录里面的类。这个类由启动类加载器加载，但因为启动类加载器并非
用 Java 实现，已经脱离了 Java 体系，所以如果尝试调用扩展类加载器的 getParent()方法获取父加
载器会得到 null。然而，它的父类加载器是启动类加载器。</li> <li>应用程序类加载器（Application ClassLoader）：亦叫系统类加载器（System ClassLoader），它
负责加载用户类路径（CLASSPATH）指定的类库，如果程序没有自己定义类加载器，就默认使用应用
类加载器</li></ul> <p>程序类加载器。它也由启动类加载器加载，但它的父加载类被设置成了扩展类加载器。如果要使用这个
加载器，可通过 ClassLoader.getSystemClassLoader()获取。</p> <h4 id="双亲委派"><a href="#双亲委派" class="header-anchor">#</a> 双亲委派</h4> <p>双亲委派模型会在类加载器加载类时首先委托给父类加载器加载，除非父类加载器不能加载才自己加载。
这种模型要求，除了顶层的启动类加载器外，其他的类加载器都要有自己的父类加载器。假如有一个类要
加载进来，一个类加载器并不会⻢上尝试自己将其加载，而是委派给父类加载器，父类加载器收到后又尝
试委派给其父类加载器，以此类推，直到委派给启动类加载器，这样一层一层往上委派。只有当父类加载
器反馈自己没法完成这个加载时，子加载器才会尝试自己加载。通过这个机制，保证了 Java 应用所使用
的都是同一个版本的 Java 核心库的类，同时这个机制也保证了安全性。设想如果应用程序类加载器想要
加载一个有破坏性的 java.lang.System 类，双亲委派模型会一层层向上委派，最终委派给启动类加载
器，而启动类加载器检查到缓存中已经有了这个类，并不会再加载这个有破坏性的 System 类。
另外，类加载器还拥有全盘负责机制，即当一个类加载器加载一个类时，这个类所依赖的、引用的其他所
有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。
在 Java 中，我们用完全匹配类名来标识一个类，即用包名和类名。而在 JVM 中，一个类由完全匹配类名
和一个类加载器的实例 ID 作为唯一标识。也就是说，同一个虚拟机可以有两个包名、类名都相同的类，只
要它们由两个不同的类加载器加载。当我们在 Java 中说两个类是否相等时，必须在针对同一个类加载器
加载的前提下才有意义，否则，就算是同样的字节码，由不同的类加载器加载，这两个类也不是相等的。
这种特征为我们提供了隔离机制，在 Tomcat 服务器中它是十分有用的。</p> <h4 id="urlclassloader"><a href="#urlclassloader" class="header-anchor">#</a> URLClassLoader</h4> <p>我们在使用自定义类加载去加载类时，我们需要指明该去哪些资源中进行加载，所以JDK提供了
URLClassLoader来方便我们使用，我们在创建URLClassLoader时需要传入一些URLs，然后在使用这个
URLClassLoader加载类时就会从这些资源中去加载。</p> <h4 id="tomcat中自定义的类加载器"><a href="#tomcat中自定义的类加载器" class="header-anchor">#</a> Tomcat中自定义的类加载器</h4> <p>Tomcat 拥有不同的自定义类加载器，以实现对各种资源库的控制。一般来说，Tomcat 主要用类加载器
解决以下 4 个问题。</p> <ul><li>同一个Tomcat中，各个Web应用之间各自使用的Java类库要互相隔离。</li> <li>同一个Tomcat中，各个Web应用之间可以提供共享的Java类库。</li> <li>为了使Tomcat不受Web应用的影响，应该使服务器的类库与应用程序的类库互相独立。</li> <li>Tomcat支持热部署。</li></ul> <p>在 Tomcat中，最重要的一个类加载器是 Common 类加载器，它的父类加载器是应用程序类加载器，负责加载 $CATALINA_ BASE/lib、$CATALINA_HOME/lib 两个目录下所有的.class 文件与.jar 文件。</p> <p>Tomcat中一般会有多个WebApp类加载器-WebAppClassLoader ，每个类加载器负责加载一个 Web 程序。它的父类加载器是Common类加载器。</p> <p>由于每个 Web 应用都有自己的 WebApp 类加载器，很好地使多个 Web 应用程序之间互相隔离且能通过创建新的 WebApp类加载器达到热部署。这种类加载器结构能有效使 Tomcat 不受 Web 应用程序影响，而 Common 类加载器的存在使多个 Web 应用程序能够互相共享类库。</p> <h3 id="tomcat中类加载器架构"><a href="#tomcat中类加载器架构" class="header-anchor">#</a> Tomcat中类加载器架构</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618140844956.png" alt="image-20220618140844956"></p> <h3 id="安全机制"><a href="#安全机制" class="header-anchor">#</a> 安全机制</h3> <p>Tomcat中设置了了一些安全策略，默认的策略文件为conf/catalina.policy。</p> <p>Tomcat中设置了安全策略，规定了Tomcat在运行过程中拥有的权限，Tomcat管理者可以修改该权限，但是Tomcat中有一些类是必须能够被访问到的，所有Tomcat中在启动过程中会提前去加载这些类，如果发现没有对应的权限，那么将会启动失败</p> <h2 id="五、tomcat的架构-生命周期-事件监听"><a href="#五、tomcat的架构-生命周期-事件监听" class="header-anchor">#</a> 五、Tomcat的架构，生命周期，事件监听</h2> <h3 id="tomcat架构"><a href="#tomcat架构" class="header-anchor">#</a> Tomcat架构</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618141220595.png" alt="image-20220618141220595"></p> <h3 id="tomcat生命周期"><a href="#tomcat生命周期" class="header-anchor">#</a> Tomcat生命周期</h3> <p>Tomcat架构是一种树状的层级管理结构，组件会有自己的父节点，也可能会有自己的孩子节点，每个节点都是组件，每个组件都有生命周期，为了管理方便，子节点的生命周期都是交由父节点来管理的。</p> <p>每个组件生命周期的管理主要由一个接口org.apache.catalina.Lifecycle和一个枚举org.apache.catalina.LifecycleState来表示。</p> <h4 id="lifecycle"><a href="#lifecycle" class="header-anchor">#</a> Lifecycle</h4> <p>org.apache.catalina.Lifecycle接口定义了组件所有执行的动作，核心的有三个：</p> <ol><li>init()，组件进行初始化</li> <li>start()，启动组件</li> <li>stop()，停止组件</li> <li>destroy()，销毁组件</li> <li>getState()，获取组件当前状态</li></ol> <h4 id="lifecyclestate"><a href="#lifecyclestate" class="header-anchor">#</a> LifecycleState</h4> <p>org.apache.catalina.LifecycleState是一个枚举，表示组件的所有生命周期。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>NEW(false, null),
INITIALIZING(false, Lifecycle.BEFORE_INIT_EVENT),
INITIALIZED(false, Lifecycle.AFTER_INIT_EVENT),
STARTING_PREP(false, Lifecycle.BEFORE_START_EVENT),
STARTING(true, Lifecycle.START_EVENT),
STARTED(true, Lifecycle.AFTER_START_EVENT),
STOPPING_PREP(true, Lifecycle.BEFORE_STOP_EVENT),
STOPPING(false, Lifecycle.STOP_EVENT),
STOPPED(false, Lifecycle.AFTER_STOP_EVENT),
DESTROYING(false, Lifecycle.BEFORE_DESTROY_EVENT),
DESTROYED(false, Lifecycle.AFTER_DESTROY_EVENT),
FAILED(false, null);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>枚举值表示状态</li> <li>第一个参数表示当前状态下组件可不可用</li> <li>第二个参数表示当变为当前状态时出发相应事件</li></ul> <h4 id="生命周期流转"><a href="#生命周期流转" class="header-anchor">#</a> 生命周期流转</h4> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618141556348.png" alt="image-20220618141556348"></p> <ol><li>所有状态都能转变为FAILED</li> <li>一个组件在STARTING_PREP、STARTING、STARTED状态调用start()方法不会产生影响</li> <li>一个组件在NEW状态调用start()方法时，会先调用init()方法</li> <li>一个组件在STOPPING_PREP、STOPPING、STOPPED状态调用stop方法不会产生影响</li> <li>一个组件在NEW状态调用stop()方法是，会将状态直接改为STOPPED。当组件自己启动失败去停止
时，需要将子组件也进行停止，尽管某些子组件还没有启动。</li> <li>其他状态相互转换都会抛异常</li> <li>合法的状态转换发生时都会触发相应的LifecycleEvent事件，非合法的转换不会触发事件。</li></ol> <h3 id="tomcat事件监听"><a href="#tomcat事件监听" class="header-anchor">#</a> Tomcat事件监听</h3> <h4 id="事件触发"><a href="#事件触发" class="header-anchor">#</a> <strong>事件触发</strong></h4> <p>Tomcat中每个组件的状态会发送变化，变化的时候会抛出一些事件，Tomcat支持定义事件监听器来监听
并消费这些事件。</p> <h4 id="事件执行"><a href="#事件执行" class="header-anchor">#</a> 事件执行</h4> <p>实现事件监听功能的类为org.apache.catalina.util.LifecycleBase。每个组件都会继承这个类。</p> <p>该类中有一个属性： <code>List&lt;LifecycleListener&gt; lifecycleListeners</code> ; 该属性用来保存事件监
听器，也就是说每个组件拥有一个事件监听器列表。
该类中有一个方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    protected void fireLifecycleEvent(String type, Object data) {
        LifecycleEvent event = new LifecycleEvent(this, type, data);
        for (LifecycleListener listener : lifecycleListeners) {
            listener.lifecycleEvent(event);
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当组件的状态发生变化时，会调用fireLifecycleEvent触发事件执行。比如当Server初始化时，会调用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>setStateInternal(LifecycleState.STARTING_PREP, null, false);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该方法内部会执行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>   String lifecycleEvent = state.getLifecycleEvent();
    if(lifecycleEvent !=null){
        fireLifecycleEvent(lifecycleEvent, data);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="事件监听器"><a href="#事件监听器" class="header-anchor">#</a> 事件监听器</h4> <p>程序员可以自定义事件监听器，只需实现LifecycleListener接口即可，比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class NamingContextListener implements LifecycleListene{...}
class FrameworkListener implements LifecycleListener{...}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>定义好事件监听器后，每个组件就可以调用父类LifecycleBase中的addLifecycleListener()方法添加事件
监听器到该组件的监听器列表中。</p> <h4 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h4> <p>虽然说是事件监听，但实际上并不是异步触发，而是主动调用事件监听器</p> <h2 id="六、tomcat启动过程"><a href="#六、tomcat启动过程" class="header-anchor">#</a> 六、Tomcat启动过程</h2> <h3 id="解析server-xml"><a href="#解析server-xml" class="header-anchor">#</a> 解析server.xml</h3> <ol><li>Catalina catalina = new Catalina(); // 没做其他事情</li> <li>catalina.setAwait(true);</li> <li>以下步骤是解析servler.xml</li> <li>StandardServer server = new StandardServer(); // 没做其他事情</li> <li>catalina.setServer(server);</li> <li>server.addLifecycleListener(...);</li> <li>StandardService service = new StandardService(); // 没做其他事情</li> <li>server.addService(service);</li> <li>Connector connector = new Connector(); // 会根据配置初始化protocolHandler</li></ol> <ul><li>a. endpoint = new JIoEndpoint(); // 初始化Endpoint， JioEndpoint中会
setMaxConnections(0);</li> <li>b. cHandler = new Http11ConnectionHandler(this); //</li> <li>c. ((JIoEndpoint) endpoint).setHandler(cHandler); // endpoint对应的连接处理器</li></ul> <ol start="10"><li>service.addConnector(connector);</li> <li>Engine engine = new StandardEngine(); // pipeline.setBasic(new StandardEngineValve());</li> <li>service.setContainer(engine);</li> <li>Host host = new StandardHost(); // pipeline.setBasic(new StandardHostValve());</li> <li>engine.addChild(host);</li> <li>Context context = new StandardContext(); // pipeline.setBasic(new StandardContextValve());</li> <li>host.addChild(context);</li> <li>engine.setParentClassLoader(Catalina.class.getClassLoader()); // 实际调用的是ContainerBase.setParentClassLoader方法，设置属性parentClassLoader为shareClassLoader</li> <li>server.setCatalina(catalina);</li> <li>server.init(); // 开始初始化</li> <li>catalina.start(); // 开始启动</li></ol> <h4 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h4> <p>解析server.xml最主要的作用就是</p> <ol><li><p>把server.xml中定义的节点都生成对应的java对象，比如在解析某一个Host节点时就会对应生成一个
StandardHost对象</p></li> <li><p>把server.xml中定义的节点的层级关系解析出来，比如StandardContext对
象.addChild(StandardHost对象)</p></li> <li><p>设置每个容器的pipeline的基础Valve</p></li></ol> <h3 id="初始化"><a href="#初始化" class="header-anchor">#</a> 初始化</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618143959476.png" alt="image-20220618143959476"></p> <h4 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> 总结</h4> <p>初始化做得事情比较少，最重要的可能就是endpoint的bind的了。</p> <h3 id="启动"><a href="#启动" class="header-anchor">#</a> 启动</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618144250195.png" alt="image-20220618144250195"></p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618144304430.png" alt="image-20220618144304430"></p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618144412055.png" alt="image-20220618144412055"></p> <p><strong>启动</strong></p> <p>启动做的事情就比较多了，主要分为以下几个步骤</p> <h4 id="启动容器"><a href="#启动容器" class="header-anchor">#</a> 启动容器</h4> <p>启动容器主要是部署应用，部署应用分为两部分：</p> <p>1.部署server.xml中定义的context</p> <p>部署webapp文件夹下的context</p> <p>部署一个应用主要分为以下步骤</p> <ol><li>生成Context对象，server.xml中定义的Context在解析server.xml时就已经生成了，webapp文件夹下
的是在部署之前生成的</li> <li>为每个应用生成一个WebappClassLoader</li> <li>解析web.xml</li> <li>设置Context对象中的属性，比如有哪些Wrapper</li></ol> <h4 id="启动connector"><a href="#启动connector" class="header-anchor">#</a> 启动Connector</h4> <p>主要是：</p> <ol><li><p>启动Endpoint开始接收请求</p></li> <li><p>构造Mapper对象，用来处理请求时，快速解析出当前请求对应哪个Context，哪个Wrapper</p></li></ol> <h2 id="七、tomcat热部署与热加载"><a href="#七、tomcat热部署与热加载" class="header-anchor">#</a> 七、Tomcat热部署与热加载</h2> <p>热部署和热加载是类似的，都是在不重启Tomcat的情况下，使得应用的最新代码生效。
热部署表示重新部署应用，它的执行主体是Host，表示主机。
热加载表示重新加载class，它的执行主体是Context，表示应用。</p> <h3 id="tomcat中的后台线程"><a href="#tomcat中的后台线程" class="header-anchor">#</a> Tomcat中的后台线程</h3> <p>热部署和热加载都需要监听相应的文件或文件夹是否发生了变化。它们都是由Tomcat的后台线程触发的。</p> <p>BackgroundProcessor就表示后台线程。</p> <p>每个容器都可以拥有一个BackgroundProcessor，但是默认情况下只有Engine容器会在启动的时候启动
一个BackgroundProcessor线程。</p> <p>该线程会每隔一段时间（可以设置，单位为秒），去执行后台任务，先执行本容器定义的后台任务，然后
再执行子容器的定义的后台任务，子容器的任务执行完成后会继续执行其子容器的任务，直到没有子容器
为止。从这里可以看出就算每个容器自己开启一个BackgroundProcessor，也只不过是多了一个执行相
同任务的线程而已，执行任务的效率有所提升。</p> <p>对于后台任务，所有容器会有一些统一的任务需要执行：</p> <ol><li><p>集群服务器心跳</p></li> <li><p>如果一个容器拥有自己的类加载器，那么查看是否需要进行热加载</p></li> <li><p>检查Session是否过期</p></li> <li><p>执行每个容器对于的Realm对应的后台任务</p></li> <li><p>执行每个容器中pipeline中的每个valve的后台任务</p></li> <li><p>发布PERIODIC_EVENT事件</p></li></ol> <p>在这个过程中的第2步中会触发热加载，第6步中会触发热部署</p> <h3 id="热加载"><a href="#热加载" class="header-anchor">#</a> 热加载</h3> <p>我们可以在Context上配置reloadable属性为true，这样就表示该应用开启了热加载功能，默认是false。
热加载触发的条件是：WEB-INF/classes目录下的文件发生了变化，WEB-INF/lib目录下的jar包添加、
删除、修改都会触发热加载。</p> <p>热加载大致流程为：</p> <ol><li>设置当前Context不能接受以及处理请求标志为true</li> <li>停止当前Context</li> <li>启动当前Context</li> <li>设置当前Context不能接受以及处理请求标志为false</li></ol> <p>我们着重来分析一下第2、3步。
我们不妨先来分析第3步-启动当前Context的过程中会发生什么事情：</p> <ol><li>创建一个每个应用都单独自定义的WebappClassLoader</li> <li>解析web.xml文件，这一步会做很多事情，但是主要的目的是寻找定义的Servlet并把它添加到Context
中去，而对于寻找Servlet需要进行两个方面的寻找，一是从web.xml中寻找定义的Servlet，二是从寻
找class文件中添加了@WebServlet注解的类。大家很有可能认为，此时是不是会去加载我们定义的
Servlet类，可以告诉大家的是，这个时候不会，Servlet类的加载是在后面步骤发生的，那么这里就有
疑问了，我们要看一个类上是不是存在一个@WebServlet注解，应该要先加载这个类呀？Tomcat并没
有这么做，它是直接先把class文件当做一个普通文件，然后看这个文件对应的地方是否存在一个
WebServlet注解，如果存在，则认为这个class文件是一个Servlet，然后把这个class的全名封装到
Servlet对象中去，然后将Servlet对象添加到Context对象中。在解析web.xml时也是类似了，对于我
们定义的Servlet，最后都会生成一个Servlet对象，然后记录一个这个Servlet对象对应的class的全
名，最后把Servlet对象添加到Context中去。</li> <li>我们在使用Servlet的时候还会用其他的一些注解比如@ServletSecurity、@RunAs等等，对于这些注解是有特定功能的，Tomcat为了识别这个注解，此时就要去真正加载我们的Servlet类了。当然要不要识别这些注解是可以配置的，如果不识别，那么这一步就不会发生了，那么Servlet类的加载就会在有请求过来时才会进行类的加载。</li></ol> <p>加载类过程：</p> <ol><li>调用WebappClassLoaderBase的loadClass方法进行类的加载，该方法传递一个类的全限定名。</li> <li>要加载一个类，先得找到这个类在哪里，对应的是哪个classs文件，所以Tomcat中有一个缓存对象，
该对象保存了一个类的全限定名对应的资源路径。当然，在第一次加载这个类时，这个缓存是空的，所
以这个时候就要去寻找这个类对应的class文件地址，找到之后再缓存。接下来就来分析是怎么找到这
个class文件地址的。</li> <li>其实查找很容易，现在WEB-INF/classes/目录下是否存在这个类，如果不存在就看WEB-INF/lib/目录下的JAR包中是否存在这个类，最终如果找到就将进行缓存，保存一个类的全限定名对应的class文件地址或jar包地址。</li> <li>当知道这个类在哪了之后，就可以defineClass了，最终得到一个class对象，并且也会将这个class对象设置到我们的缓存中，所以上文说的缓存中，其实是这么一个映射关系，一个类的全限定名对应这个类的文件地址以及这个类的class对象。</li> <li>所以当下次再有情况需要加载class时，就可以直接取缓存中的对应的class对象了。</li></ol> <p>这是第3步，我们在来看第2步：
对于第2步-停止当前Context，其实所做的事情比较单一，就是清空和销毁，而其中跟类加载相关就是清空上文中的缓存对象。</p> <p>这样，我们的热加载就是先清空所有东⻄，然后重新启动我们应用，但是因为这个的触发条件基本上是class类发生了变化，所以热加载的过程中关于应用其他的一些属性是没有发生变化的，比如你现在想在Context中添加一个Vavle是不会触发热加载的，而如果要达到这个效果就要用到热部署。</p> <blockquote><p>注意：虽然我们在热加载的过程发现它是先停止再启动，做法看似粗暴，但是这样是性价比比较高的，
并且这种方式至少比重启Tomcat效率要高很多。</p></blockquote> <blockquote><p>注意：热加载不能用于war包</p></blockquote> <p>关于类的加载，这里有一点是需要注意的，对于一个class文件所表示的类，同一个类加载器的不同实例，都可以加载这个类，并且得到的class对象是不同的，回到热加载，我们举一个例子，我们现在有一个A类，一个自定义的WebappClassloader类，一开始先用一个WebappClassloader实例加载A类，那么在
jvm中就会存在一个A类的class对象，然后进行热加载，先停止，再启动，在停止的时候会杀掉当前应用的所有线程（除开真正执行代码的线程），再启动时又会生成一个WebappClassloader实例来加载A类，如果热加载之前的那个A类的class对象还没有被回收的话，那么此时jvm中其实会存在两个A类的class对
象，这是不冲突，因为class对象的唯一标志是类加载器实例对象+类的全限定名。</p> <h3 id="热部署"><a href="#热部署" class="header-anchor">#</a> 热部署</h3> <p>BackgroundProcessor线程第六步会发出一个PERIODIC_EVENT事件，而HostConfig监听了此事件，当接收到此事件后就会执行热部署的检查与操作。</p> <p>对于一个文件夹部署的应用，通常会检查以下资源是否发生变动：</p> <ul><li>/tomcat-7/webapps/应用名.war</li> <li>/tomcat-7/webapps/应用名</li> <li>/tomcat-7/webapps/应用名/META-INF/context.xml</li> <li>/tomcat-7/conf/Catalina/localhost/应用名.xml</li> <li>/tomcat-7/conf/context.xml</li></ul> <p>对于一个War部署的应用，会检查以下资源是否发生变动：</p> <ul><li>/tomcat-7/webapps/应用名.war</li> <li>/tomcat-7/conf/Catalina/localhost/应用名.xml</li> <li>/tomcat-7/conf/context.xml</li></ul> <p>对于一个描述符部署的应用，会检查以下资源是否发生变动：</p> <ul><li>/tomcat-7/conf/Catalina/localhost/应用名.xml</li> <li>指定的DocBase目录</li> <li>/tomcat-7/conf/context.xml</li></ul> <p>一旦这些文件或目录发生了变化，就会触发热部署，当然热部署也是有开关的，在Host上，默认是开启
的。这里需要注意的是，对于一个目录是否发生了变化，Tomcat只判断了这个目录的修改时间是否发生了
变化，所以和热加载是不冲突的，因为热加载监听的是WEB-INF/classes和WEB-INF/lib目录，而热部
署监听的是应用名那一层的目录。</p> <p>在讲热部署的过程之前，我们要先讲一下应用部署的优先级，对于一个应用，我们可以在四个地方进行定
义：</p> <ol><li>server.xml中的context节点</li> <li>/tomcat-7/conf/Catalina/localhost/应用名.xml</li> <li>/tomcat-7/webapps/应用名.war</li> <li>/tomcat-7/webapps/应用名</li></ol> <p>优先级就是上面所列的顺序，意思是同一个应用名，如果你在这个四个地方都配置了，那么优先级低的将不起作用。因为Tomcat在部署一个应用的时候，会先查一下这个应用名是否已经被部署过了。热部署的过程：如果发生改变的是文件夹，比如/tomcat-7/webapps/应用名，那么不会做什么事情，只是会更新一下记录的修改时间，这是因为这个/tomcat-7/webapps/应用名目录下的文件，要么是jsp文件，要么是其他文件，而Tomcat只会管jsp文件，而对于jsp文件如果发生了修改，jsp自带的机制会处理修改的。</p> <p>如果发生改变的是/tomcat-7/conf/Catalina/localhost/应用名.xml文件，那么就是先undeploy，然后再deploy，和热加载其实类似。对于undeploy就不多说了，就是讲当前应用从host从移除，这就包括了当前应用的停止和销毁，然后还会从已部署列表中移除当前应用，然后调用deployApps()就可以重新部署应用了。</p> <h2 id="八、tomcat中关于session的实现"><a href="#八、tomcat中关于session的实现" class="header-anchor">#</a> 八、Tomcat中关于session的实现</h2> <h3 id="标准会话对象-standardsession"><a href="#标准会话对象-standardsession" class="header-anchor">#</a> 标准会话对象-StandardSession</h3> <ul><li>Session 接口定义了 Tomcat 内部用来操作会话的一些方法。</li> <li>Serializable 则是序列化接口，实现它是为了方便传输及持久化。</li> <li>HTTPSession 是 Servlet 规范中为会话操作而定义的一些方法，作为一个标准 Web 容器，实现它是
必然的。</li></ul> <p>一个最简单的标准会话应该包括 ID 和 Map&lt;String，Object&gt; 结构的属性。其中，ID 用于表示会话编
号，它必须是全局唯一的，属性用于存储会话相关信息，以 KV 结构存储。另外，它还应该包括会话创建
时间、事件监听器，并且提供 Web 层面访问的外观类等。</p> <h3 id="标准会话管理器-standardmanager"><a href="#标准会话管理器-standardmanager" class="header-anchor">#</a> 标准会话管理器-StandardManager</h3> <p>用于保存状态的会话对象已经有了，现在就需要一个管理器来管理所有会话。例如，会话 ID 生成，根据会
话 ID 找出对应的会话，对于过期的会话进行销毁等操作。用一句话描述标准会话管理器：提供一个专⻔管
理某个 Web 应用所有会话的容器，并且会在 Web 应用启动、停止时进行会话重加载和持久化。</p> <p>会话管理主要提供的功能包括会话 ID 生成器、后台处理（处理过期会话）、持久化模块及会话集的维护。
如下图所示，标准会话管理器包含了 SessionIdGenerator 组件、backgroundProcess 模块、持久化模
块以及会话集合。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618145938265.png" alt="image-20220618145938265"></p> <p>首先看 SessionIdGenerator，它负责为每个会话生成、分配一个唯一标识。例如，最终会生成类似
「326257DA6DB76F8D2E38F2C4540D1DEA」字符串的会话标识。具体的默认生成算法主要依靠 JDK
提供的 SHA1PRNG 算法。在集群环境中，为了方便识别会话归属，它最终生成的会话标识类似于
「326257DA6DB76F8D2E38F2C4540D1DEA.tomcat1」，后面会加上 Tomcat 的集群标识 jvmRoute
变量的值，这里假设其中一个集群标识配置为「tomcat1」。如果你想置换随机数生成算法，可以通过配
置 server.xml 的 Manager 节点 secureRandomAlgorithm 及 secureRandomClass 属性达到修改算法
的效果。</p> <p>然后看如何对过期会话进行处理。负责判断会话是否过期的逻辑主要在 backgroundProcess 模块
中，在 Tomcat 容器中会有一条线程专⻔用于执行后台处理。当然，也包括标准会话管理器的
backgroundProcess，它不断循环判断所有的会话中是否有过期的，一旦过期，则从会话集中删除此会
话。</p> <p>最后是关于持久化模块和会话集的维护。由于标准会话旨在提供一个简单便捷的管理器，因此持久化
和重加载操作并不会太灵活且扩展性弱，Tomcat 会在每个 StandardContext（Web 应用）停止时调用
管理器将属于此 Web 应用的所有会话持久化到磁盘中。文件名为 SESSIONS.ser，而目录路径则由
server.xml 的 Manager 节点 pathname 指定或 Javax.servlet. context.tempdir 变量指定，默认存放
路径为%CATALINA_HOME%/work/Catalina/localhost/ WebName/SESSIONS.ser。当 Web 应用启
动时，又会加载这些持久化的会话，加载完成后，SESSIONS.ser 文件将会被删除，所以每次启动成功后
就不会看到此文件的存在。另外，会话集的维护是指提供创建新会话对象、删除指定会话对象及更新会话
对象的功能。</p> <h2 id="九、spring-boot启动扫描servlet"><a href="#九、spring-boot启动扫描servlet" class="header-anchor">#</a> 九、Spring Boot启动扫描Servlet</h2> <ol><li>@ServletComponentScan负责扫描@WebServlet，每个Servlet对应一个
ServletContextInitializer(接口)，对应的实现类是ServletRegistrationBean</li> <li>SpringApplication.run(Application.class)里面会去创建一个
ServletWebServerApplicationContext，最终会调用该类的onRefresh方法</li> <li>调用createWebServer方法创建并启动Tomcat</li> <li>在创建的Tomcat的过程中会创建一个TomcatStarter，并且在创建TomcatStarter时将
ServletContextInitializer传进去，TomcatStarter实现了ServletContainerInitializer接口，该接口是Servlet规范中的接口</li> <li>启动Tomcat</li> <li>启动Tomcat后，Tomcat会负责调用TomcatStarter中的onStartup方法</li> <li>循环调用每个ServletContextInitializer的onStartup方法，并且把servletContext传给
ServletContextInitializer</li> <li>最终在ServletRegistrationBean中将ServletRegistrationBean对应的Servlet添加到servletContext
中</li></ol> <p>​</p> <h2 id="tomcat源码编译"><a href="#tomcat源码编译" class="header-anchor">#</a> Tomcat源码编译</h2> <p>链接：https://pan.baidu.com/s/1h_u8AuGojdHqwYsKS24YGw&amp;shfl=sharepset
提取码：hulx</p> <p>源码地址：https://gitee.com/archguide/tomcat</p> <h2 id="idea中运行tomcat-9源码"><a href="#idea中运行tomcat-9源码" class="header-anchor">#</a> IDEA中运行Tomcat 9源码</h2> <h3 id="使用idea从github上克隆源码"><a href="#使用idea从github上克隆源码" class="header-anchor">#</a> 使用IDEA从GITHUB上克隆源码</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150537834.png" alt="image-20220618150537834"></p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150556989.png" alt="image-20220618150556989"></p> <h3 id="源码克隆下来后-不能直接运行-需要用ant进行编译-主要目的是下载依赖"><a href="#源码克隆下来后-不能直接运行-需要用ant进行编译-主要目的是下载依赖" class="header-anchor">#</a> 源码克隆下来后，不能直接运行，需要用ant进行编译，主要目的是下载依赖</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150614452.png" alt="image-20220618150614452">
在用ant编译之前，建议先修改build.properties.default文件中的base.path的值，ant编译时需要去下载
第三方jar包，base.path将指定这些jar存放的位置。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150644143.png" alt="image-20220618150644143"></p> <p>修改完成后，在源码目录下使用命令行执行ant ide-intellij进行编译。执行命令后需要等待一段时间。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150659892.png" alt="image-20220618150659892"></p> <p>执行成功后在工程目录结构中多出一个文件夹，该文件夹保存了Tomcat源码所依赖的jar。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150720479.png" alt="image-20220618150720479"></p> <p>我们要把该文件夹下的jar加入到classpath中去，进入到Project Structure。把下载的依赖添加进来</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150739778.png" alt="image-20220618150739778"></p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150752587.png" alt="image-20220618150752587"></p> <h3 id="依赖添加进来后-可以尝试使用idea构建工程了。"><a href="#依赖添加进来后-可以尝试使用idea构建工程了。" class="header-anchor">#</a> 依赖添加进来后，可以尝试使用IDEA构建工程了。</h3> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150802817.png" alt="image-20220618150802817"></p> <p>构建过程中可能会报错，比如：</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150823352.png" alt="image-20220618150823352"></p> <p>该modules下的几个模块都是maven工程，右键pom.xml文件点击Add as Maven Project，点击后会自动下载依赖，从而解决构建报错，其他模块也类似。
对三个模块都下载依赖后，重新构建后，可能会报如下错误：</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150846554.png" alt="image-20220618150846554"></p> <p>提示ant包不存在，需要引入ant.jar的依赖，还是一样，打开Project Structure，选择tomcat Module，
添加依赖，将ant.jar添加进来，这里需要注意，Tomcat默认用的是ant-1.9.8.jar，所以可以提前把这个
jar下载在电脑上，然后引入此jar。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150904181.png" alt="image-20220618150904181"></p> <p>但是Apply的时候，会提示：</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150923203.png" alt="image-20220618150923203"></p> <p>这个我也不知道怎么办了...，解决办法是，将ant-1.9.8.jar保存在tomcat-build-jars文件夹下，然后右键
该jar，点击Add as Library。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150940612.png" alt="image-20220618150940612"></p> <p>点击ok，可以绕过刚刚的错误。重新构建，仍然会报错：</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618150955411.png" alt="image-20220618150955411"></p> <p>将@VERSION@改成9即可，再次重新构建，构建没有问题了。</p> <p>如果构建后没有报错，但是下图的这个Java文件中还是报红色，这应该是IDEA的问题，只需要手动的使用
IDEA的快捷提示重新import一下依赖即可。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151018694.png" alt="image-20220618151018694"></p> <h3 id="构建成功后-运行源代码。"><a href="#构建成功后-运行源代码。" class="header-anchor">#</a> 构建成功后，运行源代码。</h3> <p>Tomcat的启动类是org.apache.catalina.startup.Bootstrap类。直接运行此类中的Main方法可以看到
Tomcat的启动日志。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151033710.png" alt="image-20220618151033710"></p> <p>但是我的机器上有乱码，Tomcat做了国际化.
增加运行参数：-Duser.language=en。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151053393.png" alt="image-20220618151053393"></p> <p>增加之后再运行就没有问题了。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151103095.png" alt="image-20220618151103095"></p> <p>但是此时访问localhost:8080，仍然会报错，看不到我们想看到的熟悉的Tomcat欢迎⻚</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151116901.png" alt="image-20220618151116901"></p> <p>这是因为Tomcat内部使用了SPI机制来初始化jsp相关的东⻄，手动运行源码的过程中默认不会去初始化
jsp相关。</p> <p>我们找到</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151140467.png" alt="image-20220618151140467"></p> <p>在工程目录下新建resouces文件夹，然后新建META-INF文件夹，然后将上图中的services文件夹复制到
META-INF文件中，最后将resources文件夹加入到classpath中。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151155039.png" alt="image-20220618151155039"></p> <p>重新运行Bootstrap，访问正常。</p> <p><img src="https://gitee.com/nylg/picture/raw/master/spring/image-20220618151207033.png" alt="image-20220618151207033"></p> <p>​</p></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/06/23, 19:19:48</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/6770e0/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">JVM调优实战及常量池详解</div></a> <a href="/pages/75f963/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">MySQL的内部组件结构</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/6770e0/" class="prev">JVM调优实战及常量池详解</a></span> <span class="next"><a href="/pages/75f963/">MySQL的内部组件结构</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/80365f/"><div>
            证券市场基本法律法规
            <!----></div></a> <span class="date">03-13</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/d9e4f4/"><div>
            证券考试规则
            <!----></div></a> <span class="date">03-12</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/cb2c17/"><div>
            金融市场基础知识
            <!----></div></a> <span class="date">03-12</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:cloudjava@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/bigdatajava" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://gitee.com/nylg" title="Gitee" target="_blank" class="iconfont icon-gitee"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2014-2024
    <span>wen chao | <a href="https://github.com/bigdatajava/blog-talk/blob/main/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.b2807c2b.js" defer></script><script src="/assets/js/2.eeaab5de.js" defer></script><script src="/assets/js/193.415828fe.js" defer></script>
  </body>
</html>
