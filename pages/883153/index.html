<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring IOC | wen chao</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3129839_xft6cqs5gc.css">
    <meta name="description" content="架构进阶之路...">
    <meta name="keywords" content="全栈博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,js,ES6,TypeScript,vue">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.877370ef.css" as="style"><link rel="preload" href="/assets/js/app.af2629f3.js" as="script"><link rel="preload" href="/assets/js/2.c7acc05c.js" as="script"><link rel="preload" href="/assets/js/216.d76003a4.js" as="script"><link rel="prefetch" href="/assets/js/10.003809e3.js"><link rel="prefetch" href="/assets/js/100.05e6d7b0.js"><link rel="prefetch" href="/assets/js/101.aedcfb99.js"><link rel="prefetch" href="/assets/js/102.0f45ef0b.js"><link rel="prefetch" href="/assets/js/103.f6349067.js"><link rel="prefetch" href="/assets/js/104.159e4fea.js"><link rel="prefetch" href="/assets/js/105.cf376772.js"><link rel="prefetch" href="/assets/js/106.4a24f110.js"><link rel="prefetch" href="/assets/js/107.9130a4fc.js"><link rel="prefetch" href="/assets/js/108.557f1de3.js"><link rel="prefetch" href="/assets/js/109.0eae2c98.js"><link rel="prefetch" href="/assets/js/11.46d1f704.js"><link rel="prefetch" href="/assets/js/110.be00b9ae.js"><link rel="prefetch" href="/assets/js/111.454bc20b.js"><link rel="prefetch" href="/assets/js/112.c987bc96.js"><link rel="prefetch" href="/assets/js/113.f07c8b3c.js"><link rel="prefetch" href="/assets/js/114.ab099d7d.js"><link rel="prefetch" href="/assets/js/115.a5bda3c7.js"><link rel="prefetch" href="/assets/js/116.eb280ad8.js"><link rel="prefetch" href="/assets/js/117.1863722f.js"><link rel="prefetch" href="/assets/js/118.3f192a2d.js"><link rel="prefetch" href="/assets/js/119.66b89deb.js"><link rel="prefetch" href="/assets/js/12.03486813.js"><link rel="prefetch" href="/assets/js/120.69b1d465.js"><link rel="prefetch" href="/assets/js/121.113b1b5a.js"><link rel="prefetch" href="/assets/js/122.917086b7.js"><link rel="prefetch" href="/assets/js/123.ef1b72cd.js"><link rel="prefetch" href="/assets/js/124.a52fd442.js"><link rel="prefetch" href="/assets/js/125.65cf0d15.js"><link rel="prefetch" href="/assets/js/126.9257bcef.js"><link rel="prefetch" href="/assets/js/127.c080527e.js"><link rel="prefetch" href="/assets/js/128.90389431.js"><link rel="prefetch" href="/assets/js/129.582bff3e.js"><link rel="prefetch" href="/assets/js/13.ba8e34d1.js"><link rel="prefetch" href="/assets/js/130.fb170212.js"><link rel="prefetch" href="/assets/js/131.ed138ac9.js"><link rel="prefetch" href="/assets/js/132.4223d6f9.js"><link rel="prefetch" href="/assets/js/133.012411be.js"><link rel="prefetch" href="/assets/js/134.ed98c78a.js"><link rel="prefetch" href="/assets/js/135.2b6eb13f.js"><link rel="prefetch" href="/assets/js/136.65149943.js"><link rel="prefetch" href="/assets/js/137.341d7363.js"><link rel="prefetch" href="/assets/js/138.e9834544.js"><link rel="prefetch" href="/assets/js/139.ff517435.js"><link rel="prefetch" href="/assets/js/14.71b2ed4a.js"><link rel="prefetch" href="/assets/js/140.bf2b9d2d.js"><link rel="prefetch" href="/assets/js/141.ef8d876a.js"><link rel="prefetch" href="/assets/js/142.c28e6ef9.js"><link rel="prefetch" href="/assets/js/143.d0b43d89.js"><link rel="prefetch" href="/assets/js/144.9545dbb1.js"><link rel="prefetch" href="/assets/js/145.c5c5aca2.js"><link rel="prefetch" href="/assets/js/146.c6989cd8.js"><link rel="prefetch" href="/assets/js/147.fe16ad8a.js"><link rel="prefetch" href="/assets/js/148.102ea00d.js"><link rel="prefetch" href="/assets/js/149.2e62b9d1.js"><link rel="prefetch" href="/assets/js/15.1736a531.js"><link rel="prefetch" href="/assets/js/150.daf684ac.js"><link rel="prefetch" href="/assets/js/151.988a3ba9.js"><link rel="prefetch" href="/assets/js/152.4742bb74.js"><link rel="prefetch" href="/assets/js/153.02bcce99.js"><link rel="prefetch" href="/assets/js/154.ebde7923.js"><link rel="prefetch" href="/assets/js/155.c906862e.js"><link rel="prefetch" href="/assets/js/156.3b3d94d4.js"><link rel="prefetch" href="/assets/js/157.81d8c740.js"><link rel="prefetch" href="/assets/js/158.40095645.js"><link rel="prefetch" href="/assets/js/159.2abc32c5.js"><link rel="prefetch" href="/assets/js/16.fb9d3b9b.js"><link rel="prefetch" href="/assets/js/160.dfa13df3.js"><link rel="prefetch" href="/assets/js/161.5697eb79.js"><link rel="prefetch" href="/assets/js/162.fef5ab87.js"><link rel="prefetch" href="/assets/js/163.8b3dff03.js"><link rel="prefetch" href="/assets/js/164.826228d2.js"><link rel="prefetch" href="/assets/js/165.e0099d56.js"><link rel="prefetch" href="/assets/js/166.8294f6c0.js"><link rel="prefetch" href="/assets/js/167.d07b77dd.js"><link rel="prefetch" href="/assets/js/168.c23c0d7b.js"><link rel="prefetch" href="/assets/js/169.c7f7599b.js"><link rel="prefetch" href="/assets/js/17.e42188aa.js"><link rel="prefetch" href="/assets/js/170.b11ea482.js"><link rel="prefetch" href="/assets/js/171.73278046.js"><link rel="prefetch" href="/assets/js/172.040cd7fc.js"><link rel="prefetch" href="/assets/js/173.e0199ce5.js"><link rel="prefetch" href="/assets/js/174.3010733d.js"><link rel="prefetch" href="/assets/js/175.05c196ea.js"><link rel="prefetch" href="/assets/js/176.c490fc2b.js"><link rel="prefetch" href="/assets/js/177.7bcb888a.js"><link rel="prefetch" href="/assets/js/178.34093cd3.js"><link rel="prefetch" href="/assets/js/179.b2413571.js"><link rel="prefetch" href="/assets/js/18.383f6a09.js"><link rel="prefetch" href="/assets/js/180.9648ec05.js"><link rel="prefetch" href="/assets/js/181.342f0059.js"><link rel="prefetch" href="/assets/js/182.35eac70e.js"><link rel="prefetch" href="/assets/js/183.f4a83742.js"><link rel="prefetch" href="/assets/js/184.d82b8a96.js"><link rel="prefetch" href="/assets/js/185.9f5f32ef.js"><link rel="prefetch" href="/assets/js/186.600a4950.js"><link rel="prefetch" href="/assets/js/187.df953d4f.js"><link rel="prefetch" href="/assets/js/188.2491fa83.js"><link rel="prefetch" href="/assets/js/189.32d3c1a4.js"><link rel="prefetch" href="/assets/js/19.cb72d9a9.js"><link rel="prefetch" href="/assets/js/190.39ac92fc.js"><link rel="prefetch" href="/assets/js/191.3125fa77.js"><link rel="prefetch" href="/assets/js/192.7655632a.js"><link rel="prefetch" href="/assets/js/193.7f55a678.js"><link rel="prefetch" href="/assets/js/194.b9c56642.js"><link rel="prefetch" href="/assets/js/195.189fe681.js"><link rel="prefetch" href="/assets/js/196.71658166.js"><link rel="prefetch" href="/assets/js/197.af445c6a.js"><link rel="prefetch" href="/assets/js/198.1de2afd9.js"><link rel="prefetch" href="/assets/js/199.2c218726.js"><link rel="prefetch" href="/assets/js/20.0e9f2f72.js"><link rel="prefetch" href="/assets/js/200.26590f9f.js"><link rel="prefetch" href="/assets/js/201.36d7a8ea.js"><link rel="prefetch" href="/assets/js/202.6c36d934.js"><link rel="prefetch" href="/assets/js/203.d4ae9b00.js"><link rel="prefetch" href="/assets/js/204.c3b2f994.js"><link rel="prefetch" href="/assets/js/205.f480166b.js"><link rel="prefetch" href="/assets/js/206.90dc53ae.js"><link rel="prefetch" href="/assets/js/207.f959801b.js"><link rel="prefetch" href="/assets/js/208.5da4dac0.js"><link rel="prefetch" href="/assets/js/209.217e41a9.js"><link rel="prefetch" href="/assets/js/21.7a7c5c4f.js"><link rel="prefetch" href="/assets/js/210.fb1d985a.js"><link rel="prefetch" href="/assets/js/211.5a3d515c.js"><link rel="prefetch" href="/assets/js/212.bb654f9b.js"><link rel="prefetch" href="/assets/js/213.b8f5ac66.js"><link rel="prefetch" href="/assets/js/214.cfb1547f.js"><link rel="prefetch" href="/assets/js/215.a1de2fe7.js"><link rel="prefetch" href="/assets/js/217.ad201174.js"><link rel="prefetch" href="/assets/js/218.5adcad1a.js"><link rel="prefetch" href="/assets/js/219.9f3b9b01.js"><link rel="prefetch" href="/assets/js/22.b9540503.js"><link rel="prefetch" href="/assets/js/220.af64e5ad.js"><link rel="prefetch" href="/assets/js/221.379beb37.js"><link rel="prefetch" href="/assets/js/222.85aa5cd0.js"><link rel="prefetch" href="/assets/js/223.13475fe5.js"><link rel="prefetch" href="/assets/js/224.d06abfcb.js"><link rel="prefetch" href="/assets/js/225.1f738876.js"><link rel="prefetch" href="/assets/js/226.a09031a1.js"><link rel="prefetch" href="/assets/js/227.f6018b9a.js"><link rel="prefetch" href="/assets/js/228.ae3296e4.js"><link rel="prefetch" href="/assets/js/229.d9bcea85.js"><link rel="prefetch" href="/assets/js/23.6b5fd8ae.js"><link rel="prefetch" href="/assets/js/230.68a89532.js"><link rel="prefetch" href="/assets/js/231.b31aa02f.js"><link rel="prefetch" href="/assets/js/232.cc07d501.js"><link rel="prefetch" href="/assets/js/233.76443c50.js"><link rel="prefetch" href="/assets/js/234.5efbcd6a.js"><link rel="prefetch" href="/assets/js/235.dfcf36cf.js"><link rel="prefetch" href="/assets/js/236.4bb99856.js"><link rel="prefetch" href="/assets/js/237.79a22c20.js"><link rel="prefetch" href="/assets/js/238.1b592be7.js"><link rel="prefetch" href="/assets/js/239.a4c119aa.js"><link rel="prefetch" href="/assets/js/24.63372db7.js"><link rel="prefetch" href="/assets/js/240.22d7d47a.js"><link rel="prefetch" href="/assets/js/241.36336698.js"><link rel="prefetch" href="/assets/js/242.b7db4d20.js"><link rel="prefetch" href="/assets/js/243.f156bf47.js"><link rel="prefetch" href="/assets/js/244.14f3046b.js"><link rel="prefetch" href="/assets/js/245.984447ea.js"><link rel="prefetch" href="/assets/js/246.cd55bf13.js"><link rel="prefetch" href="/assets/js/247.d2a77b3d.js"><link rel="prefetch" href="/assets/js/248.c23e38fd.js"><link rel="prefetch" href="/assets/js/249.a0b42d1f.js"><link rel="prefetch" href="/assets/js/25.d3f99e2a.js"><link rel="prefetch" href="/assets/js/250.870b2e9a.js"><link rel="prefetch" href="/assets/js/251.ee8edd7f.js"><link rel="prefetch" href="/assets/js/252.15e2c05e.js"><link rel="prefetch" href="/assets/js/253.18d0fc46.js"><link rel="prefetch" href="/assets/js/254.39ecf5f7.js"><link rel="prefetch" href="/assets/js/255.d42ae6e7.js"><link rel="prefetch" href="/assets/js/256.5a2b4630.js"><link rel="prefetch" href="/assets/js/257.df147154.js"><link rel="prefetch" href="/assets/js/258.f42bcf46.js"><link rel="prefetch" href="/assets/js/259.022f92f9.js"><link rel="prefetch" href="/assets/js/26.c6b54266.js"><link rel="prefetch" href="/assets/js/260.abb07bf2.js"><link rel="prefetch" href="/assets/js/261.74b1bebb.js"><link rel="prefetch" href="/assets/js/262.680edf56.js"><link rel="prefetch" href="/assets/js/263.0cdbe35a.js"><link rel="prefetch" href="/assets/js/264.ea699edd.js"><link rel="prefetch" href="/assets/js/265.cf168b25.js"><link rel="prefetch" href="/assets/js/266.18f03883.js"><link rel="prefetch" href="/assets/js/267.007dcd30.js"><link rel="prefetch" href="/assets/js/268.41de028b.js"><link rel="prefetch" href="/assets/js/269.e206560c.js"><link rel="prefetch" href="/assets/js/27.120b6069.js"><link rel="prefetch" href="/assets/js/270.164398a3.js"><link rel="prefetch" href="/assets/js/271.7d100757.js"><link rel="prefetch" href="/assets/js/272.0b83e5d3.js"><link rel="prefetch" href="/assets/js/273.f317bcb6.js"><link rel="prefetch" href="/assets/js/274.2947d9f0.js"><link rel="prefetch" href="/assets/js/275.e99b65f2.js"><link rel="prefetch" href="/assets/js/276.ea03cf89.js"><link rel="prefetch" href="/assets/js/277.93476fbc.js"><link rel="prefetch" href="/assets/js/278.db0ff8eb.js"><link rel="prefetch" href="/assets/js/279.b36007aa.js"><link rel="prefetch" href="/assets/js/28.91595b48.js"><link rel="prefetch" href="/assets/js/280.14723ae7.js"><link rel="prefetch" href="/assets/js/281.f27b79de.js"><link rel="prefetch" href="/assets/js/282.718708d7.js"><link rel="prefetch" href="/assets/js/283.f91a771c.js"><link rel="prefetch" href="/assets/js/284.25b1d4f7.js"><link rel="prefetch" href="/assets/js/285.a641722b.js"><link rel="prefetch" href="/assets/js/286.9d2d85fb.js"><link rel="prefetch" href="/assets/js/287.a8a0d7a2.js"><link rel="prefetch" href="/assets/js/288.ee27e2fe.js"><link rel="prefetch" href="/assets/js/289.e4300193.js"><link rel="prefetch" href="/assets/js/29.a5ef89d9.js"><link rel="prefetch" href="/assets/js/290.ba445f12.js"><link rel="prefetch" href="/assets/js/291.7a767d85.js"><link rel="prefetch" href="/assets/js/292.aa96cc76.js"><link rel="prefetch" href="/assets/js/293.e18d36c6.js"><link rel="prefetch" href="/assets/js/294.7113dff7.js"><link rel="prefetch" href="/assets/js/295.abae5e0e.js"><link rel="prefetch" href="/assets/js/296.010241c4.js"><link rel="prefetch" href="/assets/js/297.4bbe88fd.js"><link rel="prefetch" href="/assets/js/298.9f291f83.js"><link rel="prefetch" href="/assets/js/299.bf9e031a.js"><link rel="prefetch" href="/assets/js/3.1403d3ee.js"><link rel="prefetch" href="/assets/js/30.3bb57e98.js"><link rel="prefetch" href="/assets/js/300.fc58f3c4.js"><link rel="prefetch" href="/assets/js/301.69cd291f.js"><link rel="prefetch" href="/assets/js/302.c34ca8e9.js"><link rel="prefetch" href="/assets/js/303.25655f40.js"><link rel="prefetch" href="/assets/js/304.97a8e358.js"><link rel="prefetch" href="/assets/js/305.1c5e713f.js"><link rel="prefetch" href="/assets/js/306.b53f2ea6.js"><link rel="prefetch" href="/assets/js/307.e4a9a150.js"><link rel="prefetch" href="/assets/js/308.92931c17.js"><link rel="prefetch" href="/assets/js/309.6e452bde.js"><link rel="prefetch" href="/assets/js/31.f1ddaeee.js"><link rel="prefetch" href="/assets/js/310.6abc9668.js"><link rel="prefetch" href="/assets/js/311.1bd77809.js"><link rel="prefetch" href="/assets/js/312.78b7405d.js"><link rel="prefetch" href="/assets/js/313.3b23ded5.js"><link rel="prefetch" href="/assets/js/314.ae150cf1.js"><link rel="prefetch" href="/assets/js/315.d375ed9c.js"><link rel="prefetch" href="/assets/js/316.c8a05987.js"><link rel="prefetch" href="/assets/js/317.febd6c4f.js"><link rel="prefetch" href="/assets/js/318.34fe4d11.js"><link rel="prefetch" href="/assets/js/319.5b558d88.js"><link rel="prefetch" href="/assets/js/32.8019bc57.js"><link rel="prefetch" href="/assets/js/320.af89e963.js"><link rel="prefetch" href="/assets/js/321.f646b641.js"><link rel="prefetch" href="/assets/js/322.897f28f1.js"><link rel="prefetch" href="/assets/js/323.38229c39.js"><link rel="prefetch" href="/assets/js/324.7baf2418.js"><link rel="prefetch" href="/assets/js/325.e0225366.js"><link rel="prefetch" href="/assets/js/326.e30b69cd.js"><link rel="prefetch" href="/assets/js/327.6774c791.js"><link rel="prefetch" href="/assets/js/328.58239b5d.js"><link rel="prefetch" href="/assets/js/329.570eb01e.js"><link rel="prefetch" href="/assets/js/33.2009be2a.js"><link rel="prefetch" href="/assets/js/330.6c29d590.js"><link rel="prefetch" href="/assets/js/331.bbe673f1.js"><link rel="prefetch" href="/assets/js/332.6d2bbedd.js"><link rel="prefetch" href="/assets/js/333.7e60b6bd.js"><link rel="prefetch" href="/assets/js/334.9f9ea9bb.js"><link rel="prefetch" href="/assets/js/335.0f60cf92.js"><link rel="prefetch" href="/assets/js/336.3981edeb.js"><link rel="prefetch" href="/assets/js/337.0ca91dae.js"><link rel="prefetch" href="/assets/js/338.09e14c30.js"><link rel="prefetch" href="/assets/js/339.31147ffa.js"><link rel="prefetch" href="/assets/js/34.f4ffaa4e.js"><link rel="prefetch" href="/assets/js/340.b216b6b7.js"><link rel="prefetch" href="/assets/js/341.7af949b2.js"><link rel="prefetch" href="/assets/js/342.03e80905.js"><link rel="prefetch" href="/assets/js/343.147ff16c.js"><link rel="prefetch" href="/assets/js/344.c95f6de9.js"><link rel="prefetch" href="/assets/js/345.7cc8cfaa.js"><link rel="prefetch" href="/assets/js/346.d5ff42a4.js"><link rel="prefetch" href="/assets/js/347.f1f1478f.js"><link rel="prefetch" href="/assets/js/348.32ea340f.js"><link rel="prefetch" href="/assets/js/349.4d743984.js"><link rel="prefetch" href="/assets/js/35.6f997bc2.js"><link rel="prefetch" href="/assets/js/350.c218cb98.js"><link rel="prefetch" href="/assets/js/351.a6f08d8b.js"><link rel="prefetch" href="/assets/js/352.46538632.js"><link rel="prefetch" href="/assets/js/353.6702d9ff.js"><link rel="prefetch" href="/assets/js/354.10264327.js"><link rel="prefetch" href="/assets/js/355.bc66e304.js"><link rel="prefetch" href="/assets/js/356.36d9208c.js"><link rel="prefetch" href="/assets/js/357.708af07a.js"><link rel="prefetch" href="/assets/js/358.61ab6834.js"><link rel="prefetch" href="/assets/js/359.bb4ad887.js"><link rel="prefetch" href="/assets/js/36.5172c464.js"><link rel="prefetch" href="/assets/js/360.9ae57e7b.js"><link rel="prefetch" href="/assets/js/37.72aa4947.js"><link rel="prefetch" href="/assets/js/38.77129de5.js"><link rel="prefetch" href="/assets/js/39.01d84c7e.js"><link rel="prefetch" href="/assets/js/4.5517c98c.js"><link rel="prefetch" href="/assets/js/40.b2fb57bd.js"><link rel="prefetch" href="/assets/js/41.fa63fb49.js"><link rel="prefetch" href="/assets/js/42.c68fd691.js"><link rel="prefetch" href="/assets/js/43.071af6f3.js"><link rel="prefetch" href="/assets/js/44.99321348.js"><link rel="prefetch" href="/assets/js/45.4c105e24.js"><link rel="prefetch" href="/assets/js/46.91a5aa2c.js"><link rel="prefetch" href="/assets/js/47.18bd4930.js"><link rel="prefetch" href="/assets/js/48.deef5f67.js"><link rel="prefetch" href="/assets/js/49.12c80dd9.js"><link rel="prefetch" href="/assets/js/5.6b7a7b35.js"><link rel="prefetch" href="/assets/js/50.259ff32b.js"><link rel="prefetch" href="/assets/js/51.ee83db82.js"><link rel="prefetch" href="/assets/js/52.1cf54e16.js"><link rel="prefetch" href="/assets/js/53.821dd297.js"><link rel="prefetch" href="/assets/js/54.bf29c9d1.js"><link rel="prefetch" href="/assets/js/55.25e00784.js"><link rel="prefetch" href="/assets/js/56.b1112045.js"><link rel="prefetch" href="/assets/js/57.5923ed3a.js"><link rel="prefetch" href="/assets/js/58.ee7fa86f.js"><link rel="prefetch" href="/assets/js/59.7b9800f0.js"><link rel="prefetch" href="/assets/js/6.207c7bac.js"><link rel="prefetch" href="/assets/js/60.ca146265.js"><link rel="prefetch" href="/assets/js/61.77a27075.js"><link rel="prefetch" href="/assets/js/62.2839e098.js"><link rel="prefetch" href="/assets/js/63.6c8cdea8.js"><link rel="prefetch" href="/assets/js/64.1a5f538c.js"><link rel="prefetch" href="/assets/js/65.a3708a3e.js"><link rel="prefetch" href="/assets/js/66.63a1d86b.js"><link rel="prefetch" href="/assets/js/67.5563ad9d.js"><link rel="prefetch" href="/assets/js/68.182b4324.js"><link rel="prefetch" href="/assets/js/69.b695215c.js"><link rel="prefetch" href="/assets/js/7.00b0f0bb.js"><link rel="prefetch" href="/assets/js/70.819c0991.js"><link rel="prefetch" href="/assets/js/71.534cf941.js"><link rel="prefetch" href="/assets/js/72.b3c641ef.js"><link rel="prefetch" href="/assets/js/73.e613a0d5.js"><link rel="prefetch" href="/assets/js/74.d7fc07e0.js"><link rel="prefetch" href="/assets/js/75.d50101e4.js"><link rel="prefetch" href="/assets/js/76.18e7ac7b.js"><link rel="prefetch" href="/assets/js/77.bb898521.js"><link rel="prefetch" href="/assets/js/78.a08d2106.js"><link rel="prefetch" href="/assets/js/79.0f362a00.js"><link rel="prefetch" href="/assets/js/8.197a9ad8.js"><link rel="prefetch" href="/assets/js/80.8b74cf4c.js"><link rel="prefetch" href="/assets/js/81.3e8c87af.js"><link rel="prefetch" href="/assets/js/82.83cb55b7.js"><link rel="prefetch" href="/assets/js/83.7355f968.js"><link rel="prefetch" href="/assets/js/84.51061851.js"><link rel="prefetch" href="/assets/js/85.b5df8911.js"><link rel="prefetch" href="/assets/js/86.baf2296e.js"><link rel="prefetch" href="/assets/js/87.2e9ae95d.js"><link rel="prefetch" href="/assets/js/88.57a8401a.js"><link rel="prefetch" href="/assets/js/89.a0d99eba.js"><link rel="prefetch" href="/assets/js/9.53a0556a.js"><link rel="prefetch" href="/assets/js/90.6121d367.js"><link rel="prefetch" href="/assets/js/91.56f285e2.js"><link rel="prefetch" href="/assets/js/92.7d7c0428.js"><link rel="prefetch" href="/assets/js/93.17841bd6.js"><link rel="prefetch" href="/assets/js/94.832fcc1c.js"><link rel="prefetch" href="/assets/js/95.e9c523bc.js"><link rel="prefetch" href="/assets/js/96.d8aae52a.js"><link rel="prefetch" href="/assets/js/97.bd436fab.js"><link rel="prefetch" href="/assets/js/98.78f6e4f3.js"><link rel="prefetch" href="/assets/js/99.a405fc1f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.877370ef.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="wen chao" class="logo"> <span class="site-name can-hide">wen chao</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Algorithm" class="dropdown-title"><a href="/Algorithm/" class="link-title">Algorithm</a> <span class="title" style="display:none;">Algorithm</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d8e764/" class="nav-link">Theory</a></li><li class="dropdown-item"><!----> <a href="/pages/81a4bd/" class="nav-link">LeetCode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><a href="/Spring/" class="link-title">Spring</a> <span class="title" style="display:none;">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/373439/" class="nav-link">Spring</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Technology" class="dropdown-title"><a href="/Technology/" class="link-title">Technology</a> <span class="title" style="display:none;">Technology</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/3b6841/" class="nav-link">DB</a></li><li class="dropdown-item"><!----> <a href="/pages/d7857e/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b89362/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/ec8b81/" class="nav-link">MongoDB</a></li><li class="dropdown-item"><!----> <a href="/pages/4e3ff1/" class="nav-link">Zookeeper</a></li><li class="dropdown-item"><!----> <a href="/pages/a75fef/" class="nav-link">MQ</a></li><li class="dropdown-item"><!----> <a href="/pages/b194d7/" class="nav-link">Dubbo</a></li><li class="dropdown-item"><!----> <a href="/pages/371f2f/" class="nav-link">ElasticSearch</a></li><li class="dropdown-item"><!----> <a href="/pages/027aa3/" class="nav-link">Workflow</a></li><li class="dropdown-item"><!----> <a href="/pages/73ab4b/" class="nav-link">OAuth2</a></li><li class="dropdown-item"><!----> <a href="/pages/d7a38a/" class="nav-link">JPA</a></li><li class="dropdown-item"><!----> <a href="/pages/eb5dc1/" class="nav-link">Liquibase</a></li><li class="dropdown-item"><!----> <a href="/pages/e54277/" class="nav-link">Lombok</a></li><li class="dropdown-item"><!----> <a href="/pages/62e4f6/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/13c836/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/pages/b50b3d/" class="nav-link">Mini Program</a></li><li class="dropdown-item"><!----> <a href="/pages/09d3b8/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/pages/a526c7/" class="nav-link">Log</a></li><li class="dropdown-item"><!----> <a href="/pages/59cf4f/" class="nav-link">JDK</a></li><li class="dropdown-item"><!----> <a href="/pages/d50dab/" class="nav-link">Thymeleaf</a></li><li class="dropdown-item"><!----> <a href="/pages/97abaa/" class="nav-link">Maven</a></li><li class="dropdown-item"><!----> <a href="/pages/7879f1/" class="nav-link">Mybatis</a></li><li class="dropdown-item"><!----> <a href="/pages/745b7c/" class="nav-link">Network</a></li><li class="dropdown-item"><!----> <a href="/pages/274dac/" class="nav-link">Raspberrypi</a></li><li class="dropdown-item"><!----> <a href="/pages/87c097/" class="nav-link">Node</a></li><li class="dropdown-item"><!----> <a href="/pages/927664/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/2c3f19/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Other" class="dropdown-title"><a href="/Other/" class="link-title">Other</a> <span class="title" style="display:none;">Other</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/fea344/" class="nav-link">Book</a></li><li class="dropdown-item"><!----> <a href="/pages/d62f72/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/f3d338/" class="nav-link">问题</a></li><li class="dropdown-item"><!----> <a href="/pages/ff202b/" class="nav-link">友链</a></li><li class="dropdown-item"><!----> <a href="/pages/2b746e/" class="nav-link">证券</a></li></ul></div></div><div class="nav-item"><a href="/About/" class="nav-link">About</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Index" class="dropdown-title"><a href="/archives/" class="link-title">Index</a> <span class="title" style="display:none;">Index</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/touxiang-lanse.png"> <div class="blogger-info"><h3>wen chao</h3> <span>持之以恒做正确有价值的事!</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Algorithm" class="dropdown-title"><a href="/Algorithm/" class="link-title">Algorithm</a> <span class="title" style="display:none;">Algorithm</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d8e764/" class="nav-link">Theory</a></li><li class="dropdown-item"><!----> <a href="/pages/81a4bd/" class="nav-link">LeetCode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><a href="/Spring/" class="link-title">Spring</a> <span class="title" style="display:none;">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/373439/" class="nav-link">Spring</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Technology" class="dropdown-title"><a href="/Technology/" class="link-title">Technology</a> <span class="title" style="display:none;">Technology</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/3b6841/" class="nav-link">DB</a></li><li class="dropdown-item"><!----> <a href="/pages/d7857e/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b89362/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/ec8b81/" class="nav-link">MongoDB</a></li><li class="dropdown-item"><!----> <a href="/pages/4e3ff1/" class="nav-link">Zookeeper</a></li><li class="dropdown-item"><!----> <a href="/pages/a75fef/" class="nav-link">MQ</a></li><li class="dropdown-item"><!----> <a href="/pages/b194d7/" class="nav-link">Dubbo</a></li><li class="dropdown-item"><!----> <a href="/pages/371f2f/" class="nav-link">ElasticSearch</a></li><li class="dropdown-item"><!----> <a href="/pages/027aa3/" class="nav-link">Workflow</a></li><li class="dropdown-item"><!----> <a href="/pages/73ab4b/" class="nav-link">OAuth2</a></li><li class="dropdown-item"><!----> <a href="/pages/d7a38a/" class="nav-link">JPA</a></li><li class="dropdown-item"><!----> <a href="/pages/eb5dc1/" class="nav-link">Liquibase</a></li><li class="dropdown-item"><!----> <a href="/pages/e54277/" class="nav-link">Lombok</a></li><li class="dropdown-item"><!----> <a href="/pages/62e4f6/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/13c836/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/pages/b50b3d/" class="nav-link">Mini Program</a></li><li class="dropdown-item"><!----> <a href="/pages/09d3b8/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/pages/a526c7/" class="nav-link">Log</a></li><li class="dropdown-item"><!----> <a href="/pages/59cf4f/" class="nav-link">JDK</a></li><li class="dropdown-item"><!----> <a href="/pages/d50dab/" class="nav-link">Thymeleaf</a></li><li class="dropdown-item"><!----> <a href="/pages/97abaa/" class="nav-link">Maven</a></li><li class="dropdown-item"><!----> <a href="/pages/7879f1/" class="nav-link">Mybatis</a></li><li class="dropdown-item"><!----> <a href="/pages/745b7c/" class="nav-link">Network</a></li><li class="dropdown-item"><!----> <a href="/pages/274dac/" class="nav-link">Raspberrypi</a></li><li class="dropdown-item"><!----> <a href="/pages/87c097/" class="nav-link">Node</a></li><li class="dropdown-item"><!----> <a href="/pages/927664/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/2c3f19/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Other" class="dropdown-title"><a href="/Other/" class="link-title">Other</a> <span class="title" style="display:none;">Other</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/fea344/" class="nav-link">Book</a></li><li class="dropdown-item"><!----> <a href="/pages/d62f72/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/f3d338/" class="nav-link">问题</a></li><li class="dropdown-item"><!----> <a href="/pages/ff202b/" class="nav-link">友链</a></li><li class="dropdown-item"><!----> <a href="/pages/2b746e/" class="nav-link">证券</a></li></ul></div></div><div class="nav-item"><a href="/About/" class="nav-link">About</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Index" class="dropdown-title"><a href="/archives/" class="link-title">Index</a> <span class="title" style="display:none;">Index</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Book</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>性能调优专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>并发编程专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>源码框架专题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/6f13ef/" class="sidebar-link">Spring源码</a></li><li><a href="/pages/615c1c/" class="sidebar-link">Spring核心API</a></li><li><a href="/pages/883153/" aria-current="page" class="active sidebar-link">Spring IOC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/883153/#ioc-详解" class="sidebar-link">IOC 详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/883153/#ioc体系" class="sidebar-link">IOC体系</a></li><li class="sidebar-sub-header level3"><a href="/pages/883153/#ioc加载流程图" class="sidebar-link">IOC加载流程图</a></li><li class="sidebar-sub-header level3"><a href="/pages/883153/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level3"><a href="/pages/883153/#spring-ioc容器的加载过程" class="sidebar-link">Spring IoC容器的加载过程</a></li><li class="sidebar-sub-header level4"><a href="/pages/883153/#_1-实例化化容器-annotationconfigapplicationcontext" class="sidebar-link">1.实例化化容器：AnnotationConfigApplicationContext ：</a></li><li class="sidebar-sub-header level4"><a href="/pages/883153/#_2-实例化工厂-defaultlistablebeanfactory" class="sidebar-link">2.实例化工厂：DefaultListableBeanFactory</a></li><li class="sidebar-sub-header level4"><a href="/pages/883153/#_3-实例化建beandefinition读取器-annotatedbeandefinitionreader" class="sidebar-link">3.实例化建BeanDefinition读取器： AnnotatedBeanDefinitionReader：</a></li><li class="sidebar-sub-header level4"><a href="/pages/883153/#_4-创建beandefinition扫描器-classpathbeandefinitionscanner" class="sidebar-link">4.创建BeanDefinition扫描器:ClassPathBeanDefinitionScanner</a></li><li class="sidebar-sub-header level4"><a href="/pages/883153/#_5-注册配置类为beandefinition-register-annotatedclasses" class="sidebar-link">5.注册配置类为BeanDefinition： register(annotatedClasses);</a></li><li class="sidebar-sub-header level4"><a href="/pages/883153/#_6-refresh" class="sidebar-link">6. refresh()</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-1-preparerefresh" class="sidebar-link">6.1 prepareRefresh</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-2-configurablelistablebeanfactory-beanfactory-obtainfreshbeanfactory" class="sidebar-link">6.2 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-3-preparebeanfactory" class="sidebar-link">6.3 prepareBeanFactory</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-4-postprocessbeanfactory-beanfactory" class="sidebar-link">6.4 postProcessBeanFactory(beanFactory)</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-5-invokebeanfactorypostprocessors-beanfactory" class="sidebar-link">6.5-invokeBeanFactoryPostProcessors(beanFactory)</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-6-registerbeanpostprocessors-beanfactory" class="sidebar-link">6.6-registerBeanPostProcessors(beanFactory);</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-7-initmessagesource" class="sidebar-link">6.7-initMessageSource()</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-8-initapplicationeventmulticaster" class="sidebar-link">6.8-initApplicationEventMulticaster()</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-9-onrefresh" class="sidebar-link">6.9-onRefresh();</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-10-registerlisteners" class="sidebar-link">6.10-registerListeners();</a></li><li class="sidebar-sub-header level5"><a href="/pages/883153/#_6-11-finishbeanfactoryinitialization-beanfactory" class="sidebar-link">6-11-finishBeanFactoryInitialization(beanFactory);</a></li><li class="sidebar-sub-header level3"><a href="/pages/883153/#spring-bean的生命周期" class="sidebar-link">Spring Bean的生命周期</a></li></ul></li></ul></li><li><a href="/pages/e5e86f/" class="sidebar-link">Spring AOP</a></li><li><a href="/pages/f958e8/" class="sidebar-link">Spring声明式事务源码</a></li><li><a href="/pages/3a0c9d/" class="sidebar-link">Spring MVC</a></li><li><a href="/pages/e73dd4/" class="sidebar-link">Spring解决循环依赖</a></li><li><a href="/pages/b8bd50/" class="sidebar-link">Spring事件监听机制</a></li><li><a href="/pages/8ddff3/" class="sidebar-link">Spring设计模式</a></li><li><a href="/pages/8b0b75/" class="sidebar-link">spring事务的隔离传播机制</a></li><li><a href="/pages/ed1d6a/" class="sidebar-link">Mybatis基础</a></li><li><a href="/pages/e200a1/" class="sidebar-link">Mybatis执行SQL流程分析</a></li><li><a href="/pages/e33d50/" class="sidebar-link">Spring整合Mybatis原理</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>微服务专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>项目实战专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>设计模式专题</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>问题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>友链</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>证券</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/Other/#Other" data-v-06225672>Other</a></li><li data-v-06225672><a href="/Other/#Book" data-v-06225672>Book</a></li><li data-v-06225672><a href="/Other/#源码框架专题" data-v-06225672>源码框架专题</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://nylg.gitee.io" target="_blank" title="作者" class="beLink" data-v-06225672>wen chao</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-06-18</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Spring IOC<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="ioc-详解"><a href="#ioc-详解" class="header-anchor">#</a> IOC 详解</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>U2FsdGVkX18PjAJAijNxkqBxylmnlhoo0bkK2rUea41NEOd7jRSvjdymsQs7cyGd
Szs5uwN1s2T6V8u6/ak3qJmuCn206O69rHHw9c4mRdpkYrUsa7L2NhKbV1X1+qEb
NdqFdPyhvGgWpLgAmoE7ZilrbNwyaTrpmF3dhpnPDw==
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="ioc体系"><a href="#ioc体系" class="header-anchor">#</a> IOC体系</h3> <p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring-ioc/082111521214_0springIOC%E4%BD%93%E7%B3%BB%E5%9B%BE_1.Jpeg" alt=""></p> <h3 id="ioc加载流程图"><a href="#ioc加载流程图" class="header-anchor">#</a> IOC加载流程图</h3> <p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/11.Jpeg" alt=""></p> <p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring-ioc/image-20210823194558015.png" alt="image-20210823194558015"></p> <p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring-ioc/image-20210823194629231.png" alt="image-20210823194629231"></p> <p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring-ioc/image-20210823194652732.png" alt="image-20210823194652732"></p> <h3 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h3> <p>Spring 最重要的概念是 IOC 和 AOP，其中IOC又是Spring中的根基：</p> <p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/clipboard1.png" alt=""></p> <p>本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean。为了保持文章的严谨性，如果同学们发现文章有误请一定不吝指出。</p> <p><strong>Demo:</strong></p> <p>配置类 MainConfig.java：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
 * Created by xsls on 2019/8/15.
 */
@Configuration
@ComponentScan(basePackages = {&quot;com.tuling.iocbeanlifecicle&quot;}) 
public class MainConfig {  

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​</p> <p>Bean Car.java：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Component
public class Car {


   private String name;
   @Autowired
   private Tank tank;

   public void setTank(Tank tank) {
      this.tank = tank;
   }

   public Tank getTank() {
      return tank;
   }

   public String getName() {
      return name;
   }


   public void setName(String name) {
      this.name = name;
   }


   public Car() {
      System.out.println(&quot;car加载....&quot;);
   }



}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>Bean MainStart.java：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public static void main(String[] args)   {
   // 加载spring上下文
   AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);

   Car car =  context.getBean(&quot;car&quot;,Car.class);
   System.out.println(car.getName());
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​</p> <h3 id="spring-ioc容器的加载过程"><a href="#spring-ioc容器的加载过程" class="header-anchor">#</a> Spring IoC容器的加载过程</h3> <h4 id="_1-实例化化容器-annotationconfigapplicationcontext"><a href="#_1-实例化化容器-annotationconfigapplicationcontext" class="header-anchor">#</a> 1.实例化化容器：AnnotationConfigApplicationContext ：</h4> <p>从这里出发：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>	// 加载spring上下文
   AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>AnnotationConfigApplicationContext的结构关系：</li></ul> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6581.png" alt="0"></p> <p>创建AnnotationConfigApplicationContext对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少
    public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {
        //调用无参构造函数，会先调用父类GenericApplicationContext的构造函数
        //父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory
        //本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner
        //scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的
        this();
        //把传入的类进行注册，这里有两个情况，
        //传入传统的配置类
        //传入bean（虽然一般没有人会这么做
        //看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类
        //但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean
        register(annotatedClasses);
        //刷新
        refresh();
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>​</p> <p>我们先来为构造方法做一个简单的说明：</p> <ol><li>这是一个有参的构造方法，可以接收多个配置类，不过一般情况下，只会传入一个配置类。</li> <li>这个配置类有两种情况，一种是传统意义上的带上@Configuration注解的配置类，还有一种是没有带上@Configuration，但是带有@Component，@Import，@ImportResouce，@Service，@ComponentScan等注解的配置类，在Spring内部把前者称为Full配置类，把后者称之为Lite配置类。在本源码分析中，有些地方也把Lite配置类称为<strong>普通Bean</strong>。</li></ol> <p>使用断点调试，通过this()调用此类无参的构造方法，代码到下面：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {

    //注解bean定义读取器，主要作用是用来读取被注解的了bean
    private final AnnotatedBeanDefinitionReader reader;

    //扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的
    private final ClassPathBeanDefinitionScanner scanner;

    /**
     * Create a new AnnotationConfigApplicationContext that needs to be populated
     * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
     */
    public AnnotationConfigApplicationContext() {
        //会隐式调用父类的构造方法，初始化DefaultListableBeanFactory

        //初始化一个Bean读取器
        this.reader = new AnnotatedBeanDefinitionReader(this);

        //初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的
        this.scanner = new ClassPathBeanDefinitionScanner(this);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>​</p> <p>首先无参构造方法中就是对读取器reader和扫描器scanner进行了实例化，reader的类型是AnnotatedBeanDefinitionReader，可以看出它是一个 “打了注解的Bean定义读取器”，scanner的类型是ClassPathBeanDefinitionScanner，它仅仅是在外面手动调用.scan方法，或者调用参数为String的构造方法，传入需要扫描的包名才会用到，像这样方式传入的配置类是不会用到这个scanner对象的。</p> <p>AnnotationConfigApplicationContext类是有继承关系的，会隐式调用父类的构造方法：</p> <p>下面代码</p> <h4 id="_2-实例化工厂-defaultlistablebeanfactory"><a href="#_2-实例化工厂-defaultlistablebeanfactory" class="header-anchor">#</a> 2.实例化工厂：DefaultListableBeanFactory</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry {

    private final DefaultListableBeanFactory beanFactory;

    @Nullable
    private ResourceLoader resourceLoader;

    private boolean customClassLoader = false;

    private final AtomicBoolean refreshed = new AtomicBoolean();


    /**
     * Create a new GenericApplicationContext.
     * @see #registerBeanDefinition
     * @see #refresh
     */
    public GenericApplicationContext() {
        this.beanFactory = new DefaultListableBeanFactory();
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>DefaultListableBeanFactory的关系图</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6583.png" alt="0"></p> <p>DefaultListableBeanFactory是相当重要的，从字面意思就可以看出它是一个Bean的工厂，什么是Bean的工厂？当然就是用来生产和获得Bean的。</p> <h4 id="_3-实例化建beandefinition读取器-annotatedbeandefinitionreader"><a href="#_3-实例化建beandefinition读取器-annotatedbeandefinitionreader" class="header-anchor">#</a> 3.实例化建BeanDefinition读取器： AnnotatedBeanDefinitionReader：</h4> <p>其主要做了2件事情</p> <p>1.注册内置BeanPostProcessor</p> <p>2.注册相关的BeanDefinition</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6579.png" alt="0"></p> <p>让我们把目光回到AnnotationConfigApplicationContext的无参构造方法，让我们看看Spring在初始化AnnotatedBeanDefinitionReader的时候做了什么：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
        this(registry, getOrCreateEnvironment(registry));
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的BeanDefinitionRegistry当然就是AnnotationConfigApplicationContext的实例了，这里又直接调用了此类其他的构造方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
        Assert.notNull(environment, &quot;Environment must not be null&quot;);
        this.registry = registry;
        this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​</p> <p>让我们把目光移动到这个方法的最后一行，进入registerAnnotationConfigProcessors方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {
        registerAnnotationConfigProcessors(registry, null);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​</p> <p>这又是一个门面方法，再点进去，这个方法的返回值Set，但是上游方法并没有去接收这个返回值，所以这个方法的返回值也不是很重要了，当然方法内部给这个返回值赋值也不重要了。由于这个方法内容比较多，这里就把最核心的贴出来，这个方法的核心就是注册Spring内置的多个Bean：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​</p> <ol><li>判断容器中是否已经存在了ConfigurationClassPostProcessor Bean</li> <li>如果不存在（当然这里肯定是不存在的），就通过RootBeanDefinition的构造方法获得ConfigurationClassPostProcessor的BeanDefinition，RootBeanDefinition是BeanDefinition的子类</li> <li>执行registerPostProcessor方法，registerPostProcessor方法内部就是注册Bean，当然这里注册其他Bean也是一样的流程。</li></ol> <p><strong>BeanDefinition是什么？</strong></p> <p>BeanDefinition联系图</p> <p><strong>向上</strong></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6590.png" alt="0"></p> <ul><li><strong>BeanMetadataElement接口</strong>：BeanDefinition元数据，返回该Bean的来源</li> <li><strong>AttributeAccessor接口</strong>：提供对BeanDefinition属性操作能力，</li></ul> <p><strong>向下</strong></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6714.png" alt="0"></p> <p>它是用来描述Bean的，里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，我们以后会常常和它打交道。**</p> <p>registerPostProcessor方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> private static BeanDefinitionHolder registerPostProcessor(
            BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {

        definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        registry.registerBeanDefinition(beanName, definition);
        return new BeanDefinitionHolder(definition, beanName);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这方法为BeanDefinition设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的，然后又调用了registerBeanDefinition方法，再点进去，Oh No，你会发现它是一个接口，没办法直接点进去了，首先要知道registry实现类是什么，那么它的实现是什么呢？答案是DefaultListableBeanFactory：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
            throws BeanDefinitionStoreException {
        this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这又是一个门面方法，再点进去，核心在于下面两行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//beanDefinitionMap是Map&lt;String, BeanDefinition&gt;，
//这里就是把beanName作为key，ScopedProxyMode作为value，推到map里面
this.beanDefinitionMap.put(beanName, beanDefinition);

//beanDefinitionNames就是一个List&lt;String&gt;,这里就是把beanName放到List中去
this.beanDefinitionNames.add(beanName);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​</p> <p>从这里可以看出DefaultListableBeanFactory就是我们所说的容器了，里面放着beanDefinitionMap，beanDefinitionNames，beanDefinitionMap是一个hashMap，beanName作为Key,beanDefinition作为Value，beanDefinitionNames是一个集合，里面存放了beanName。打个断点，第一次运行到这里，监视这两个变量：</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6587.png" alt="0"></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6589.png" alt="0"></p> <p><strong>DefaultListableBeanFactory中的beanDefinitionMap，beanDefinitionNames也是相当重要的，以后会经常看到它，最好看到它，第一时间就可以反应出它里面放了什么数据</strong></p> <p>这里仅仅是注册，可以简单的理解为把一些原料放入工厂，工厂还没有真正的去生产。</p> <p>上面已经介绍过，这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。</p> <p><strong>ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，BeanFactoryPostProcessor是Spring的扩展点之一，ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。</strong></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6586.png" alt="0"></p> <p>除了注册了ConfigurationClassPostProcessor，还注册了其他Bean，其他Bean也都实现了其他接口，比如BeanPostProcessor等。</p> <p><strong>BeanPostProcessor接口也是Spring的扩展点之一。</strong></p> <p>至此，实例化AnnotatedBeanDefinitionReader reader分析完毕。</p> <h4 id="_4-创建beandefinition扫描器-classpathbeandefinitionscanner"><a href="#_4-创建beandefinition扫描器-classpathbeandefinitionscanner" class="header-anchor">#</a> 4.创建BeanDefinition扫描器:ClassPathBeanDefinitionScanner</h4> <p>由于常规使用方式是不会用到AnnotationConfigApplicationContext里面的scanner的，这里的scanner仅仅是为了程序员可以手动调用AnnotationConfigApplicationContext对象的scan方法。所以这里就不看scanner是如何被实例化的了。</p> <h4 id="_5-注册配置类为beandefinition-register-annotatedclasses"><a href="#_5-注册配置类为beandefinition-register-annotatedclasses" class="header-anchor">#</a> 5.注册配置类为BeanDefinition： register(annotatedClasses);</h4> <p>把目光回到最开始，再分析第二行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>register(annotatedClasses);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里传进去的是一个数组，最终会循环调用如下方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
            @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
        //AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类
        //转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解
        AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);

        //判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析
        if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
            return;
        }

        abd.setInstanceSupplier(instanceSupplier);

        //解析bean的作用域，如果没有设置的话，默认为单例
        ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
        abd.setScope(scopeMetadata.getScopeName());

        //获得beanName
        String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

        //解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description
        AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);

        //限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种
        //AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，
        //qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理
        //但是spring提供了其他方式去注册bean，就可能会传入了
        if (qualifiers != null) {
            //可以传入qualifier数组，所以需要循环处理
            for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
                //Primary注解优先
                if (Primary.class == qualifier) {
                    abd.setPrimary(true);
                }
                //Lazy注解
                else if (Lazy.class == qualifier) {
                    abd.setLazyInit(true);
                }
                //其他，AnnotatedGenericBeanDefinition有个Map&lt;String,AutowireCandidateQualifier&gt;属性，直接push进去
                else {
                    abd.addQualifier(new AutowireCandidateQualifier(qualifier));
                }
            }
        }

        for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
            customizer.customize(abd);
        }

        //这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中
        BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);

        definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);

        //注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，
        //DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap
        //beanDefinitionNames是一个List&lt;String&gt;,用来保存beanName
        //beanDefinitionMap是一个Map,用来保存beanName和beanDefinition
        BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br></div></div><p>​</p> <p>在这里又要说明下，以常规方式去注册配置类，此方法中除了第一个参数，其他参数都是默认值。</p> <ol><li><p>通过AnnotatedGenericBeanDefinition的构造方法，获得配置类的BeanDefinition，这里是不是似曾相似，在注册ConfigurationClassPostProcessor类的时候，也是通过构造方法去获得BeanDefinition的，只不过当时是通过RootBeanDefinition去获得，现在是通过AnnotatedGenericBeanDefinition去获得。</p></li> <li><p>判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。</p></li> <li><p>然后是解析作用域，如果没有设置的话，默认为单例。</p></li> <li><p>获得BeanName。</p></li> <li><p>解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description。</p></li> <li><p>限定符处理，不是特指@Qualifier注解，也有可能是Primary，或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性）。</p></li> <li><p>把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中（这个不是很重要，可以简单的理解为方便传参）。</p></li> <li><p>注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册：</p></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>public static void registerBeanDefinition(
            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
            throws BeanDefinitionStoreException {

        //获取beanName
        // Register bean definition under primary name.
        String beanName = definitionHolder.getBeanName();

        //注册bean
        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

                //Spring支持别名
        // Register aliases for bean name, if any.
        String[] aliases = definitionHolder.getAliases();
        if (aliases != null) {
            for (String alias : aliases) {
                registry.registerAlias(beanName, alias);
            }
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这个registerBeanDefinition是不是又有一种似曾相似的感觉，没错，在上面注册Spring内置的Bean的时候，已经解析过这个方法了，这里就不重复了，此时，让我们再观察下beanDefinitionMap beanDefinitionNames两个变量，除了Spring内置的Bean，还有我们传进来的Bean，这里的Bean当然就是我们的配置类了：</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6580.png" alt="0"></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6588.png" alt="0"></p> <p>到这里注册配置类也分析完毕了。</p> <h4 id="_6-refresh"><a href="#_6-refresh" class="header-anchor">#</a> 6. refresh()</h4> <p>大家可以看到其实到这里，Spring还没有进行扫描，只是实例化了一个工厂，注册了一些内置的Bean和我们传进去的配置类，真正的大头是在第三行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  refresh();     
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p>这个方法做了很多事情，让我们点开这个方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			//刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等
			prepareRefresh();

			//DefaultListableBeanFactory
			// Tell the subclass to refresh the internal bean factory.
			//和主流程关系也不大，最终获得了DefaultListableBeanFactory，
			// DefaultListableBeanFactory实现了ConfigurableListableBeanFactory
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			//还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector
			//还设置了 忽略自动装配 和 允许自动装配 的接口,如果不存在某个bean的时候，spring就自动注册singleton bean
			//还设置了bean表达式解析器 等
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				//这是一个空方法
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				//执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				// 注册BeanPostProcessor
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				// 空方法
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br></div></div><p>里面有很多小方法，我们今天的目标是分析前五个小方法：</p> <h5 id="_6-1-preparerefresh"><a href="#_6-1-preparerefresh" class="header-anchor">#</a> 6.1 prepareRefresh</h5> <p>从命名来看，就知道这个方法主要做了一些刷新前的准备工作，和主流程关系不大，主要是保存了容器的启动时间，启动标志等。</p> <h5 id="_6-2-configurablelistablebeanfactory-beanfactory-obtainfreshbeanfactory"><a href="#_6-2-configurablelistablebeanfactory-beanfactory-obtainfreshbeanfactory" class="header-anchor">#</a> 6.2 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</h5> <p>这个方法和主流程关系也不是很大，可以简单的认为，就是把beanFactory取出来而已。XML模式下会在这里读取BeanDefinition</p> <h5 id="_6-3-preparebeanfactory"><a href="#_6-3-preparebeanfactory" class="header-anchor">#</a> 6.3 prepareBeanFactory</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>			//还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector
			//还设置了 忽略自动装配 和 允许自动装配 的接口,如果不存在某个bean的时候，spring就自动注册singleton bean
			//还设置了bean表达式解析器 等
			prepareBeanFactory(beanFactory);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6591.png" alt="0"></p> <p>这代码相比前面两个就比较重要了，我们需要点进去好好看看，做了什么操作:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// Tell the internal bean factory to use the context's class loader etc.
		beanFactory.setBeanClassLoader(getClassLoader());//设置类加载器

		//设置bean表达式解析器
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));

		//属性编辑器支持
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
		//添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

		//以下接口，忽略自动装配
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
		//以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// Register early post-processor for detecting inner beans as ApplicationListeners.
		//添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		//如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean
		//Register default environment beans.

		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p>​</p> <p>主要做了如下的操作：</p> <ol><li>设置了一个类加载器</li> <li>设置了bean表达式解析器</li> <li>添加了属性编辑器的支持</li> <li>添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口</li> <li>设置了一些忽略自动装配的接口</li> <li>设置了一些允许自动装配的接口，并且进行了赋值操作</li> <li>在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean</li></ol> <h5 id="_6-4-postprocessbeanfactory-beanfactory"><a href="#_6-4-postprocessbeanfactory-beanfactory" class="header-anchor">#</a> 6.4 postProcessBeanFactory(beanFactory)</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>//这是一个空方法
postProcessBeanFactory(beanFactory);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这是一个空方法，可能以后Spring会进行扩展把。</p> <h5 id="_6-5-invokebeanfactorypostprocessors-beanfactory"><a href="#_6-5-invokebeanfactorypostprocessors-beanfactory" class="header-anchor">#</a> 6.5-invokeBeanFactoryPostProcessors(beanFactory)</h5> <p>可以结合流程图一起观看更佳：</p> <p>https://www.processon.com/view/link/5f18298a7d9c0835d38a57c0</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>			//执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor
				invokeBeanFactoryPostProcessors(beanFactory);
重点代码终于来了，可以说 这句代码是目前为止最重要，也是内容最多的代码了，我们有必要好好分析下：
	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {

		//getBeanFactoryPostProcessors真是坑，第一次看到这里的时候，愣住了，总觉得获得的永远都是空的集合，掉入坑里，久久无法自拔
		//后来才知道spring允许我们手动添加BeanFactoryPostProcessor
		//即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
		if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>让我们看看第一个小方法的第二个参数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>	public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() {
		return this.beanFactoryPostProcessors;
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​</p> <p>这里获得的是BeanFactoryPostProcessor，当我看到这里的时候，愣住了，通过IDEA的查找引用功能，我发现这个集合永远都是空的，根本没有代码为这个集合添加数据，很久都没有想通，后来才知道我们在外部可以手动添加一个后置处理器，而不是交给Spring去扫描，即：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>	AnnotationConfigApplicationContext annotationConfigApplicationContext =
				new AnnotationConfigApplicationContext(AppConfig.class);
		annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>只有这样，这个集合才不会为空，但是应该没有人这么做吧，当然也有可能是我孤陋寡闻。</p> <p>让我们点开invokeBeanFactoryPostProcessors方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>
			<span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> beanFactoryPostProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> processedBeans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">BeanDefinitionRegistry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">BeanDefinitionRegistry</span> registry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">;</span>

			<span class="token comment">//regularPostProcessors 用来存放BeanFactoryPostProcessor，</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> regularPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//registryProcessors 用来存放BeanDefinitionRegistryPostProcessor</span>
			<span class="token comment">//BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">&gt;</span></span> registryProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据</span>
			<span class="token comment">// 因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的</span>
			<span class="token comment">// 只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanFactoryPostProcessor</span> postProcessor <span class="token operator">:</span> beanFactoryPostProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor</span>
				<span class="token comment">// 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor</span>
				<span class="token comment">// 是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>postProcessor <span class="token keyword">instanceof</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token class-name">BeanDefinitionRegistryPostProcessor</span> registryProcessor <span class="token operator">=</span>
							<span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">)</span> postProcessor<span class="token punctuation">;</span>
					registryProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
					registryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registryProcessor<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>

				<span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//不是的话，就装到regularPostProcessors</span>
					regularPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>postProcessor<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
			<span class="token comment">// uninitialized to let the bean factory post-processors apply to them!</span>
			<span class="token comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span>
			<span class="token comment">// PriorityOrdered, Ordered, and the rest.</span>
			<span class="token comment">//一个临时变量，用来装载BeanDefinitionRegistryPostProcessor</span>
			<span class="token comment">//BeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">&gt;</span></span> currentRegistryProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span>
			<span class="token comment">// 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span>
			<span class="token comment">// 并且装入数组postProcessorNames，我理解一般情况下，只会找到一个</span>
			<span class="token comment">// 这里又有一个坑，为什么我自己创建了一个实现BeanDefinitionRegistryPostProcessor接口的类，也打上了@Component注解</span>
			<span class="token comment">// 配置类也加上了@Component注解，但是这里却没有拿到</span>
			<span class="token comment">// 因为直到这一步，Spring还没有去扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面的第一个</span>
			<span class="token comment">// invokeBeanDefinitionRegistryPostProcessors方法</span>
			<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span>
					beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">PriorityOrdered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token comment">//获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors</span>
					<span class="token comment">//ConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口</span>
					<span class="token comment">//BeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口</span>
					<span class="token comment">//ConfigurationClassPostProcessor是极其重要的类</span>
					<span class="token comment">//里面执行了扫描Bean，Import，ImportResouce等各种操作</span>
					<span class="token comment">//用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑</span>
					currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了</span>
					processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token comment">//处理排序</span>
			<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span>
			<span class="token comment">//一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法</span>
			<span class="token comment">//而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法</span>
			<span class="token comment">//所以这里需要把处理器放入一个集合中，后续统一执行父类的方法</span>
			registryProcessors<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法</span>
			<span class="token comment">//Spring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理</span>
			<span class="token comment">//如果不想用这个组件，直接把注册组件的那一步去掉就可以</span>
			<span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//因为currentRegistryProcessors是一个临时变量，所以需要清除</span>
			currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span>
			<span class="token comment">// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span>
			<span class="token comment">// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span>
			<span class="token comment">// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理</span>
			<span class="token comment">// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span>
			postProcessorNames <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>processedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">Ordered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token comment">//处理排序</span>
			<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//合并Processors</span>
			registryProcessors<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//执行我们自定义的BeanDefinitionRegistryPostProcessor</span>
			<span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//清空临时变量</span>
			currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span>
			<span class="token comment">// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span>
			<span class="token comment">// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span>
			<span class="token keyword">boolean</span> reiterate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>reiterate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				reiterate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				postProcessorNames <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>processedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
						currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
						reiterate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
				registryProcessors<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
				currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span>
			<span class="token comment">//registryProcessors集合装载BeanDefinitionRegistryPostProcessor</span>
			<span class="token comment">//上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span>
			<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>registryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span>
			<span class="token comment">//但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</span>
			<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>regularPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// Invoke factory processors registered with the context instance.</span>
			<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactoryPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
		<span class="token comment">// uninitialized to let the bean factory post-processors apply to them!</span>
		<span class="token comment">//找到BeanFactoryPostProcessor实现类的BeanName数组</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span>
				beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span>
		<span class="token comment">// Ordered, and the rest.</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> priorityOrderedPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> orderedPostProcessorNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nonOrderedPostProcessorNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//循环BeanName数组</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//如果这个Bean被执行过了，跳过</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>processedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// skip - already processed in first phase above</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">PriorityOrdered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				priorityOrderedPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果实现了Ordered接口，加入到orderedPostProcessorNames</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">Ordered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				orderedPostProcessorNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				nonOrderedPostProcessorNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span>
		<span class="token comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span>
		<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>priorityOrderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//执行priorityOrderedPostProcessors</span>
		<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>priorityOrderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//执行实现了Ordered接口的BeanFactoryPostProcessor</span>
		<span class="token comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> orderedPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> postProcessorName <span class="token operator">:</span> orderedPostProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			orderedPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>postProcessorName<span class="token punctuation">,</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>orderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>orderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor</span>
		<span class="token comment">// Finally, invoke all other BeanFactoryPostProcessors.</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> nonOrderedPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> postProcessorName <span class="token operator">:</span> nonOrderedPostProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			nonOrderedPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>postProcessorName<span class="token punctuation">,</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>nonOrderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Clear cached merged bean definitions since the post-processors might have</span>
		<span class="token comment">// modified the original metadata, e.g. replacing placeholders in values...</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">clearMetadataCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br></div></div><p>首先判断beanFactory是不是BeanDefinitionRegistry的实例，当然肯定是的，然后执行如下操作：</p> <ol><li>定义了一个Set，装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。</li> <li>定义了两个List，一个是regularPostProcessors，用来装载BeanFactoryPostProcessor，一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor。BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。</li> <li>循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。</li> <li>定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。</li> <li>getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这个后置处理器在上一节中已经说明过了，十分重要。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。</li> <li>循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），</li></ol> <p>如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了。当然现在还没有处理，但是马上就要处理了。。。</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6584.png" alt="0"></p> <ol><li>进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li> <li>把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li> <li>可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的<strong>热插拔</strong>，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。</li></ol> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6577.png" alt="0"></p> <ol><li>清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。</li> <li>再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。</li></ol> <p>这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。</p> <ol><li>处理排序。</li> <li>合并Processors，合并的理由和上面是一样的。</li> <li>执行我们自定义的BeanDefinitionRegistryPostProcessor。</li> <li>清空临时变量。</li> <li>在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor。</li> <li>上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次。</li> <li>执行regularPostProcessors中的后置处理器的方法，需要注意的是，在一般情况下，regularPostProcessors是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据。</li> <li>查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。</li></ol> <p>这就是这个方法中做的主要的事情了，可以说是比较复杂的。但是逻辑还是比较清晰的，在第9步的时候，我说有一个方法会详细说来，现在就让我们好好看看这个方法究竟做了什么吧。</p> <p>这里面调用链很深， 在课程中详细讲解，篇幅有限。</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6596.png" alt="0"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
		List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
		String[] candidateNames = registry.getBeanDefinitionNames();//获得所有的BeanDefinition的Name，放入candidateNames数组

		//循环candidateNames数组
		for (String beanName : candidateNames) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);//根据beanName获得BeanDefinition

			// 内部有两个标记位来标记是否已经处理过了
			// 这里会引发一连串知识盲点
			// 当我们注册配置类的时候，可以不加Configuration注解，直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类
			// 如果加了Configuration注解，就称之为Full配置类
			// 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类
			// 如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了
			// 写一个A类，其中有一个构造方法，打印出“你好”
			// 再写一个配置类，里面有两个bean注解的方法
			// 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA
			// 第二个方法又调用了getA方法
			// 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次
			// 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
				}
			}

			//判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），
			//在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记
			//满足条件，加入到configCandidates
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
			}
		}

		// 如果没有配置类，直接返回
		// Return immediately if no @Configuration classes were found
		if (configCandidates.isEmpty()) {
			return;
		}

		// Sort by previously determined @Order value, if applicable
		//处理排序
		configCandidates.sort((bd1, bd2) -&gt; {
			int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
			int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
			return Integer.compare(i1, i2);
		});

		// Detect any custom bean name generation strategy supplied through the enclosing application context
		SingletonBeanRegistry sbr = null;
		// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if
		if (registry instanceof SingletonBeanRegistry) {
			sbr = (SingletonBeanRegistry) registry;
			if (!this.localBeanNameGeneratorSet) {
				//spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做
				BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
				if (generator != null) {
					this.componentScanBeanNameGenerator = generator;
					this.importBeanNameGenerator = generator;
				}
			}
		}

		if (this.environment == null) {
			this.environment = new StandardEnvironment();
		}

		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);

		Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
		Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
		do {
			//解析配置类（传统意义上的配置类或者是普通bean，核心来了）
			parser.parse(candidates);
			parser.validate();

			Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
			configClasses.removeAll(alreadyParsed);

			// Read the model and create bean definitions based on its content
			if (this.reader == null) {
				this.reader = new ConfigurationClassBeanDefinitionReader(
						registry, this.sourceExtractor, this.resourceLoader, this.environment,
						this.importBeanNameGenerator, parser.getImportRegistry());
			}
			this.reader.loadBeanDefinitions(configClasses);//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition
			alreadyParsed.addAll(configClasses);//把configClasses加入到alreadyParsed，代表

			candidates.clear();
			//获得注册器里面BeanDefinition的数量 和 candidateNames进行比较
			//如果大于的话，说明有新的BeanDefinition注册进来了
			if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
				String[] newCandidateNames = registry.getBeanDefinitionNames();//从注册器里面获得BeanDefinitionNames
				Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));//candidateNames转换set
				Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
				//循环alreadyParsed。把类名加入到alreadyParsedClasses
				for (ConfigurationClass configurationClass : alreadyParsed) {
					alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
				}
				for (String candidateName : newCandidateNames) {
					if (!oldCandidateNames.contains(candidateName)) {
						BeanDefinition bd = registry.getBeanDefinition(candidateName);
						if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
								!alreadyParsedClasses.contains(bd.getBeanClassName())) {
							candidates.add(new BeanDefinitionHolder(bd, candidateName));
						}
					}
				}
				candidateNames = newCandidateNames;
			}
		}
		while (!candidates.isEmpty());

		// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
		if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
			sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
		}

		if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
			// Clear cache in externally provided MetadataReaderFactory; this is a no-op
			// for a shared cache since it'll be cleared by the ApplicationContext.
			((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
		}
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br></div></div><p>​</p> <ol><li>获得所有的BeanName，放入candidateNames数组。</li> <li>循环candidateNames数组，根据beanName获得BeanDefinition，判断此BeanDefinition是否已经被处理过了。</li> <li>判断是否是配置类，如果是的话。加入到configCandidates数组，在判断的时候，还会标记配置类属于Full配置类，还是Lite配置类，这里会引发一连串的知识盲点：</li></ol> <p>3.1 当我们注册配置类的时候，可以不加@Configuration注解，直接使用@Component @ComponentScan @Import @ImportResource等注解，Spring把这种配置类称之为Lite配置类， 如果加了@Configuration注解，就称之为Full配置类。</p> <p>3.2 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类，如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了。</p> <p>3.3 写一个A类，其中有一个构造方法，打印出“你好”，再写一个配置类，里面有两个被@bean注解的方法，其中一个方法new了A类，并且返回A的对象，把此方法称之为getA，第二个方法又调用了getA方法，如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次，如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写。</p> <ol><li>如果没有配置类直接返回。</li> <li>处理排序。</li> <li>解析配置类，可能是Full配置类，也有可能是Lite配置类，这个小方法是此方法的核心，稍后具体说明。</li> <li>在第6步的时候，只是注册了部分Bean，像 @Import @Bean等，是没有被注册的，这里统一对这些进行注册。</li></ol> <p>下面是解析配置类的过程：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
		this.deferredImportSelectors = new LinkedList&lt;&gt;();
		//循环传进来的配置类
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();//获得BeanDefinition
			try {
				//如果获得BeanDefinition是AnnotatedBeanDefinition的实例
				if (bd instanceof AnnotatedBeanDefinition) {
					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
				} else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
				} else {
					parse(bd.getBeanClassName(), holder.getBeanName());
				}
			} catch (BeanDefinitionStoreException ex) {
				throw ex;
			} catch (Throwable ex) {
				throw new BeanDefinitionStoreException(
						&quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
			}
		}

		//执行DeferredImportSelector
		processDeferredImportSelectors();
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>因为可以有多个配置类，所以需要循环处理。我们的配置类的BeanDefinition是AnnotatedBeanDefinition的实例，所以会进入第一个if：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
		processConfigurationClass(new ConfigurationClass(metadata, beanName));
	}
	protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {

		//判断是否需要跳过
		if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
			return;
		}

		ConfigurationClass existingClass = this.configurationClasses.get(configClass);
		if (existingClass != null) {
			if (configClass.isImported()) {
				if (existingClass.isImported()) {
					existingClass.mergeImportedBy(configClass);
				}
				// Otherwise ignore new imported config class; existing non-imported class overrides it.
				return;
			} else {
				// Explicit bean definition found, probably replacing an import.
				// Let's remove the old one and go with the new one.
				this.configurationClasses.remove(configClass);
				this.knownSuperclasses.values().removeIf(configClass::equals);
			}
		}

		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
		}
		while (sourceClass != null);

		this.configurationClasses.put(configClass, configClass);
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>​</p> <p>重点在于doProcessConfigurationClass方法，需要特别注意，最后一行代码，会把configClass放入一个Map，会在上面第7步中用到。</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6602.png" alt="0"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
			throws IOException {

		//递归处理内部类，一般不会写内部类
		// Recursively process any member (nested) classes first
		processMemberClasses(configClass, sourceClass);

		// Process any @PropertySource annotations
		//处理@PropertySource注解，@PropertySource注解用来加载properties文件
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			if (this.environment instanceof ConfigurableEnvironment) {
				processPropertySource(propertySource);
			} else {
				logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
						&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
			}
		}

		// Process any @ComponentScan annotations
		//获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等
		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);

		//如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if
		if (!componentScans.isEmpty() &amp;&amp;
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			//循环处理componentScans
			for (AnnotationAttributes componentScan : componentScans) {
				// The config class is annotated with @ComponentScan -&gt; perform the scan immediately
				//componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称
				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				// Check the set of scanned definitions for any further config classes and parse recursively if needed
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
					if (bdCand == null) {
						bdCand = holder.getBeanDefinition();
					}
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
						//递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解
						parse(bdCand.getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}

		// Process any @Import annotations
		//处理@Import注解
		//@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解
		//@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar
		//getImports(sourceClass)是获得import的内容，返回的是一个set
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		// Process any @ImportResource annotations
		//处理@ImportResource注解
		AnnotationAttributes importResource =
				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
		if (importResource != null) {
			String[] resources = importResource.getStringArray(&quot;locations&quot;);
			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
			for (String resource : resources) {
				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
				configClass.addImportedResource(resolvedResource, readerClass);
			}
		}

		//处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收
		// Process individual @Bean methods
		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}

		// Process default methods on interfaces
		processInterfaces(configClass, sourceClass);

		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
			if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
					!this.knownSuperclasses.containsKey(superclass)) {
				this.knownSuperclasses.put(superclass, configClass);
				// Superclass found, return its annotation metadata and recurse
				return sourceClass.getSuperClass();
			}
		}

		// No superclass -&gt; processing is complete
		return null;
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br></div></div><p>​</p> <ol><li>递归处理内部类，一般不会使用内部类。</li> <li>处理@PropertySource注解，@PropertySource注解用来加载properties文件。</li> <li>获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等。</li> <li>判断有没有被@ComponentScans标记，或者被@Condition条件带过，如果满足条件的话，进入if，进行如下操作：</li></ol> <p>4.1 执行扫描操作，把扫描出来的放入set，这个方法稍后再详细说明。</p> <p>4.2 循环set，判断是否是配置类，是的话，递归调用parse方法，因为被扫描出来的类，还是一个配置类，有@ComponentScans注解，或者其中有被@Bean标记的方法 等等，所以需要再次被解析。</p> <ol><li>处理@Import注解，@Import是Spring中很重要的一个注解，正是由于它的存在，让Spring非常灵活，不管是Spring内部，还是与Spring整合的第三方技术，都大量的运用了@Import注解，@Import有三种情况，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar，getImports(sourceClass)是获得import的内容，返回的是一个set，这个方法稍后再详细说明。</li> <li>处理@ImportResource注解。</li> <li>处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收。</li></ol> <p>我们先来看4.1中的那个方法：</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6605.png" alt="0"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
		//扫描器，还记不记在new AnnotationConfigApplicationContext的时候
		//会调用AnnotationConfigApplicationContext的构造方法
		//构造方法里面有一句 this.scanner = new ClassPathBeanDefinitionScanner(this);
		//当时说这个对象不重要，这里就是证明了。常规用法中，实际上执行扫描的只会是这里的scanner对象
		ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
				componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);

		//判断是否重写了默认的命名规则
		Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
		boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
				BeanUtils.instantiateClass(generatorClass));

		ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
			scanner.setScopedProxyMode(scopedProxyMode);
		}
		else {
			Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
		}

		scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));

		//addIncludeFilter addExcludeFilter,最终是往List&lt;TypeFilter&gt;里面填充数据
		//TypeFilter是一个函数式接口，函数式接口在java8的时候大放异彩，只定义了一个虚方法的接口被称为函数式接口
		//当调用scanner.addIncludeFilter  scanner.addExcludeFilter 仅仅把 定义的规则塞进去，并么有真正去执行匹配过程

		//处理includeFilters
		for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
			for (TypeFilter typeFilter : typeFiltersFor(filter)) {
				scanner.addIncludeFilter(typeFilter);
			}
		}

		//处理excludeFilters
		for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
			for (TypeFilter typeFilter : typeFiltersFor(filter)) {
				scanner.addExcludeFilter(typeFilter);
			}
		}

		boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
		if (lazyInit) {
			scanner.getBeanDefinitionDefaults().setLazyInit(true);
		}

		Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
		String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
		for (String pkg : basePackagesArray) {
			String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
			Collections.addAll(basePackages, tokenized);
		}
		// 从下面的代码可以看出ComponentScans指定扫描目标，除了最常用的basePackages，还有两种方式
		// 1.指定basePackageClasses，就是指定多个类，只要是与这几个类同级的，或者在这几个类下级的都可以被扫描到，这种方式其实是spring比较推荐的
		// 因为指定basePackages没有IDE的检查，容易出错，但是指定一个类，就有IDE的检查了，不容易出错，经常会用一个空的类来作为basePackageClasses
		// 2.直接不指定，默认会把与配置类同级，或者在配置类下级的作为扫描目标
		for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
			basePackages.add(ClassUtils.getPackageName(clazz));
		}
		if (basePackages.isEmpty()) {
			basePackages.add(ClassUtils.getPackageName(declaringClass));
		}

		//把规则填充到排除规则：List&lt;TypeFilter&gt;，这里就把 注册类自身当作排除规则，真正执行匹配的时候，会把自身给排除
		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
		//basePackages是一个LinkedHashSet&lt;String&gt;，这里就是把basePackages转为字符串数组的形式
		return scanner.doScan(StringUtils.toStringArray(basePackages));
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br></div></div><ol><li>定义了一个扫描器scanner，还记不记在new AnnotationConfigApplicationContext的时候，会调用AnnotationConfigApplicationContext的构造方法，构造方法里面有一句 this.scanner = new ClassPathBeanDefinitionScanner(this);当时说这个对象不重要，这里就是证明了。常规用法中，实际上执行扫描的只会是这里的scanner对象。</li> <li>处理includeFilters，就是把规则添加到scanner。</li> <li>处理excludeFilters，就是把规则添加到scanner。</li> <li>解析basePackages，获得需要扫描哪些包。</li> <li>添加一个默认的排除规则：排除自身。</li> <li>执行扫描，稍后详细说明。</li></ol> <p>这里需要做一个补充说明，添加规则的时候，只是把具体的规则放入规则类的集合中去，规则类是一个函数式接口，只定义了一个虚方法的接口被称为函数式接口，函数式接口在java8的时候大放异彩，这里只是把规则方塞进去，并没有真正执行匹配规则。</p> <p>我们来看看到底是怎么执行扫描的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
		Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
		//循环处理basePackages
		for (String basePackage : basePackages) {
			//根据包名找到符合条件的BeanDefinition集合
			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
			for (BeanDefinition candidate : candidates) {
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
				//由findCandidateComponents内部可知，这里的candidate是ScannedGenericBeanDefinition
				//而ScannedGenericBeanDefinition是AbstractBeanDefinition和AnnotatedBeanDefinition的之类
				//所以下面的两个if都会进入
				if (candidate instanceof AbstractBeanDefinition) {
					//内部会设置默认值
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
				}
				if (candidate instanceof AnnotatedBeanDefinition) {
					//如果是AnnotatedBeanDefinition，还会再设置一次值
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
				}
				if (checkCandidate(beanName, candidate)) {
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder =
							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
					beanDefinitions.add(definitionHolder);
					registerBeanDefinition(definitionHolder, this.registry);
				}
			}
		}
		return beanDefinitions;
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>因为basePackages可能有多个，所以需要循环处理，最终会进行Bean的注册。下面再来看看findCandidateComponents方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
		//spring支持component索引技术，需要引入一个组件，因为大部分情况不会引入这个组件
		//所以不会进入到这个if
		if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
			return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
		}
		else {
			return scanCandidateComponents(basePackage);
		}
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​</p> <p>Spring支持component索引技术，需要引入一个组件，大部分项目没有引入这个组件，所以会进入scanCandidateComponents方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
		Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
		try {
			//把 传进来的类似 命名空间形式的字符串转换成类似类文件地址的形式，然后在前面加上classpath*:
			//即：com.xx=&gt;classpath*:com/xx/**/*.class
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + '/' + this.resourcePattern;
			//根据packageSearchPath，获得符合要求的文件
			Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
			boolean traceEnabled = logger.isTraceEnabled();
			boolean debugEnabled = logger.isDebugEnabled();
			//循环资源
			for (Resource resource : resources) {
				if (traceEnabled) {
					logger.trace(&quot;Scanning &quot; + resource);
				}

				if (resource.isReadable()) {//判断资源是否可读，并且不是一个目录
					try {
						//metadataReader 元数据读取器，解析resource，也可以理解为描述资源的数据结构
						MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
						//在isCandidateComponent方法内部会真正执行匹配规则
						//注册配置类自身会被排除，不会进入到这个if
						if (isCandidateComponent(metadataReader)) {
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
							sbd.setResource(resource);
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
								if (debugEnabled) {
									logger.debug(&quot;Identified candidate component class: &quot; + resource);
								}
								candidates.add(sbd);
							}
							else {
								if (debugEnabled) {
									logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
								}
							}
						}
						else {
							if (traceEnabled) {
								logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
							}
						}
					}
					catch (Throwable ex) {
						throw new BeanDefinitionStoreException(
								&quot;Failed to read candidate component class: &quot; + resource, ex);
					}
				}
				else {
					if (traceEnabled) {
						logger.trace(&quot;Ignored because not readable: &quot; + resource);
					}
				}
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
		}
		return candidates;
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><ol><li>把传进来的类似命名空间形式的字符串转换成类似类文件地址的形式，然后在前面加上classpath*，即：com.xx=&gt;classpath*:com/xx/**/*.class。</li> <li>根据packageSearchPath，获得符合要求的文件。</li> <li>循环符合要求的文件，进一步进行判断。</li></ol> <p>最终会把符合要求的文件，转换为BeanDefinition，并且返回。</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6608.png" alt="0"></p> <p><strong>@Import解析：</strong></p> <p>直到这里，上面说的4.1中提到的方法终于分析完毕了，让我们再看看上面提到的第5步中的处理@Import注解方法：</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6616.png" alt="0"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//这个方法内部相当相当复杂，importCandidates是Import的内容，调用这个方法的时候，已经说过可能有三种情况
	//这里再说下，1.Import普通类，2.Import ImportSelector，3.Import ImportBeanDefinitionRegistrar
	//循环importCandidates，判断属于哪种情况
	//如果是普通类，会进到else，调用processConfigurationClass方法
	//这个方法是不是很熟悉，没错，processImports这个方法就是在processConfigurationClass方法中被调用的
	//processImports又主动调用processConfigurationClass方法，是一个递归调用，因为Import的普通类，也有可能被加了Import注解，@ComponentScan注解 或者其他注解，所以普通类需要再次被解析
	//如果Import ImportSelector就跑到了第一个if中去，首先执行Aware接口方法，所以我们在实现ImportSelector的同时，还可以实现Aware接口
	//然后判断是不是DeferredImportSelector，DeferredImportSelector扩展了ImportSelector
	//如果不是的话，调用selectImports方法，获得全限定类名数组，在转换成类的数组，然后再调用processImports，又特么的是一个递归调用...
	//可能又有三种情况，一种情况是selectImports的类是一个普通类，第二种情况是selectImports的类是一个ImportBeanDefinitionRegistrar类，第三种情况是还是一个ImportSelector类...
	//所以又需要递归调用
	//如果Import ImportBeanDefinitionRegistrar就跑到了第二个if，还是会执行Aware接口方法，这里终于没有递归了，会把数据放到ConfigurationClass中的Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; importBeanDefinitionRegistrars中去
	private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
								Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) {

		if (importCandidates.isEmpty()) {
			return;
		}

		if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
			this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
		} else {
			this.importStack.push(configClass);
			try {
				for (SourceClass candidate : importCandidates) {
					if (candidate.isAssignable(ImportSelector.class)) {
						// Candidate class is an ImportSelector -&gt; delegate to it to determine imports
						Class&lt;?&gt; candidateClass = candidate.loadClass();
						ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
						ParserStrategyUtils.invokeAwareMethods(
								selector, this.environment, this.resourceLoader, this.registry);
						if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) {
							this.deferredImportSelectors.add(
									new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
						} else {
							String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
							Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
							processImports(configClass, currentSourceClass, importSourceClasses, false);
						}
					} else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
						// Candidate class is an ImportBeanDefinitionRegistrar -&gt;
						// delegate to it to register additional bean definitions
						Class&lt;?&gt; candidateClass = candidate.loadClass();
						ImportBeanDefinitionRegistrar registrar =
								BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
						ParserStrategyUtils.invokeAwareMethods(
								registrar, this.environment, this.resourceLoader, this.registry);
						configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
					} else {
						// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
						// process it as an @Configuration class
						this.importStack.registerImport(
								currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
						processConfigurationClass(candidate.asConfigClass(configClass));
					}
				}
			} catch (BeanDefinitionStoreException ex) {
				throw ex;
			} catch (Throwable ex) {
				throw new BeanDefinitionStoreException(
						&quot;Failed to process import candidates for configuration class [&quot; +
								configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
			} finally {
				this.importStack.pop();
			}
		}
	}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><p><img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6620.png" alt="0"></p> <p>这个方法大概的作用已经在注释中已经写明了，就不再重复了。</p> <p>直到这里，才把ConfigurationClassPostProcessor中的processConfigBeanDefinitions方法简单的过了一下。</p> <p>但是这还没有结束，这里只会解析@Import的Bean而已， 不会注册。</p> <p>后续还有个点：processConfigBeanDefinitions是BeanDefinitionRegistryPostProcessor接口中的方法，BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，还有postProcessBeanFactory方法没有分析，这个方法是干嘛的，简单的来说，就是判断配置类是Lite配置类，还是Full配置类，如果是配置类，就会被Cglib代理，目的就是保证Bean的作用域。关于这个方法实在是比较复杂，课程中讲解。</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6624.png" alt="0"></p> <p>我们来做一个总结，ConfigurationClassPostProcessor中的processConfigBeanDefinitions方法十分重要，主要是完成扫描，最终注册我们定义的Bean。</p> <h5 id="_6-6-registerbeanpostprocessors-beanfactory"><a href="#_6-6-registerbeanpostprocessors-beanfactory" class="header-anchor">#</a> 6.6-registerBeanPostProcessors(beanFactory);</h5> <p>实例化和注册beanFactory中扩展了BeanPostProcessor的bean。</p> <p>例如：</p> <p>AutowiredAnnotationBeanPostProcessor(处理被@Autowired注解修饰的bean并注入)</p> <p>RequiredAnnotationBeanPostProcessor(处理被@Required注解修饰的方法)</p> <p>CommonAnnotationBeanPostProcessor(处理@PreDestroy、@PostConstruct、@Resource等多个注解的作用)等。</p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6585.png" alt="0"></p> <h5 id="_6-7-initmessagesource"><a href="#_6-7-initmessagesource" class="header-anchor">#</a> 6.7-initMessageSource()</h5> <p>// 初始化国际化资源处理器. 不是主线代码忽略，没什么学习价值。</p> <p>initMessageSource();</p> <h5 id="_6-8-initapplicationeventmulticaster"><a href="#_6-8-initapplicationeventmulticaster" class="header-anchor">#</a> 6.8-initApplicationEventMulticaster()</h5> <p>// 创建事件多播器</p> <p>事件相关会单独讲解：<a href="note://wcp1597739566991276">Spring事件监听机制</a></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6634.png" alt="0"></p> <h5 id="_6-9-onrefresh"><a href="#_6-9-onrefresh" class="header-anchor">#</a> 6.9-onRefresh();</h5> <p>模板方法，在容器刷新的时候可以自定义逻辑，不同的Spring容器做不同的事情。</p> <h5 id="_6-10-registerlisteners"><a href="#_6-10-registerlisteners" class="header-anchor">#</a> 6.10-registerListeners();</h5> <p>注册监听器，广播early application events</p> <p>事件相关会单独讲解：<a href="note://wcp1597739566991276">Spring事件监听机制</a></p> <p>​    <img src="https://404500.oss-cn-beijing.aliyuncs.com/picture/spring/6636.png" alt="0"></p> <h5 id="_6-11-finishbeanfactoryinitialization-beanfactory"><a href="#_6-11-finishbeanfactoryinitialization-beanfactory" class="header-anchor">#</a> 6-11-finishBeanFactoryInitialization(beanFactory);</h5> <p>实例化所有剩余的（非懒加载）单例</p> <p>比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。</p> <p>实例化的过程各种BeanPostProcessor开始起作用。</p> <p>这个方法是用来实例化懒加载单例Bean的，也就是我们的Bean都是在这里被创建出来的（当然我这里说的的是绝大部分情况是这样的）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>finishBeanFactoryInitialization(beanFactory);         
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p>我们再进入finishBeanFactoryInitialization这方法，里面有一个beanFactory.preInstantiateSingletons()方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        //初始化所有的非懒加载单例
        beanFactory.preInstantiateSingletons();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​</p> <p>我们尝试再点进去，这个时候你会发现这是一个接口，好在它只有一个实现类，所以可以我们来到了他的唯一实现，实现类就是org.springframework.beans.factory.support.DefaultListableBeanFactory，这里面是一个循环，我们的Bean就是循环被创建出来的，我们找到其中的getBean方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> getBean(beanName);     
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p>这里有一个分支，如果Bean是FactoryBean，如何如何，如果Bean不是FactoryBean如何如何，好在不管是不是FactoryBean，最终还是会调用getBean方法，所以我们可以毫不犹豫的点进去，点进去之后，你会发现，这是一个门面方法，直接调用了doGetBean方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return doGetBean(name, null, null, false);    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p>再进去，不断的深入，接近我们要寻找的东西。</p> <p>这里面的比较复杂，但是有我在，我可以直接告诉你，下一步我们要进入哪里，我们要进入</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (mbd.isSingleton()) {

                    //getSingleton中的第二个参数类型是ObjectFactory&lt;?&gt;，是一个函数式接口，不会立刻执行，而是在
                    //getSingleton方法中，调用ObjectFactory的getObject，才会执行createBean
                    sharedInstance = getSingleton(beanName, () -&gt; {
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这里面的createBean方法，再点进去啊，但是又点不进去了，这是接口啊，但是别慌，这个接口又只有一个实现类，所以说 没事，就是干，这个实现类为org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory。</p> <p>这个实现的方法里面又做了很多事情，我们就不去看了，我就是带着大家找到那几个生命周期的回调到底定义在哪里就OK了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  Object beanInstance = doCreateBean(beanName, mbdToUse, args);//创建bean，核心
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
            }
            return beanInstance;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>再继续深入doCreateBean方法，这个方法又做了一堆一堆的事情，但是值得开心的事情就是 我们已经找到了我们要寻找的东西了。</p> <p><strong>创建实例</strong></p> <p>首先是创建实例，位于：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>instanceWrapper = createBeanInstance(beanName, mbd, args);//创建bean的实例。核心  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p><strong>填充属性</strong></p> <p>其次是填充属性，位于：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>populateBean(beanName, mbd, instanceWrapper);//填充属性，炒鸡重要            
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在填充属性下面有一行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>exposedObject = initializeBean(beanName, exposedObject, mbd);       
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p>继续深入进去。</p> <p><strong>aware系列接口的回调</strong></p> <p>aware系列接口的回调位于initializeBean中的invokeAwareMethods方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>invokeAwareMethods(beanName, bean);
private void invokeAwareMethods(final String beanName, final Object bean) {
        if (bean instanceof Aware) {
            if (bean instanceof BeanNameAware) {
                ((BeanNameAware) bean).setBeanName(beanName);
            }
            if (bean instanceof BeanClassLoaderAware) {
                ClassLoader bcl = getBeanClassLoader();
                if (bcl != null) {
                    ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
                }
            }
            if (bean instanceof BeanFactoryAware) {
                ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
            }
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>BeanPostProcessor的postProcessBeforeInitialization方法</strong></p> <p>BeanPostProcessor的postProcessBeforeInitialization方法位于initializeBean的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
        }
    @Override
    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result = existingBean;
        for (BeanPostProcessor processor : getBeanPostProcessors()) {
            Object current = processor.postProcessBeforeInitialization(result, beanName);
            if (current == null) {
                return result;
            }
            result = current;
        }
        return result;
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>​</p> <p><strong>afterPropertiesSet init-method</strong></p> <p>afterPropertiesSet init-method位于initializeBean中的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> invokeInitMethods(beanName, wrappedBean, mbd);      
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​</p> <p>这里面调用了两个方法，一个是afterPropertiesSet方法，一个是init-method方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> ((InitializingBean) bean).afterPropertiesSet();
 invokeCustomInitMethod(beanName, bean, mbd);        
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​</p> <p><strong>BeanPostProcessor的postProcessAfterInitialization方法</strong></p> <p>BeanPostProcessor的postProcessAfterInitialization方法位于initializeBean的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        }
    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result = existingBean;
        for (BeanPostProcessor processor : getBeanPostProcessors()) {
            Object current = processor.postProcessAfterI nitialization(result, beanName);
            if (current == null) {
                return result;
            }
            result = current;
        }
        return result;
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>当然在实际的开发中，应该没人会去销毁Spring的应用上下文把，所以剩余的两个销毁的回调就不去找了。</p> <h3 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="header-anchor">#</a> <strong>Spring Bean的生命周期</strong></h3> <p>Spring In Action以及市面上流传的大部分博客是这样的：</p> <ol><li>实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，可以理解为连Autowired注解都是没有解析的；</li> <li>填充属性，当做完这一步，Bean对象基本是完整的了，可以理解为Autowired注解已经解析完毕，依赖注入完成了；</li> <li>如果Bean实现了BeanNameAware接口，则调用setBeanName方法；</li> <li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法；</li> <li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法；</li> <li>调用BeanPostProcessor的postProcessBeforeInitialization方法；</li> <li>如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法；</li> <li>如果Bean定义了init-method方法，则调用Bean的init-method方法；</li> <li>调用BeanPostProcessor的postProcessAfterInitialization方法；当进行到这一步，Bean已经被准备就绪了，一直停留在应用的上下文中，直到被销毁；</li> <li>如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean定义了destory-method声明了销毁方法也会被调用。</li></ol> <p>为了验证上面的逻辑，可以做个试验：</p> <p>首先定义了一个Bean，里面有各种回调和钩子，其中需要注意下，我在SpringBean的构造方法中打印了studentService，看SpringBean被new的出来的时候，studentService是否被注入了；又在setBeanName中打印了studentService，看此时studentService是否被注入了，以此来验证，Bean是何时完成的自动注入的（这个StudentServiceImpl 类的代码就不贴出来了，无非就是一个最普通的Bean）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class SpringBean implements InitializingBean, DisposableBean, BeanNameAware, BeanFactoryAware, BeanClassLoaderAware {

    public SpringBean() {
        System.out.println(&quot;SpringBean构造方法:&quot; + studentService);
        System.out.println(&quot;SpringBean构造方法&quot;);
    }

    @Autowired
    StudentServiceImpl studentService;

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;afterPropertiesSet&quot;);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;destroy&quot;);
    }

    @Override
    public void setBeanClassLoader(ClassLoader classLoader) {
        System.out.println(&quot;setBeanClassLoader&quot;);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;setBeanFactory&quot;);
    }

    @Override
    public void setBeanName(String name) {
        System.out.println(&quot;setBeanName:&quot; + studentService);
        System.out.println(&quot;setBeanName&quot;);
    }

    public void initMethod() {
        System.out.println(&quot;initMethod&quot;);
    }

    public void destroyMethod() {
        System.out.println(&quot;destroyMethod&quot;);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>再定义一个BeanPostProcessor，在重写的两个方法中进行了判断，如果传进来的beanName是springBean才进行打印：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if(beanName.equals(&quot;springBean&quot;)) {
            System.out.println(&quot;postProcessBeforeInitialization&quot;);
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if(beanName.equals(&quot;springBean&quot;)) {
            System.out.println(&quot;postProcessAfterInitialization&quot;);
        }
        return bean;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​</p> <p>定义一个配置类，完成自动扫描，但是SpringBean是手动注册的，并且声明了initMethod和destroyMethod：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Configuration
@ComponentScan
public class AppConfig {
    @Bean(initMethod = &quot;initMethod&quot;,destroyMethod = &quot;destroyMethod&quot;)
    public SpringBean springBean() {
        return new SpringBean();
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>最后就是启动类了：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationConfigApplicationContext =
                new AnnotationConfigApplicationContext(AppConfig.class);
        annotationConfigApplicationContext.destroy();
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​</p> <p>运行结果：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>SpringBean构造方法:null
SpringBean构造方法
setBeanName:com.codebear.StudentServiceImpl@31190526
setBeanName
setBeanClassLoader
setBeanFactory
postProcessBeforeInitialization
afterPropertiesSet
initMethod
postProcessAfterInitialization
destroy
destroyMethod
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​</p> <p>可以看到，试验结果和上面分析的完全一致。</p> <p>这就是广为流传的Spring生命周期。</p> <p>也许你在应付面试的时候，是死记硬背这些结论的，现在我带着你找到这些方法，跟我来。</p> <p><strong>6-12-finishRefresh();</strong></p> <p>refresh做完之后需要做的其他事情。</p> <p>清除上下文资源缓存（如扫描中的ASM元数据）</p> <p>初始化上下文的生命周期处理器，并刷新（找出Spring容器中实现了Lifecycle接口的bean并执行start()方法）。</p> <p>发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>protected void finishRefresh() {
    // Initialize lifecycle processor for this context.
    // 1.为此上下文初始化生命周期处理器
    initLifecycleProcessor();
 
    // Propagate refresh to lifecycle processor first.
    // 2.首先将刷新完毕事件传播到生命周期处理器（触发isAutoStartup方法返回true的SmartLifecycle的start方法）
    getLifecycleProcessor().onRefresh();
 
    // Publish the final event.
    // 3.推送上下文刷新完毕事件到相应的监听器
    publishEvent(new ContextRefreshedEvent(this));
 
    // Participate in LiveBeansView MBean, if active.
    LiveBeansView.registerApplicationContext(this);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这里单独介绍下publishEvent</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Override
public void publishEvent(ApplicationEvent event) {
    publishEvent(event, null);
}
 
protected void publishEvent(Object event, ResolvableType eventType) {
    Assert.notNull(event, &quot;Event must not be null&quot;);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Publishing event in &quot; + getDisplayName() + &quot;: &quot; + event);
    }
 
    // Decorate event as an ApplicationEvent if necessary
    // 1.如有必要，将事件装饰为ApplicationEvent
    ApplicationEvent applicationEvent;
    if (event instanceof ApplicationEvent) {
        applicationEvent = (ApplicationEvent) event;
    } else {
        applicationEvent = new PayloadApplicationEvent&lt;Object&gt;(this, event);
        if (eventType == null) {
            eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();
        }
    }
 
    // Multicast right now if possible - or lazily once the multicaster is initialized
    if (this.earlyApplicationEvents != null) {
        this.earlyApplicationEvents.add(applicationEvent);
    } else {
        // 2.使用事件广播器广播事件到相应的监听器
        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
    }
 
    // Publish event via parent context as well...
    // 3.同样的，通过parent发布事件......
    if (this.parent != null) {
        if (this.parent instanceof AbstractApplicationContext) {
            ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
        } else {
            this.parent.publishEvent(event);
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>​</p> <p>2.使用事件广播器广播事件到相应的监听器<strong>multicastEvent</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Override
public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    // 1.getApplicationListeners：返回与给定事件类型匹配的应用监听器集合
    for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
        // 2.返回此广播器的当前任务执行程序
        Executor executor = getTaskExecutor();
        if (executor != null) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    // 3.1 executor不为null，则使用executor调用监听器
                    invokeListener(listener, event);
                }
            });
        } else {
            // 3.2 否则，直接调用监听器
            invokeListener(listener, event);
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>​</p> <p>3.2 调用监听器<strong>invokeListener</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>protected void invokeListener(ApplicationListener&lt;?&gt; listener, ApplicationEvent event) {
    // 1.返回此广播器的当前错误处理程序
    ErrorHandler errorHandler = getErrorHandler();
    if (errorHandler != null) {
        try {
            // 2.1 如果errorHandler不为null，则使用带错误处理的方式调用给定的监听器
            doInvokeListener(listener, event);
        } catch (Throwable err) {
            errorHandler.handleError(err);
        }
    } else {
        // 2.2 否则，直接调用调用给定的监听器
        doInvokeListener(listener, event);
    }
}
 
private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
    try {
        // 触发监听器的onApplicationEvent方法，参数为给定的事件
        listener.onApplicationEvent(event);
    } catch (ClassCastException ex) {
        String msg = ex.getMessage();
        if (msg == null || msg.startsWith(event.getClass().getName())) {
            // Possibly a lambda-defined listener which we could not resolve the generic event type for
            Log logger = LogFactory.getLog(getClass());
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Non-matching event type for listener: &quot; + listener, ex);
            }
        } else {
            throw ex;
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>这样，当 Spring 执行到 finishRefresh 方法时，就会将 ContextRefreshedEvent 事件推送到 MyRefreshedListener 中。</p> <p>跟 ContextRefreshedEvent 相似的还有：ContextStartedEvent、ContextClosedEvent、ContextStoppedEvent，有兴趣的可以自己看看这几个事件的使用场景。</p> <p>当然，我们也可以自定义监听事件，只需要继承 ApplicationContextEvent 抽象类即可。</p></div></div>  <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/615c1c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Spring核心API</div></a> <a href="/pages/e5e86f/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Spring AOP</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/615c1c/" class="prev">Spring核心API</a></span> <span class="next"><a href="/pages/e5e86f/">Spring AOP</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/80365f/"><div>
            证券市场基本法律法规
            <!----></div></a> <span class="date">03-13</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/d9e4f4/"><div>
            证券考试规则
            <!----></div></a> <span class="date">03-12</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/cb2c17/"><div>
            金融市场基础知识
            <!----></div></a> <span class="date">03-12</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:cloudjava@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/bigdatajava" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://gitee.com/nylg" title="Gitee" target="_blank" class="iconfont icon-gitee"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2014-2025
    <span>wen chao | <a href="https://github.com/bigdatajava/blog-talk/blob/main/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.af2629f3.js" defer></script><script src="/assets/js/2.c7acc05c.js" defer></script><script src="/assets/js/216.d76003a4.js" defer></script>
  </body>
</html>
